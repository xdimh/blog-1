{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/weekly/source/CNAME","path":"CNAME","modified":1,"renderable":1},{"_id":"themes/weekly/source/README","path":"README","modified":1,"renderable":1},{"_id":"themes/weekly/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/weekly/source/google72609e781836c3c8.html","path":"google72609e781836c3c8.html","modified":1,"renderable":1},{"_id":"themes/weekly/source/robots.txt","path":"robots.txt","modified":1,"renderable":1},{"_id":"themes/weekly/source/css/github-markdown.css","path":"css/github-markdown.css","modified":1,"renderable":1},{"_id":"themes/weekly/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/weekly/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/weekly/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/weekly/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/weekly/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/weekly/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/weekly/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/weekly/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/weekly/.DS_Store","hash":"9457f542cf2c3f2a50b9ecd64858fc6f50b0d0c4","modified":1493138401000},{"_id":"themes/weekly/README.md","hash":"86c7d03224177bb5f5668eef21b0e2b298095690","modified":1492559134000},{"_id":"themes/weekly/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1492559134000},{"_id":"themes/weekly/_config.yml","hash":"bab129a369c4f89d116478283561e5d09ac5f6fc","modified":1519654155000},{"_id":"source/_drafts/webkit-text-size-adjust.md","hash":"0458404a7792eefa0f0733c7c5e5720cea039acc","modified":1501566281000},{"_id":"source/_posts/base64.md","hash":"d6f97cdc2837cfc11694c14ea80f889e89d085ce","modified":1493790791000},{"_id":"source/_drafts/talk-h5-performance-lightly.md","hash":"6d110ea3af46ddba6211227268b034699889a953","modified":1501566247000},{"_id":"source/_posts/event-proxy.md","hash":"9c0cd368c149aae64f5510ec0000a5822c1abb4c","modified":1494341515000},{"_id":"source/_posts/fe-event-loop.md","hash":"a7ec863d16b7feb293dabfd62e6ce5ee56f080bd","modified":1494341522000},{"_id":"source/_posts/git-and-npm.md","hash":"3a781ffd66c6fd3a27a40314609b01437940042f","modified":1501566006000},{"_id":"source/_posts/gulp-prefix.md","hash":"6e175eb36e159425eeb9952bf81641b5318942d7","modified":1493790800000},{"_id":"source/_posts/gulp-plugin-develop.md","hash":"5b3cde0893c5d486e34bd4316e1ec82d8d896209","modified":1493790796000},{"_id":"source/_posts/mongoose-tutorial-1.md","hash":"beeb77161702a37ff3bfb3de0b48f84eee2413df","modified":1494254445000},{"_id":"source/_posts/javascript-event-loop.md","hash":"b64e4afcdd8924232e7458b5a5b92caedb9a88e8","modified":1493996103000},{"_id":"source/_posts/node-stream.md","hash":"3dc274a75fffe1869034d2152d7781020eaee6cf","modified":1493781693000},{"_id":"source/_posts/mongoose-tutorial-2.md","hash":"4e9ea5b9899437ddab4c3f57551a2be694d7bced","modified":1494254445000},{"_id":"source/_posts/ngrok.md","hash":"63de82b38dda8854bf56ffe4ac54d0e36f86c007","modified":1493790808000},{"_id":"source/_posts/react-life-cycle.md","hash":"becc51a34bcb9cf618686fe995cb8f813f1c4331","modified":1493790813000},{"_id":"source/_posts/regular-expression.md","hash":"ccebc0e6f56a367fa4981088f95501c1cedaa89d","modified":1493790824000},{"_id":"source/_posts/redux-introduction.md","hash":"a88dfb89ce0c73345d91ea2e298aec48e0d5c2a3","modified":1493790818000},{"_id":"source/_posts/rn-dev-prepare.md","hash":"98f6ff0e5424585e4806f4be012682e081f6c4be","modified":1493790827000},{"_id":"source/_posts/rn-introduction.md","hash":"8f1d654342bca4a828bd88df8ddcb4ab2cd14ad8","modified":1493790832000},{"_id":"source/_posts/webpack1-to-webpack2.md","hash":"982cd92f207bd044e85f2496eb7444f691edce35","modified":1519659872000},{"_id":"themes/weekly/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1492559134000},{"_id":"themes/weekly/layout/base-without-sidebar.jade","hash":"60b5a70f7c61c91aca9fbf813bde26096ef4028f","modified":1492559134000},{"_id":"themes/weekly/layout/base.jade","hash":"41f3a0f5e3c5b722de9d058c458822e5122384e1","modified":1492559134000},{"_id":"themes/weekly/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1492559134000},{"_id":"themes/weekly/layout/post.jade","hash":"59c68e6219be008b447b134f1b226e5ea35a9794","modified":1519663393000},{"_id":"themes/weekly/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1492559134000},{"_id":"themes/weekly/layout/index.jade","hash":"2d40b673a03c49408724dd9748c8bc0a68259983","modified":1492559134000},{"_id":"themes/weekly/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1492559134000},{"_id":"themes/weekly/languages/en.yml","hash":"e77e1dbdf77ee071c688e46219b593e1a6e1fc41","modified":1492559134000},{"_id":"themes/weekly/layout/timeline.jade","hash":"649281ace58d7ff08a6ecb10606799ae2f77bb38","modified":1492559134000},{"_id":"themes/weekly/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1492559134000},{"_id":"themes/weekly/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1492559134000},{"_id":"themes/weekly/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1492559134000},{"_id":"themes/weekly/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1492559134000},{"_id":"themes/weekly/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1492559134000},{"_id":"themes/weekly/languages/zh-CN.yml","hash":"765fb91a2b8771d46baf0668e9a0b21c919f3776","modified":1493189498000},{"_id":"themes/weekly/source/.DS_Store","hash":"1429b9c08aeb8c15b3499d150e011720f8ff275c","modified":1494987249000},{"_id":"themes/weekly/source/CNAME","hash":"262c2ec1c887434f6dc470bf058edd5dcb28ecf5","modified":1493217374000},{"_id":"themes/weekly/source/README","hash":"6d9077ac3eeb5be470a8a8d44bfb7603601d6755","modified":1493217818000},{"_id":"themes/weekly/source/favicon.ico","hash":"9f6b5349a55b8f95eaec82327d76268f9800f41e","modified":1493138201000},{"_id":"themes/weekly/source/google72609e781836c3c8.html","hash":"e169e442d40249fd885017cf89bdc125dfd2981c","modified":1494252166000},{"_id":"themes/weekly/source/robots.txt","hash":"bca460c801f999c7ca706630aa448925c0eab623","modified":1493994786000},{"_id":"source/about/index.md","hash":"f5fe8a098f7c60b81df059d5e46dfaf609344fb4","modified":1494118673000},{"_id":"themes/weekly/layout/_partial/head.jade","hash":"8f92e0517f92ca93676da2c189a33befbe86fcba","modified":1519663393000},{"_id":"themes/weekly/layout/_partial/after_footer.jade","hash":"4a2f73a33481784073ec914cfec4d41317caa4fa","modified":1519663414000},{"_id":"themes/weekly/layout/_partial/footer.jade","hash":"cdf27556d2d851995bb11c221180c61c7ca15e7f","modified":1493178344000},{"_id":"themes/weekly/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1492559134000},{"_id":"themes/weekly/layout/_partial/helpers.jade","hash":"0ae75c6f323ab2b311a3bfdc9d974fa10c2dff29","modified":1493132307000},{"_id":"themes/weekly/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1492559134000},{"_id":"themes/weekly/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1492559134000},{"_id":"themes/weekly/layout/_partial/totop.jade","hash":"94c10d36bed7daf03ba136100d02453993046ce7","modified":1519663425000},{"_id":"themes/weekly/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1492559134000},{"_id":"themes/weekly/layout/_partial/tag.jade","hash":"62247a310f101b3749b49f68259934bde08b7379","modified":1493135123000},{"_id":"themes/weekly/layout/_widget/links.jade","hash":"046d26b175c0f222a54ffa90ab95602bd195b6eb","modified":1493174363000},{"_id":"themes/weekly/layout/_widget/category.jade","hash":"8e92c3765ff326bb94302d7aedb96a53e5baced2","modified":1493134865000},{"_id":"themes/weekly/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1492559134000},{"_id":"themes/weekly/layout/_widget/recent_posts.jade","hash":"0c5d8553fbe526892bf17ae067e32c2c621b9838","modified":1493174364000},{"_id":"themes/weekly/layout/_widget/search.jade","hash":"06c0d6dd560222f8677a54bd05cf79857e01e3de","modified":1493192287000},{"_id":"themes/weekly/layout/_partial/comments.jade","hash":"cfa421beb0a118eb078de6a48db9787fac74fd2d","modified":1493136341000},{"_id":"themes/weekly/layout/_widget/tag.jade","hash":"465de97fc6bf069dd6754db63130fafe02996ba7","modified":1493174317000},{"_id":"themes/weekly/source/css/_markdown.scss","hash":"15beca7536fcd397304ef6b82aaa0dcffcb7d85e","modified":1493170142000},{"_id":"themes/weekly/source/css/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1493171586000},{"_id":"themes/weekly/source/css/github-markdown.css","hash":"30f0b0ef50e2cf79aea49c21e4b77b05a0865967","modified":1491050598000},{"_id":"themes/weekly/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1492559134000},{"_id":"themes/weekly/source/css/style.scss","hash":"b428d4a50700cb34c6b2e840f638148d75dc8075","modified":1493790597000},{"_id":"themes/weekly/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1492559134000},{"_id":"themes/weekly/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1492559134000},{"_id":"themes/weekly/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1492559134000},{"_id":"themes/weekly/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1492559134000},{"_id":"themes/weekly/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1492559134000},{"_id":"themes/weekly/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1492559134000},{"_id":"public/baidu_urls.txt","hash":"abd2d56eea3937975bcdb82b2fbe2c3fc0285720","modified":1519663443776},{"_id":"public/baidusitemap.xml","hash":"4719c9919cf00df522285660e17d48cea645614e","modified":1519663443800},{"_id":"public/search.xml","hash":"03f91fa971f40e3dd19d87724a1dd092fcc0cda8","modified":1519663443801},{"_id":"public/sitemap.xml","hash":"86a525a16f31d32e8de3a3a5e8c1f2dd447193e2","modified":1519663443801},{"_id":"public/about/index.html","hash":"c30d0db33ce4fe0d38f0a74e272b7a2214f86b61","modified":1519663443815},{"_id":"public/2017/04/26/react-life-cycle/index.html","hash":"1426665e554129f1f33bb300e140cbc0c30ae5cc","modified":1519663443815},{"_id":"public/2017/04/26/ngrok/index.html","hash":"8b36726bda0c125eed0f2ed6979fa886e962fb35","modified":1519663443816},{"_id":"public/2017/04/26/rn-dev-prepare/index.html","hash":"b7d288029be26cacbfcbeaeb12d811e94d8607f4","modified":1519663443816},{"_id":"public/archives/index.html","hash":"a9018e6926da6665e8db370335e8d683f482543d","modified":1519663443817},{"_id":"public/archives/2017/index.html","hash":"a9018e6926da6665e8db370335e8d683f482543d","modified":1519663443817},{"_id":"public/archives/2017/04/index.html","hash":"675e07341020d9da40ceb650c80422475214cc56","modified":1519663443817},{"_id":"public/archives/2017/05/index.html","hash":"457b668bfd867ff5a441c21f8689a5a345f3e9d3","modified":1519663443817},{"_id":"public/archives/2017/06/index.html","hash":"d78ae0ecbe97348204a31bdb1a7337941d687068","modified":1519663443817},{"_id":"public/categories/NodeJS/index.html","hash":"e0a23965e4ef6c8d9248c433464710d497900234","modified":1519663443817},{"_id":"public/categories/前端大杂烩/index.html","hash":"64330f6462cc600b3c2d655029e39026be8658dc","modified":1519663443817},{"_id":"public/categories/NodeJS/nodeclub源码学习/index.html","hash":"6ea8bdbbc21c74d176a303c2faff9e3c00d007e8","modified":1519663443817},{"_id":"public/categories/nodeclub源码学习/index.html","hash":"5deea52165129547961256c7c7ada5e192190c1f","modified":1519663443817},{"_id":"public/categories/NodeJS/前端大杂烩/index.html","hash":"2e0c614709b97c6d6ac11a5324507232b28c9b0e","modified":1519663443817},{"_id":"public/categories/React/index.html","hash":"daff94d2800ee0057c1d5381e3ae80a331046da6","modified":1519663443817},{"_id":"public/categories/React-Native/index.html","hash":"9e05a5300362447218f3f1a22c03856b4b9aee9d","modified":1519663443817},{"_id":"public/categories/构建工具/index.html","hash":"4724a19d02c947ec8be61f376a4a0a58618f0fd5","modified":1519663443817},{"_id":"public/categories/构建工具/前端大杂烩/index.html","hash":"7a00b4a18ddced5f20034882406b6eb8abb237c5","modified":1519663443818},{"_id":"public/page/2/index.html","hash":"3fb89bb2eea6980871efc8f05d6cd6040437d7c0","modified":1519663443818},{"_id":"public/tags/JavaScript/index.html","hash":"1654b1868f008cc58628fd121ca219a998a04ac1","modified":1519663443818},{"_id":"public/tags/NodeJS/index.html","hash":"e0a23965e4ef6c8d9248c433464710d497900234","modified":1519663443819},{"_id":"public/tags/前端大杂烩/index.html","hash":"b8fdf1ff419d1d89eaaadd4d3facafcad316dcb2","modified":1519663443819},{"_id":"public/tags/git/index.html","hash":"90aaa009c4ff9a37bdbca03cc7688380f1d7f913","modified":1519663443819},{"_id":"public/tags/npm/index.html","hash":"33a08d3552907e1744b5382b5aaee0306125ab1b","modified":1519663443819},{"_id":"public/tags/Mongoose/index.html","hash":"f1eed06efc9e30ab35e97e8d68752c30d822f840","modified":1519663443819},{"_id":"public/tags/Mongodb/index.html","hash":"0a07262f4157d04b59631f22ee5a50ab913cdd7b","modified":1519663443819},{"_id":"public/tags/React/index.html","hash":"daff94d2800ee0057c1d5381e3ae80a331046da6","modified":1519663443819},{"_id":"public/tags/React-Native/index.html","hash":"9e05a5300362447218f3f1a22c03856b4b9aee9d","modified":1519663443819},{"_id":"public/tags/webpack/index.html","hash":"25b4e9c670aad0c3b14acefc1da570f0a0fb0499","modified":1519663443819},{"_id":"public/2017/06/24/git-and-npm/index.html","hash":"f3cc42b52e966ebff98119254274c9eab9d8eab7","modified":1519663443819},{"_id":"public/2017/05/08/webpack1-to-webpack2/index.html","hash":"ad46882a28eaedead7c00472cc505d2c981030cd","modified":1519663443819},{"_id":"public/2017/05/06/event-proxy/index.html","hash":"a03a6b64f3b038bde59f8cca97f6039718228892","modified":1519663443820},{"_id":"public/2017/05/05/fe-event-loop/index.html","hash":"5bafdfdf95de459e30dc12d991175a25a07b34d0","modified":1519663443820},{"_id":"public/2017/05/03/javascript-event-loop/index.html","hash":"21761ad95aaeae0df6a19b2a48f94ddca65d69cf","modified":1519663443821},{"_id":"public/2017/04/27/mongoose-tutorial-2/index.html","hash":"af83c41c482bfa2ea141a0fd8b5672d984ea3d3e","modified":1519663443821},{"_id":"public/2017/04/26/redux-introduction/index.html","hash":"45f91c85921b40bad8141989b260b28b463d35d4","modified":1519663443821},{"_id":"public/2017/04/26/regular-expression/index.html","hash":"cc04f424c3cfe132592ba452bc765c48c5accaa7","modified":1519663443821},{"_id":"public/2017/04/26/base64/index.html","hash":"d488fac483def90f4298672285ca9602836bbd38","modified":1519663443821},{"_id":"public/2017/04/26/gulp-plugin-develop/index.html","hash":"7866a0f575d3a74873a58d358a86d3ca29ef354a","modified":1519663443821},{"_id":"public/2017/04/26/gulp-prefix/index.html","hash":"dbcc7c5e823e74d8636750071c7bb5f7db1cb5ad","modified":1519663443821},{"_id":"public/2017/04/26/rn-introduction/index.html","hash":"84f26351d376d628d05ad8d382d0933f9421a9f3","modified":1519663443821},{"_id":"public/2017/04/26/node-stream/index.html","hash":"41993691488f4db94ef73f191e6d3f5d8d929189","modified":1519663443821},{"_id":"public/2017/04/26/mongoose-tutorial-1/index.html","hash":"42738f8097146fe292c1648cccaf5bfe9eba41fb","modified":1519663443821},{"_id":"public/index.html","hash":"849128bcfe92b3cf07c0116c9af5b3547fd103bc","modified":1519663443821},{"_id":"public/CNAME","hash":"262c2ec1c887434f6dc470bf058edd5dcb28ecf5","modified":1519663443828},{"_id":"public/README","hash":"6d9077ac3eeb5be470a8a8d44bfb7603601d6755","modified":1519663443828},{"_id":"public/favicon.ico","hash":"9f6b5349a55b8f95eaec82327d76268f9800f41e","modified":1519663443828},{"_id":"public/robots.txt","hash":"bca460c801f999c7ca706630aa448925c0eab623","modified":1519663443829},{"_id":"public/google72609e781836c3c8.html","hash":"e169e442d40249fd885017cf89bdc125dfd2981c","modified":1519663443889},{"_id":"public/css/github-markdown.css","hash":"30f0b0ef50e2cf79aea49c21e4b77b05a0865967","modified":1519663443889},{"_id":"public/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1519663443889},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1519663443889},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1519663443889},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1519663443889},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1519663443890},{"_id":"public/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1519663443890},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1519663443890},{"_id":"public/css/style.css","hash":"4ff3d583d701f38e2b5fe9d1ecd8147c93204e4a","modified":1519663443890}],"Category":[{"name":"NodeJS","_id":"cje4gdhph0003b37qm3kj55hf"},{"name":"前端大杂烩","_id":"cje4gdhpu0008b37qg9v7mofd"},{"name":"nodeclub源码学习","parent":"cje4gdhph0003b37qm3kj55hf","_id":"cje4gdhq5000cb37qdsfoc34x"},{"name":"nodeclub源码学习","_id":"cje4gdhqw000zb37qo9sg5fj7"},{"name":"前端大杂烩","parent":"cje4gdhph0003b37qm3kj55hf","_id":"cje4gdhrg001gb37qkoj8yx91"},{"name":"React","_id":"cje4gdhrp001tb37q3s24vujn"},{"name":"React Native","_id":"cje4gdhrs001xb37q213qtu0t"},{"name":"构建工具","_id":"cje4gdhrw0025b37qw8rhhjij"},{"name":"前端大杂烩","parent":"cje4gdhrw0025b37qw8rhhjij","_id":"cje4gdhrz002cb37qai1fbyw3"}],"Data":[],"Page":[{"title":"关于作者","date":"2017-04-24T23:05:04.000Z","comments":0,"_content":"\n![JUST DO IT(还在做IT)](http://rainypin.qiniudn.com/blog/images/avatar.jpeg)\n\n### 作者\n\n~Refresh,深陷前端泥潭中,不能自拔。\n\n### 一句话介绍\n\n生活不止眼前的苟且，还有读不懂的诗和到不了的远方。\n\n### 居住地\n\n杭州\n\n### 所在行业\n\n互联网\n\n### 职业经历\n\n2015.4-2016.8 网易.易信.前端工程师\n\n### 教育经历\n\n北京邮电大学.计算机技术\n\n### GitHub & 邮箱\nhttps://github.com/xdimh\nxdimhf@163.com","source":"about/index.md","raw":"---\ntitle: 关于作者\ndate: 2017-04-25 07:05:04\ncomments: false\n---\n\n![JUST DO IT(还在做IT)](http://rainypin.qiniudn.com/blog/images/avatar.jpeg)\n\n### 作者\n\n~Refresh,深陷前端泥潭中,不能自拔。\n\n### 一句话介绍\n\n生活不止眼前的苟且，还有读不懂的诗和到不了的远方。\n\n### 居住地\n\n杭州\n\n### 所在行业\n\n互联网\n\n### 职业经历\n\n2015.4-2016.8 网易.易信.前端工程师\n\n### 教育经历\n\n北京邮电大学.计算机技术\n\n### GitHub & 邮箱\nhttps://github.com/xdimh\nxdimhf@163.com","updated":"2017-05-07T00:57:53.000Z","path":"about/index.html","layout":"page","_id":"cje4gdirb002kb37q9x6e2lpm","content":"<p><img src=\"http://rainypin.qiniudn.com/blog/images/avatar.jpeg\" alt=\"JUST DO IT(还在做IT)\"></p>\n<h3 id=\"作者\"><a href=\"#作者\" class=\"headerlink\" title=\"作者\"></a>作者</h3><p>~Refresh,深陷前端泥潭中,不能自拔。</p>\n<h3 id=\"一句话介绍\"><a href=\"#一句话介绍\" class=\"headerlink\" title=\"一句话介绍\"></a>一句话介绍</h3><p>生活不止眼前的苟且，还有读不懂的诗和到不了的远方。</p>\n<h3 id=\"居住地\"><a href=\"#居住地\" class=\"headerlink\" title=\"居住地\"></a>居住地</h3><p>杭州</p>\n<h3 id=\"所在行业\"><a href=\"#所在行业\" class=\"headerlink\" title=\"所在行业\"></a>所在行业</h3><p>互联网</p>\n<h3 id=\"职业经历\"><a href=\"#职业经历\" class=\"headerlink\" title=\"职业经历\"></a>职业经历</h3><p>2015.4-2016.8 网易.易信.前端工程师</p>\n<h3 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h3><p>北京邮电大学.计算机技术</p>\n<h3 id=\"GitHub-amp-邮箱\"><a href=\"#GitHub-amp-邮箱\" class=\"headerlink\" title=\"GitHub &amp; 邮箱\"></a>GitHub &amp; 邮箱</h3><p><a href=\"https://github.com/xdimh\" target=\"_blank\" rel=\"external\">https://github.com/xdimh</a><br>xdimhf@163.com</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://rainypin.qiniudn.com/blog/images/avatar.jpeg\" alt=\"JUST DO IT(还在做IT)\"></p>\n<h3 id=\"作者\"><a href=\"#作者\" class=\"headerlink\" title=\"作者\"></a>作者</h3><p>~Refresh,深陷前端泥潭中,不能自拔。</p>\n<h3 id=\"一句话介绍\"><a href=\"#一句话介绍\" class=\"headerlink\" title=\"一句话介绍\"></a>一句话介绍</h3><p>生活不止眼前的苟且，还有读不懂的诗和到不了的远方。</p>\n<h3 id=\"居住地\"><a href=\"#居住地\" class=\"headerlink\" title=\"居住地\"></a>居住地</h3><p>杭州</p>\n<h3 id=\"所在行业\"><a href=\"#所在行业\" class=\"headerlink\" title=\"所在行业\"></a>所在行业</h3><p>互联网</p>\n<h3 id=\"职业经历\"><a href=\"#职业经历\" class=\"headerlink\" title=\"职业经历\"></a>职业经历</h3><p>2015.4-2016.8 网易.易信.前端工程师</p>\n<h3 id=\"教育经历\"><a href=\"#教育经历\" class=\"headerlink\" title=\"教育经历\"></a>教育经历</h3><p>北京邮电大学.计算机技术</p>\n<h3 id=\"GitHub-amp-邮箱\"><a href=\"#GitHub-amp-邮箱\" class=\"headerlink\" title=\"GitHub &amp; 邮箱\"></a>GitHub &amp; 邮箱</h3><p><a href=\"https://github.com/xdimh\" target=\"_blank\" rel=\"external\">https://github.com/xdimh</a><br>xdimhf@163.com</p>\n"}],"Post":[{"title":"谜之样式属性:text-size-adjust","type":"original","date":"2017-08-01T05:43:20.000Z","description":null,"_content":"\n","source":"_drafts/webkit-text-size-adjust.md","raw":"---\ntitle: 谜之样式属性:text-size-adjust \ntype: original\ntags: []\ncategories: []\ndate: 2017-08-01 13:43:20\ndescription:\n---\n\n","slug":"webkit-text-size-adjust","published":0,"updated":"2017-08-01T05:44:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhoy0000b37qu3suy2sa","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"eventproxy 源码解析","type":"original","date":"2017-05-06T08:09:19.000Z","description":null,"_content":"\n\nEventProxy 仅仅是一个很轻量的工具，但是能够带来一种事件式编程的思维变化。有几个特点：\n\n1. 利用事件机制解耦复杂业务逻辑\n2. 移除被广为诟病的深度callback嵌套问题\n3. 将串行等待变成并行等待，提升多异步协作场景下的执行效率\n4. 友好的Error handling\n5. 无平台依赖，适合前后端，能用于浏览器和Node.js\n6. 兼容CMD，AMD以及CommonJS模块环境\n\n在nodeclub源码中有一段实现代码如下:\n\n```javascript\n// nodeclub 首页路由处理函数\nexports.index = function (req, res, next) {\n  var page = parseInt(req.query.page, 10) || 1;\n  page = page > 0 ? page : 1;\n  var tab = req.query.tab || 'all';\n\n  var proxy = new eventproxy();\n  proxy.fail(next);\n\n  // 取主题\n  var query = {};\n  if (!tab || tab === 'all') {\n    query.tab = {$ne: 'job'}\n  } else {\n    if (tab === 'good') {\n      query.good = true;\n    } else {\n      query.tab = tab;\n    }\n  }\n\n  var limit = config.list_topic_count;\n  var options = { skip: (page - 1) * limit, limit: limit, sort: '-top -last_reply_at'};\n\n  Topic.getTopicsByQuery(query, options, proxy.done('topics', function (topics) {\n    return topics;\n  }));\n\n  // 取排行榜上的用户\n  cache.get('tops', proxy.done(function (tops) {\n    if (tops) {\n      proxy.emit('tops', tops);\n    } else {\n      User.getUsersByQuery(\n        {is_block: false},\n        { limit: 10, sort: '-score'},\n        proxy.done('tops', function (tops) {\n          cache.set('tops', tops, 60 * 1);\n          return tops;\n        })\n      );\n    }\n  }));\n  // END 取排行榜上的用户\n\n  // 取0回复的主题\n  cache.get('no_reply_topics', proxy.done(function (no_reply_topics) {\n    if (no_reply_topics) {\n      proxy.emit('no_reply_topics', no_reply_topics);\n    } else {\n      Topic.getTopicsByQuery(\n        { reply_count: 0, tab: {$ne: 'job'}},\n        { limit: 5, sort: '-create_at'},\n        proxy.done('no_reply_topics', function (no_reply_topics) {\n          cache.set('no_reply_topics', no_reply_topics, 60 * 1);\n          return no_reply_topics;\n        }));\n    }\n  }));\n  // END 取0回复的主题\n\n  // 取分页数据\n  var pagesCacheKey = JSON.stringify(query) + 'pages';\n  cache.get(pagesCacheKey, proxy.done(function (pages) {\n    if (pages) {\n      proxy.emit('pages', pages);\n    } else {\n      Topic.getCountByQuery(query, proxy.done(function (all_topics_count) {\n        var pages = Math.ceil(all_topics_count / limit);\n        cache.set(pagesCacheKey, pages, 60 * 1);\n        proxy.emit('pages', pages);\n      }));\n    }\n  }));\n  // END 取分页数据\n\n  var tabName = renderHelper.tabName(tab);\n  proxy.all('topics', 'tops', 'no_reply_topics', 'pages',\n    function (topics, tops, no_reply_topics, pages) {\n      res.render('index', {\n        topics: topics,\n        current_page: page,\n        list_topic_count: limit,\n        tops: tops,\n        no_reply_topics: no_reply_topics,\n        pages: pages,\n        tabs: config.tabs,\n        tab: tab,\n        pageTitle: tabName && (tabName + '版块'),\n      });\n    });\n};\n```\n\n代码中看到了 ``proxy.emit('ev')`` , ``proxy.done('ev',fn)``,``proxy.fail(next)`` 所以要看懂这段代码,就必须了解eventproxy使用方法(当然可以猜测具体的作用)。查看了GitHub上的README,遗憾的是api文档现在不能正常访问了,出于学习的态度,简单的阅读了源码实现:\n\n```JavaScript\n!(function (name, definition) {\n  // Check define\n  var hasDefine = typeof define === 'function',\n    // Check exports\n    hasExports = typeof module !== 'undefined' && module.exports;\n\n  if (hasDefine) {\n    // AMD Module or CMD Module\n    define('eventproxy_debug', function () {return function () {};}); // 定义一个eventproxy_debug 模块，返回一个空函数作为debug函数。\n    define(['eventproxy_debug'], definition); // 依赖前面定义的模块，作为debug参数传入definition中。\n  } else if (hasExports) {\n    // Node.js Module\n    module.exports = definition(require('debug')('eventproxy'));\n    // debug 模块，一个简单的输出调试信息模块\n  } else {\n    // Assign to common namespaces or simply the global object (window)\n    this[name] = definition();\n  }\n})('EventProxy', function (debug){\n    // ...\n});\n```\n\n首先是定义了一系列的环境支持。像AMD,CMD,UMD,CommonJS。EventProxy 是最终的模块名称,真正的定义需要传入一个debug函数。其实就是日志输出工具,接下来就是具体的定义和实现:\n\n```JavaScript\nEventProxy.prototype.addListener = function(ev, callback) {\n  //....\n}\nEventProxy.prototype.bind = EventProxy.prototype.addListener;\nEventProxy.prototype.on = EventProxy.prototype.addListener;\nEventProxy.prototype.subscribe = EventProxy.prototype.addListener;\n\n```\n注册事件函数和它的一系列别名,别名也是挺多的。\n\n```javascript\nEventProxy.prototype.headbind = function (ev, callback) {\n    // ...\n    debug('Add listener for %s', ev);\n    this._callbacks[ev] = this._callbacks[ev] || [];\n    this._callbacks[ev].unshift(callback);\n    return this;\n}\n```\n代码比较简单,直接说下具体的作用吧,headbind 顾名思义,就是绑定的同时通过数组的unshift函数将事件回调函数放在最前面,接下来是解绑事件函数:\n\n```JavaScript\n EventProxy.prototype.removeListener = function (eventname, callback) {\n    var calls = this._callbacks;\n    if (!eventname) {\n      debug('Remove all listeners');\n      this._callbacks = {};\n    } else {\n      if (!callback) {\n        debug('Remove all listeners of %s', eventname);\n        calls[eventname] = [];\n      } else {\n        var list = calls[eventname];\n        if (list) {\n          var l = list.length;\n          for (var i = 0; i < l; i++) {\n            if (callback === list[i]) {\n              debug('Remove a listener of %s', eventname);\n              list[i] = null;\n            }\n          }\n        }\n      }\n    }\n    return this;\n  };\n```\n\n这个函数作用很简单就是删除(其实是对数组中相应元素下标置为null)绑定的事件回调函数,如果没有指明删除具体哪个回调函数 callback ，则删除这个事件上绑定的所有回调函数,如果连eventname都没有提供则删除所有事件上绑定的所有回调函数,这个方法的别名,``unbind``。还有根据前面两个绑定和解绑衍生出来的几个方法,``removeAllListeners``,``bindForAll``,``unbindForAll``。 在all事件上绑定处理函数,意味着任何事件触发都会执行all事件上的回调函数,下面源码一看就一目了然了:\n\n```JavaScript\nEventProxy.prototype.trigger = function (eventname, data) {\n    var list, ev, callback, i, l;\n    var both = 2; // 设置为2的目的是，第一次先执行具体事件上的回调函数，第二次执行绑定在ALL_EVENT上的回调函数。\n    var calls = this._callbacks;\n    debug('Emit event %s with data %j', eventname, data);\n    while (both--) {\n      ev = both ? eventname : ALL_EVENT;\n      list = calls[ev];\n      if (list) {\n        for (i = 0, l = list.length; i < l; i++) {\n          if (!(callback = list[i])) { //如果callback为null，回调函数数组中剔除空元素，修正循环下标和数组长度。\n            list.splice(i, 1);\n            i--;\n            l--;\n          } else {\n            var args = [];\n            var start = both ? 1 : 0; // 如果是具体事件上的回调函数执行，参数不包括事件名称，如果是ALL_EVENT上的回调函数\n            //执行，参数包括事件名称。\n            for (var j = start; j < arguments.length; j++) {\n              args.push(arguments[j]);\n            }\n            callback.apply(this, args);\n          }\n        }\n      }\n    }\n    return this;\n  };\n```\n\nboth 设置成2,就是执行完一次对于事件回调函数后,还要再执行一次all事件上的回调函数,也是很嗨的。然后它的别名也是蛮多的,``emit``,``fire``,所以最上面源码中的``proxy.emit``也就知道作用了。接下来继续看源代码:\n\n```JavaScript\n  EventProxy.prototype.once = function (ev, callback) {\n    var self = this;\n    //包装回调函数，执行完后自己解绑。\n    var wrapper = function () {\n      callback.apply(self, arguments);\n      self.unbind(ev, wrapper);\n    };\n    this.bind(ev, wrapper);\n    return this;\n  };\n```\n\n通过对callback 进行一层包装,包装后的函数会在运行callback后 `` self.unbind(ev, wrapper);`` 进行自我解绑,从而使得callback只会触发执行一次。\n\n```javascript\n // 方法使用优先级 setImmediate -> nextTick -> setTimeout\n  var later = (typeof setImmediate !== 'undefined' && setImmediate) ||\n    (typeof process !== 'undefined' && process.nextTick) || function (fn) {\n    setTimeout(fn, 0);\n  };\n```\n这里定义了异步方法,各个方法的区别和有关事件循环的内容可以参看我总结的另一篇文章[JavaScript & NodeJS 事件循环](http://weeklyweb.info/2017/05/05/fe-event-loop/)。\n\n```javascript\n   //使得触发事件行为变成异步\n  EventProxy.prototype.emitLater = function () {\n    var self = this;\n    var args = arguments;\n    later(function () {\n      self.trigger.apply(self, args);\n    });\n  };\n```\n不知道emitLater这个方法使用场景,根据代码可以知道就是延迟触发事件,不明觉厉了。\n\n```javascript\n  // 绑定完事件回调后立马先触发一次\n  EventProxy.prototype.immediate = function (ev, callback, data) {\n    this.bind(ev, callback); // 绑定事件\n    this.trigger(ev, data); // 立马触发\n    return this;\n  };\n  EventProxy.prototype.asap = EventProxy.prototype.immediate;\n```\n \nimmediate 方法和它的别名asap,作用就是绑定事件函数后立马执行。\n\n```javascript\n  var _assign = function (eventname1, eventname2, cb, once) {\n    var proxy = this;\n    var argsLength = arguments.length;\n    var times = 0;\n    var flag = {};\n\n    // Check the arguments length.\n    //必须提供至少3个参数\n    if (argsLength < 3) {\n      return this;\n    }\n\n    var events = SLICE.call(arguments, 0, -2);\n    var callback = arguments[argsLength - 2];\n    var isOnce = arguments[argsLength - 1];\n\n    // Check the callback type.\n    if (typeof callback !== \"function\") {\n      return this;\n    }\n    debug('Assign listener for events %j, once is %s', events, !!isOnce);\n    var bind = function (key) { //计数 收集数据\n      var method = isOnce ? \"once\" : \"bind\";\n      proxy[method](key, function (data) {\n        proxy._fired[key] = proxy._fired[key] || {};\n        proxy._fired[key].data = data;\n        if (!flag[key]) {\n          flag[key] = true;\n          times++;\n        }\n      });\n    };\n\n    var length = events.length;\n    for (var index = 0; index < length; index++) {\n      bind(events[index]);\n    }\n\n    var _all = function (event) {\n      if (times < length) { // 用来保证是否所有事件都已经触发过\n        return; \n      }\n      if (!flag[event]) { // 确保是提供的参数中包含的事件被触发\n        return;\n      }\n      var data = [];\n      for (var index = 0; index < length; index++) {\n        data.push(proxy._fired[events[index]].data); // 收集所有数据\n      }\n      if (isOnce) { // 是否只需要触发一次\n        proxy.unbindForAll(_all);\n      }\n      debug('Events %j all emited with data %j', events, data);\n      callback.apply(null, data); // 调用回调函数\n    };\n    proxy.bindForAll(_all); // 将新够造的回调函数\n  };\n```\n\n该方法的作用是收集前面事件触发后传给回调函数的数据，然后最后构成一个数据数组，传给callback（cb）如果调用时传入的 once 为 true,则这个callback 只会被调用一次否则会多次被调用。这个方法是一个内部方法,其中暴露给用户使用的是下面的方法:\n\n```JavaScript\n  EventProxy.prototype.all = function (eventname1, eventname2, callback) {\n    var args = CONCAT.apply([], arguments);\n    args.push(true);\n    _assign.apply(this, args); \n    return this;\n  };\n  EventProxy.prototype.assign = EventProxy.prototype.all;\n  \n  EventProxy.prototype.tail = function () {\n      var args = CONCAT.apply([], arguments);\n      args.push(false);\n      _assign.apply(this, args);\n      return this;\n  };\n  EventProxy.prototype.assignAll = EventProxy.prototype.tail;\n  EventProxy.prototype.assignAlways = EventProxy.prototype.tail;\n```\n\n* all 方法,别名 assign \n\n    绑定一系列事件，当这些事件都触发了，callback会被执行一次,执行完就解绑自己,所以后续不会再被触发执行。\n\n* tail 方法,别名 assignAll , assignAlways\n    \n    绑定一些事件，当所有事件都触发了，callback 会被触发，以后只要这些事件中的事件再次被触发，callback都会被执行。\n    \n```javascript\n EventProxy.prototype.fail = function (callback) {\n    var that = this;\n\n    that.once('error', function () {\n      that.unbind();\n      // put all arguments to the error handler\n      // fail(function(err, args1, args2, ...){})\n      callback.apply(null, arguments);\n    });\n    return this;\n  };\n\n  EventProxy.prototype.throw = function () {\n    var that = this;\n    that.emit.apply(that, ['error'].concat(SLICE.call(arguments)));\n  };\n```\n\n* fail 方法\n\n  绑定事件到error上,当出现error事件的时候,执行回调函数,并解绑所有的事件绑定。\n  \n* throw \n   \n  error 事件触发的缩写。通过throw方法,就可以触发fail方法绑定的回调函数,这里``proxy.fail(next)``,这边错误发生执行的回调函数就是next。\n  \n  \n ```javascript\n   EventProxy.prototype.done = function (handler, callback) {\n     var that = this;\n     //重新返回一个回调函数\n     return function (err, data) {\n       if (err) {\n         // put all arguments to the error handler\n         // 如果出现错误,则直接出发erorr事件,并返回\n         return that.emit.apply(that, ['error'].concat(SLICE.call(arguments)));\n       }\n \n       // callback(err, args1, args2, ...)\n       // 获取到数据,剔除err参数\n       var args = SLICE.call(arguments, 1);\n       \n       // 如果handler是字符串\n       if (typeof handler === 'string') {\n         // getAsync(query, ep.done('query'));\n         // or\n         // getAsync(query, ep.done('query', function (data) {\n         //   return data.trim();\n         // }));\n         //存在callback\n         if (callback) {\n           // 获取 callback 处理的数据。\n           // only replace the args when it really return a result\n           return that.emit(handler, callback.apply(null, args));\n         } else {\n           // put all arguments to the done handler\n           //ep.done('some');\n           //ep.on('some', function(args1, args2, ...){});\n           // 如果callback 未提供,直接触发事件,参数为新回调函数获取到的内容\n           return that.emit.apply(that, [handler].concat(args));\n         }\n       }\n \n       // speed improve for mostly case: `callback(err, data)`\n       // 如果handler提供的是function 且 则直接执行\n       if (arguments.length <= 2) {\n         return handler(data);\n       }\n \n       // callback(err, args1, args2, ...)\n       handler.apply(null, args);\n     };\n };\n ```\n \n * done 方法\n    \n   事件回调包装函数,handler 事件名称,callback 结果数据处理函数,返回新的结果数据。具体解释参看源码中的注释,主要分几种情况:\n    * handler 参数提供且为字符串\n        1. 如果提供了 callback 结果处理函数\n            \n           调用 ``that.emit(handler, callback.apply(null, args));`` 作为参数的数据是经过 callback 处理后的值。\n        \n        2. 如果未提供 callback 参数\n            \n           调用 ``that.emit.apply(that, [handler].concat(args));`` 数据参数为 handler 加上 args(异步操作结果数据) 。\n           \n    * handler 为 Function\n        1. 如果异步操作结果数据的参数只有两个,类似这种情形``callback(err,data)`` 则直接调用``handler(data);``。\n        2. 如果异步操作结果数据的参数不止两个,类似``callback(err,arg1,arg2,...)`` 这种,则调用``handler.apply(null, args);``。\n        \n## 最后\n\n虽然eventproxy的源代码比较简单,但是在阅读的过程中也添加了部分注释,有兴趣可以看下,地址:https://github.com/xdimh/eventproxy-comments/blob/master/eventproxy.js","source":"_posts/event-proxy.md","raw":"---\ntitle: eventproxy 源码解析\ntype: original\ntags: [JavaScript,NodeJS]\ncategories: [NodeJS,nodeclub源码学习]\ndate: 2017-05-06 16:09:19\ndescription:\n---\n\n\nEventProxy 仅仅是一个很轻量的工具，但是能够带来一种事件式编程的思维变化。有几个特点：\n\n1. 利用事件机制解耦复杂业务逻辑\n2. 移除被广为诟病的深度callback嵌套问题\n3. 将串行等待变成并行等待，提升多异步协作场景下的执行效率\n4. 友好的Error handling\n5. 无平台依赖，适合前后端，能用于浏览器和Node.js\n6. 兼容CMD，AMD以及CommonJS模块环境\n\n在nodeclub源码中有一段实现代码如下:\n\n```javascript\n// nodeclub 首页路由处理函数\nexports.index = function (req, res, next) {\n  var page = parseInt(req.query.page, 10) || 1;\n  page = page > 0 ? page : 1;\n  var tab = req.query.tab || 'all';\n\n  var proxy = new eventproxy();\n  proxy.fail(next);\n\n  // 取主题\n  var query = {};\n  if (!tab || tab === 'all') {\n    query.tab = {$ne: 'job'}\n  } else {\n    if (tab === 'good') {\n      query.good = true;\n    } else {\n      query.tab = tab;\n    }\n  }\n\n  var limit = config.list_topic_count;\n  var options = { skip: (page - 1) * limit, limit: limit, sort: '-top -last_reply_at'};\n\n  Topic.getTopicsByQuery(query, options, proxy.done('topics', function (topics) {\n    return topics;\n  }));\n\n  // 取排行榜上的用户\n  cache.get('tops', proxy.done(function (tops) {\n    if (tops) {\n      proxy.emit('tops', tops);\n    } else {\n      User.getUsersByQuery(\n        {is_block: false},\n        { limit: 10, sort: '-score'},\n        proxy.done('tops', function (tops) {\n          cache.set('tops', tops, 60 * 1);\n          return tops;\n        })\n      );\n    }\n  }));\n  // END 取排行榜上的用户\n\n  // 取0回复的主题\n  cache.get('no_reply_topics', proxy.done(function (no_reply_topics) {\n    if (no_reply_topics) {\n      proxy.emit('no_reply_topics', no_reply_topics);\n    } else {\n      Topic.getTopicsByQuery(\n        { reply_count: 0, tab: {$ne: 'job'}},\n        { limit: 5, sort: '-create_at'},\n        proxy.done('no_reply_topics', function (no_reply_topics) {\n          cache.set('no_reply_topics', no_reply_topics, 60 * 1);\n          return no_reply_topics;\n        }));\n    }\n  }));\n  // END 取0回复的主题\n\n  // 取分页数据\n  var pagesCacheKey = JSON.stringify(query) + 'pages';\n  cache.get(pagesCacheKey, proxy.done(function (pages) {\n    if (pages) {\n      proxy.emit('pages', pages);\n    } else {\n      Topic.getCountByQuery(query, proxy.done(function (all_topics_count) {\n        var pages = Math.ceil(all_topics_count / limit);\n        cache.set(pagesCacheKey, pages, 60 * 1);\n        proxy.emit('pages', pages);\n      }));\n    }\n  }));\n  // END 取分页数据\n\n  var tabName = renderHelper.tabName(tab);\n  proxy.all('topics', 'tops', 'no_reply_topics', 'pages',\n    function (topics, tops, no_reply_topics, pages) {\n      res.render('index', {\n        topics: topics,\n        current_page: page,\n        list_topic_count: limit,\n        tops: tops,\n        no_reply_topics: no_reply_topics,\n        pages: pages,\n        tabs: config.tabs,\n        tab: tab,\n        pageTitle: tabName && (tabName + '版块'),\n      });\n    });\n};\n```\n\n代码中看到了 ``proxy.emit('ev')`` , ``proxy.done('ev',fn)``,``proxy.fail(next)`` 所以要看懂这段代码,就必须了解eventproxy使用方法(当然可以猜测具体的作用)。查看了GitHub上的README,遗憾的是api文档现在不能正常访问了,出于学习的态度,简单的阅读了源码实现:\n\n```JavaScript\n!(function (name, definition) {\n  // Check define\n  var hasDefine = typeof define === 'function',\n    // Check exports\n    hasExports = typeof module !== 'undefined' && module.exports;\n\n  if (hasDefine) {\n    // AMD Module or CMD Module\n    define('eventproxy_debug', function () {return function () {};}); // 定义一个eventproxy_debug 模块，返回一个空函数作为debug函数。\n    define(['eventproxy_debug'], definition); // 依赖前面定义的模块，作为debug参数传入definition中。\n  } else if (hasExports) {\n    // Node.js Module\n    module.exports = definition(require('debug')('eventproxy'));\n    // debug 模块，一个简单的输出调试信息模块\n  } else {\n    // Assign to common namespaces or simply the global object (window)\n    this[name] = definition();\n  }\n})('EventProxy', function (debug){\n    // ...\n});\n```\n\n首先是定义了一系列的环境支持。像AMD,CMD,UMD,CommonJS。EventProxy 是最终的模块名称,真正的定义需要传入一个debug函数。其实就是日志输出工具,接下来就是具体的定义和实现:\n\n```JavaScript\nEventProxy.prototype.addListener = function(ev, callback) {\n  //....\n}\nEventProxy.prototype.bind = EventProxy.prototype.addListener;\nEventProxy.prototype.on = EventProxy.prototype.addListener;\nEventProxy.prototype.subscribe = EventProxy.prototype.addListener;\n\n```\n注册事件函数和它的一系列别名,别名也是挺多的。\n\n```javascript\nEventProxy.prototype.headbind = function (ev, callback) {\n    // ...\n    debug('Add listener for %s', ev);\n    this._callbacks[ev] = this._callbacks[ev] || [];\n    this._callbacks[ev].unshift(callback);\n    return this;\n}\n```\n代码比较简单,直接说下具体的作用吧,headbind 顾名思义,就是绑定的同时通过数组的unshift函数将事件回调函数放在最前面,接下来是解绑事件函数:\n\n```JavaScript\n EventProxy.prototype.removeListener = function (eventname, callback) {\n    var calls = this._callbacks;\n    if (!eventname) {\n      debug('Remove all listeners');\n      this._callbacks = {};\n    } else {\n      if (!callback) {\n        debug('Remove all listeners of %s', eventname);\n        calls[eventname] = [];\n      } else {\n        var list = calls[eventname];\n        if (list) {\n          var l = list.length;\n          for (var i = 0; i < l; i++) {\n            if (callback === list[i]) {\n              debug('Remove a listener of %s', eventname);\n              list[i] = null;\n            }\n          }\n        }\n      }\n    }\n    return this;\n  };\n```\n\n这个函数作用很简单就是删除(其实是对数组中相应元素下标置为null)绑定的事件回调函数,如果没有指明删除具体哪个回调函数 callback ，则删除这个事件上绑定的所有回调函数,如果连eventname都没有提供则删除所有事件上绑定的所有回调函数,这个方法的别名,``unbind``。还有根据前面两个绑定和解绑衍生出来的几个方法,``removeAllListeners``,``bindForAll``,``unbindForAll``。 在all事件上绑定处理函数,意味着任何事件触发都会执行all事件上的回调函数,下面源码一看就一目了然了:\n\n```JavaScript\nEventProxy.prototype.trigger = function (eventname, data) {\n    var list, ev, callback, i, l;\n    var both = 2; // 设置为2的目的是，第一次先执行具体事件上的回调函数，第二次执行绑定在ALL_EVENT上的回调函数。\n    var calls = this._callbacks;\n    debug('Emit event %s with data %j', eventname, data);\n    while (both--) {\n      ev = both ? eventname : ALL_EVENT;\n      list = calls[ev];\n      if (list) {\n        for (i = 0, l = list.length; i < l; i++) {\n          if (!(callback = list[i])) { //如果callback为null，回调函数数组中剔除空元素，修正循环下标和数组长度。\n            list.splice(i, 1);\n            i--;\n            l--;\n          } else {\n            var args = [];\n            var start = both ? 1 : 0; // 如果是具体事件上的回调函数执行，参数不包括事件名称，如果是ALL_EVENT上的回调函数\n            //执行，参数包括事件名称。\n            for (var j = start; j < arguments.length; j++) {\n              args.push(arguments[j]);\n            }\n            callback.apply(this, args);\n          }\n        }\n      }\n    }\n    return this;\n  };\n```\n\nboth 设置成2,就是执行完一次对于事件回调函数后,还要再执行一次all事件上的回调函数,也是很嗨的。然后它的别名也是蛮多的,``emit``,``fire``,所以最上面源码中的``proxy.emit``也就知道作用了。接下来继续看源代码:\n\n```JavaScript\n  EventProxy.prototype.once = function (ev, callback) {\n    var self = this;\n    //包装回调函数，执行完后自己解绑。\n    var wrapper = function () {\n      callback.apply(self, arguments);\n      self.unbind(ev, wrapper);\n    };\n    this.bind(ev, wrapper);\n    return this;\n  };\n```\n\n通过对callback 进行一层包装,包装后的函数会在运行callback后 `` self.unbind(ev, wrapper);`` 进行自我解绑,从而使得callback只会触发执行一次。\n\n```javascript\n // 方法使用优先级 setImmediate -> nextTick -> setTimeout\n  var later = (typeof setImmediate !== 'undefined' && setImmediate) ||\n    (typeof process !== 'undefined' && process.nextTick) || function (fn) {\n    setTimeout(fn, 0);\n  };\n```\n这里定义了异步方法,各个方法的区别和有关事件循环的内容可以参看我总结的另一篇文章[JavaScript & NodeJS 事件循环](http://weeklyweb.info/2017/05/05/fe-event-loop/)。\n\n```javascript\n   //使得触发事件行为变成异步\n  EventProxy.prototype.emitLater = function () {\n    var self = this;\n    var args = arguments;\n    later(function () {\n      self.trigger.apply(self, args);\n    });\n  };\n```\n不知道emitLater这个方法使用场景,根据代码可以知道就是延迟触发事件,不明觉厉了。\n\n```javascript\n  // 绑定完事件回调后立马先触发一次\n  EventProxy.prototype.immediate = function (ev, callback, data) {\n    this.bind(ev, callback); // 绑定事件\n    this.trigger(ev, data); // 立马触发\n    return this;\n  };\n  EventProxy.prototype.asap = EventProxy.prototype.immediate;\n```\n \nimmediate 方法和它的别名asap,作用就是绑定事件函数后立马执行。\n\n```javascript\n  var _assign = function (eventname1, eventname2, cb, once) {\n    var proxy = this;\n    var argsLength = arguments.length;\n    var times = 0;\n    var flag = {};\n\n    // Check the arguments length.\n    //必须提供至少3个参数\n    if (argsLength < 3) {\n      return this;\n    }\n\n    var events = SLICE.call(arguments, 0, -2);\n    var callback = arguments[argsLength - 2];\n    var isOnce = arguments[argsLength - 1];\n\n    // Check the callback type.\n    if (typeof callback !== \"function\") {\n      return this;\n    }\n    debug('Assign listener for events %j, once is %s', events, !!isOnce);\n    var bind = function (key) { //计数 收集数据\n      var method = isOnce ? \"once\" : \"bind\";\n      proxy[method](key, function (data) {\n        proxy._fired[key] = proxy._fired[key] || {};\n        proxy._fired[key].data = data;\n        if (!flag[key]) {\n          flag[key] = true;\n          times++;\n        }\n      });\n    };\n\n    var length = events.length;\n    for (var index = 0; index < length; index++) {\n      bind(events[index]);\n    }\n\n    var _all = function (event) {\n      if (times < length) { // 用来保证是否所有事件都已经触发过\n        return; \n      }\n      if (!flag[event]) { // 确保是提供的参数中包含的事件被触发\n        return;\n      }\n      var data = [];\n      for (var index = 0; index < length; index++) {\n        data.push(proxy._fired[events[index]].data); // 收集所有数据\n      }\n      if (isOnce) { // 是否只需要触发一次\n        proxy.unbindForAll(_all);\n      }\n      debug('Events %j all emited with data %j', events, data);\n      callback.apply(null, data); // 调用回调函数\n    };\n    proxy.bindForAll(_all); // 将新够造的回调函数\n  };\n```\n\n该方法的作用是收集前面事件触发后传给回调函数的数据，然后最后构成一个数据数组，传给callback（cb）如果调用时传入的 once 为 true,则这个callback 只会被调用一次否则会多次被调用。这个方法是一个内部方法,其中暴露给用户使用的是下面的方法:\n\n```JavaScript\n  EventProxy.prototype.all = function (eventname1, eventname2, callback) {\n    var args = CONCAT.apply([], arguments);\n    args.push(true);\n    _assign.apply(this, args); \n    return this;\n  };\n  EventProxy.prototype.assign = EventProxy.prototype.all;\n  \n  EventProxy.prototype.tail = function () {\n      var args = CONCAT.apply([], arguments);\n      args.push(false);\n      _assign.apply(this, args);\n      return this;\n  };\n  EventProxy.prototype.assignAll = EventProxy.prototype.tail;\n  EventProxy.prototype.assignAlways = EventProxy.prototype.tail;\n```\n\n* all 方法,别名 assign \n\n    绑定一系列事件，当这些事件都触发了，callback会被执行一次,执行完就解绑自己,所以后续不会再被触发执行。\n\n* tail 方法,别名 assignAll , assignAlways\n    \n    绑定一些事件，当所有事件都触发了，callback 会被触发，以后只要这些事件中的事件再次被触发，callback都会被执行。\n    \n```javascript\n EventProxy.prototype.fail = function (callback) {\n    var that = this;\n\n    that.once('error', function () {\n      that.unbind();\n      // put all arguments to the error handler\n      // fail(function(err, args1, args2, ...){})\n      callback.apply(null, arguments);\n    });\n    return this;\n  };\n\n  EventProxy.prototype.throw = function () {\n    var that = this;\n    that.emit.apply(that, ['error'].concat(SLICE.call(arguments)));\n  };\n```\n\n* fail 方法\n\n  绑定事件到error上,当出现error事件的时候,执行回调函数,并解绑所有的事件绑定。\n  \n* throw \n   \n  error 事件触发的缩写。通过throw方法,就可以触发fail方法绑定的回调函数,这里``proxy.fail(next)``,这边错误发生执行的回调函数就是next。\n  \n  \n ```javascript\n   EventProxy.prototype.done = function (handler, callback) {\n     var that = this;\n     //重新返回一个回调函数\n     return function (err, data) {\n       if (err) {\n         // put all arguments to the error handler\n         // 如果出现错误,则直接出发erorr事件,并返回\n         return that.emit.apply(that, ['error'].concat(SLICE.call(arguments)));\n       }\n \n       // callback(err, args1, args2, ...)\n       // 获取到数据,剔除err参数\n       var args = SLICE.call(arguments, 1);\n       \n       // 如果handler是字符串\n       if (typeof handler === 'string') {\n         // getAsync(query, ep.done('query'));\n         // or\n         // getAsync(query, ep.done('query', function (data) {\n         //   return data.trim();\n         // }));\n         //存在callback\n         if (callback) {\n           // 获取 callback 处理的数据。\n           // only replace the args when it really return a result\n           return that.emit(handler, callback.apply(null, args));\n         } else {\n           // put all arguments to the done handler\n           //ep.done('some');\n           //ep.on('some', function(args1, args2, ...){});\n           // 如果callback 未提供,直接触发事件,参数为新回调函数获取到的内容\n           return that.emit.apply(that, [handler].concat(args));\n         }\n       }\n \n       // speed improve for mostly case: `callback(err, data)`\n       // 如果handler提供的是function 且 则直接执行\n       if (arguments.length <= 2) {\n         return handler(data);\n       }\n \n       // callback(err, args1, args2, ...)\n       handler.apply(null, args);\n     };\n };\n ```\n \n * done 方法\n    \n   事件回调包装函数,handler 事件名称,callback 结果数据处理函数,返回新的结果数据。具体解释参看源码中的注释,主要分几种情况:\n    * handler 参数提供且为字符串\n        1. 如果提供了 callback 结果处理函数\n            \n           调用 ``that.emit(handler, callback.apply(null, args));`` 作为参数的数据是经过 callback 处理后的值。\n        \n        2. 如果未提供 callback 参数\n            \n           调用 ``that.emit.apply(that, [handler].concat(args));`` 数据参数为 handler 加上 args(异步操作结果数据) 。\n           \n    * handler 为 Function\n        1. 如果异步操作结果数据的参数只有两个,类似这种情形``callback(err,data)`` 则直接调用``handler(data);``。\n        2. 如果异步操作结果数据的参数不止两个,类似``callback(err,arg1,arg2,...)`` 这种,则调用``handler.apply(null, args);``。\n        \n## 最后\n\n虽然eventproxy的源代码比较简单,但是在阅读的过程中也添加了部分注释,有兴趣可以看下,地址:https://github.com/xdimh/eventproxy-comments/blob/master/eventproxy.js","slug":"event-proxy","published":1,"updated":"2017-05-09T14:51:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhp50001b37q1rl4rapk","content":"<p>EventProxy 仅仅是一个很轻量的工具，但是能够带来一种事件式编程的思维变化。有几个特点：</p>\n<ol>\n<li>利用事件机制解耦复杂业务逻辑</li>\n<li>移除被广为诟病的深度callback嵌套问题</li>\n<li>将串行等待变成并行等待，提升多异步协作场景下的执行效率</li>\n<li>友好的Error handling</li>\n<li>无平台依赖，适合前后端，能用于浏览器和Node.js</li>\n<li>兼容CMD，AMD以及CommonJS模块环境</li>\n</ol>\n<p>在nodeclub源码中有一段实现代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// nodeclub 首页路由处理函数</span></div><div class=\"line\">exports.index = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> page = <span class=\"built_in\">parseInt</span>(req.query.page, <span class=\"number\">10</span>) || <span class=\"number\">1</span>;</div><div class=\"line\">  page = page &gt; <span class=\"number\">0</span> ? page : <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> tab = req.query.tab || <span class=\"string\">'all'</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> eventproxy();</div><div class=\"line\">  proxy.fail(next);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 取主题</span></div><div class=\"line\">  <span class=\"keyword\">var</span> query = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!tab || tab === <span class=\"string\">'all'</span>) &#123;</div><div class=\"line\">    query.tab = &#123;<span class=\"attr\">$ne</span>: <span class=\"string\">'job'</span>&#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tab === <span class=\"string\">'good'</span>) &#123;</div><div class=\"line\">      query.good = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      query.tab = tab;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> limit = config.list_topic_count;</div><div class=\"line\">  <span class=\"keyword\">var</span> options = &#123; <span class=\"attr\">skip</span>: (page - <span class=\"number\">1</span>) * limit, <span class=\"attr\">limit</span>: limit, <span class=\"attr\">sort</span>: <span class=\"string\">'-top -last_reply_at'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">  Topic.getTopicsByQuery(query, options, proxy.done(<span class=\"string\">'topics'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">topics</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> topics;</div><div class=\"line\">  &#125;));</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 取排行榜上的用户</span></div><div class=\"line\">  cache.get(<span class=\"string\">'tops'</span>, proxy.done(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tops</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tops) &#123;</div><div class=\"line\">      proxy.emit(<span class=\"string\">'tops'</span>, tops);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      User.getUsersByQuery(</div><div class=\"line\">        &#123;<span class=\"attr\">is_block</span>: <span class=\"literal\">false</span>&#125;,</div><div class=\"line\">        &#123; <span class=\"attr\">limit</span>: <span class=\"number\">10</span>, <span class=\"attr\">sort</span>: <span class=\"string\">'-score'</span>&#125;,</div><div class=\"line\">        proxy.done(<span class=\"string\">'tops'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tops</span>) </span>&#123;</div><div class=\"line\">          cache.set(<span class=\"string\">'tops'</span>, tops, <span class=\"number\">60</span> * <span class=\"number\">1</span>);</div><div class=\"line\">          <span class=\"keyword\">return</span> tops;</div><div class=\"line\">        &#125;)</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;));</div><div class=\"line\">  <span class=\"comment\">// END 取排行榜上的用户</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 取0回复的主题</span></div><div class=\"line\">  cache.get(<span class=\"string\">'no_reply_topics'</span>, proxy.done(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">no_reply_topics</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (no_reply_topics) &#123;</div><div class=\"line\">      proxy.emit(<span class=\"string\">'no_reply_topics'</span>, no_reply_topics);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      Topic.getTopicsByQuery(</div><div class=\"line\">        &#123; <span class=\"attr\">reply_count</span>: <span class=\"number\">0</span>, <span class=\"attr\">tab</span>: &#123;<span class=\"attr\">$ne</span>: <span class=\"string\">'job'</span>&#125;&#125;,</div><div class=\"line\">        &#123; <span class=\"attr\">limit</span>: <span class=\"number\">5</span>, <span class=\"attr\">sort</span>: <span class=\"string\">'-create_at'</span>&#125;,</div><div class=\"line\">        proxy.done(<span class=\"string\">'no_reply_topics'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">no_reply_topics</span>) </span>&#123;</div><div class=\"line\">          cache.set(<span class=\"string\">'no_reply_topics'</span>, no_reply_topics, <span class=\"number\">60</span> * <span class=\"number\">1</span>);</div><div class=\"line\">          <span class=\"keyword\">return</span> no_reply_topics;</div><div class=\"line\">        &#125;));</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;));</div><div class=\"line\">  <span class=\"comment\">// END 取0回复的主题</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 取分页数据</span></div><div class=\"line\">  <span class=\"keyword\">var</span> pagesCacheKey = <span class=\"built_in\">JSON</span>.stringify(query) + <span class=\"string\">'pages'</span>;</div><div class=\"line\">  cache.get(pagesCacheKey, proxy.done(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">pages</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pages) &#123;</div><div class=\"line\">      proxy.emit(<span class=\"string\">'pages'</span>, pages);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      Topic.getCountByQuery(query, proxy.done(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">all_topics_count</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> pages = <span class=\"built_in\">Math</span>.ceil(all_topics_count / limit);</div><div class=\"line\">        cache.set(pagesCacheKey, pages, <span class=\"number\">60</span> * <span class=\"number\">1</span>);</div><div class=\"line\">        proxy.emit(<span class=\"string\">'pages'</span>, pages);</div><div class=\"line\">      &#125;));</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;));</div><div class=\"line\">  <span class=\"comment\">// END 取分页数据</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> tabName = renderHelper.tabName(tab);</div><div class=\"line\">  proxy.all(<span class=\"string\">'topics'</span>, <span class=\"string\">'tops'</span>, <span class=\"string\">'no_reply_topics'</span>, <span class=\"string\">'pages'</span>,</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">topics, tops, no_reply_topics, pages</span>) </span>&#123;</div><div class=\"line\">      res.render(<span class=\"string\">'index'</span>, &#123;</div><div class=\"line\">        <span class=\"attr\">topics</span>: topics,</div><div class=\"line\">        <span class=\"attr\">current_page</span>: page,</div><div class=\"line\">        <span class=\"attr\">list_topic_count</span>: limit,</div><div class=\"line\">        <span class=\"attr\">tops</span>: tops,</div><div class=\"line\">        <span class=\"attr\">no_reply_topics</span>: no_reply_topics,</div><div class=\"line\">        <span class=\"attr\">pages</span>: pages,</div><div class=\"line\">        <span class=\"attr\">tabs</span>: config.tabs,</div><div class=\"line\">        <span class=\"attr\">tab</span>: tab,</div><div class=\"line\">        <span class=\"attr\">pageTitle</span>: tabName &amp;&amp; (tabName + <span class=\"string\">'版块'</span>),</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>代码中看到了 <code>proxy.emit(&#39;ev&#39;)</code> , <code>proxy.done(&#39;ev&#39;,fn)</code>,<code>proxy.fail(next)</code> 所以要看懂这段代码,就必须了解eventproxy使用方法(当然可以猜测具体的作用)。查看了GitHub上的README,遗憾的是api文档现在不能正常访问了,出于学习的态度,简单的阅读了源码实现:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">!(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, definition</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// Check define</span></div><div class=\"line\">  <span class=\"keyword\">var</span> hasDefine = <span class=\"keyword\">typeof</span> define === <span class=\"string\">'function'</span>,</div><div class=\"line\">    <span class=\"comment\">// Check exports</span></div><div class=\"line\">    hasExports = <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">module</span>.exports;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (hasDefine) &#123;</div><div class=\"line\">    <span class=\"comment\">// AMD Module or CMD Module</span></div><div class=\"line\">    define(<span class=\"string\">'eventproxy_debug'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;&#125;); <span class=\"comment\">// 定义一个eventproxy_debug 模块，返回一个空函数作为debug函数。</span></div><div class=\"line\">    define([<span class=\"string\">'eventproxy_debug'</span>], definition); <span class=\"comment\">// 依赖前面定义的模块，作为debug参数传入definition中。</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hasExports) &#123;</div><div class=\"line\">    <span class=\"comment\">// Node.js Module</span></div><div class=\"line\">    <span class=\"built_in\">module</span>.exports = definition(<span class=\"built_in\">require</span>(<span class=\"string\">'debug'</span>)(<span class=\"string\">'eventproxy'</span>));</div><div class=\"line\">    <span class=\"comment\">// debug 模块，一个简单的输出调试信息模块</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Assign to common namespaces or simply the global object (window)</span></div><div class=\"line\">    <span class=\"keyword\">this</span>[name] = definition();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)(<span class=\"string\">'EventProxy'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">debug</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>首先是定义了一系列的环境支持。像AMD,CMD,UMD,CommonJS。EventProxy 是最终的模块名称,真正的定义需要传入一个debug函数。其实就是日志输出工具,接下来就是具体的定义和实现:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.addListener = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ev, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//....</span></div><div class=\"line\">&#125;</div><div class=\"line\">EventProxy.prototype.bind = EventProxy.prototype.addListener;</div><div class=\"line\">EventProxy.prototype.on = EventProxy.prototype.addListener;</div><div class=\"line\">EventProxy.prototype.subscribe = EventProxy.prototype.addListener;</div></pre></td></tr></table></figure>\n<p>注册事件函数和它的一系列别名,别名也是挺多的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.headbind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev, callback</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    debug(<span class=\"string\">'Add listener for %s'</span>, ev);</div><div class=\"line\">    <span class=\"keyword\">this</span>._callbacks[ev] = <span class=\"keyword\">this</span>._callbacks[ev] || [];</div><div class=\"line\">    <span class=\"keyword\">this</span>._callbacks[ev].unshift(callback);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码比较简单,直接说下具体的作用吧,headbind 顾名思义,就是绑定的同时通过数组的unshift函数将事件回调函数放在最前面,接下来是解绑事件函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.removeListener = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventname, callback</span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> calls = <span class=\"keyword\">this</span>._callbacks;</div><div class=\"line\">   <span class=\"keyword\">if</span> (!eventname) &#123;</div><div class=\"line\">     debug(<span class=\"string\">'Remove all listeners'</span>);</div><div class=\"line\">     <span class=\"keyword\">this</span>._callbacks = &#123;&#125;;</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (!callback) &#123;</div><div class=\"line\">       debug(<span class=\"string\">'Remove all listeners of %s'</span>, eventname);</div><div class=\"line\">       calls[eventname] = [];</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       <span class=\"keyword\">var</span> list = calls[eventname];</div><div class=\"line\">       <span class=\"keyword\">if</span> (list) &#123;</div><div class=\"line\">         <span class=\"keyword\">var</span> l = list.length;</div><div class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; l; i++) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (callback === list[i]) &#123;</div><div class=\"line\">             debug(<span class=\"string\">'Remove a listener of %s'</span>, eventname);</div><div class=\"line\">             list[i] = <span class=\"literal\">null</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\"> &#125;;</div></pre></td></tr></table></figure>\n<p>这个函数作用很简单就是删除(其实是对数组中相应元素下标置为null)绑定的事件回调函数,如果没有指明删除具体哪个回调函数 callback ，则删除这个事件上绑定的所有回调函数,如果连eventname都没有提供则删除所有事件上绑定的所有回调函数,这个方法的别名,<code>unbind</code>。还有根据前面两个绑定和解绑衍生出来的几个方法,<code>removeAllListeners</code>,<code>bindForAll</code>,<code>unbindForAll</code>。 在all事件上绑定处理函数,意味着任何事件触发都会执行all事件上的回调函数,下面源码一看就一目了然了:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.trigger = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventname, data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> list, ev, callback, i, l;</div><div class=\"line\">    <span class=\"keyword\">var</span> both = <span class=\"number\">2</span>; <span class=\"comment\">// 设置为2的目的是，第一次先执行具体事件上的回调函数，第二次执行绑定在ALL_EVENT上的回调函数。</span></div><div class=\"line\">    <span class=\"keyword\">var</span> calls = <span class=\"keyword\">this</span>._callbacks;</div><div class=\"line\">    debug(<span class=\"string\">'Emit event %s with data %j'</span>, eventname, data);</div><div class=\"line\">    <span class=\"keyword\">while</span> (both--) &#123;</div><div class=\"line\">      ev = both ? eventname : ALL_EVENT;</div><div class=\"line\">      list = calls[ev];</div><div class=\"line\">      <span class=\"keyword\">if</span> (list) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, l = list.length; i &lt; l; i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (!(callback = list[i])) &#123; <span class=\"comment\">//如果callback为null，回调函数数组中剔除空元素，修正循环下标和数组长度。</span></div><div class=\"line\">            list.splice(i, <span class=\"number\">1</span>);</div><div class=\"line\">            i--;</div><div class=\"line\">            l--;</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> args = [];</div><div class=\"line\">            <span class=\"keyword\">var</span> start = both ? <span class=\"number\">1</span> : <span class=\"number\">0</span>; <span class=\"comment\">// 如果是具体事件上的回调函数执行，参数不包括事件名称，如果是ALL_EVENT上的回调函数</span></div><div class=\"line\">            <span class=\"comment\">//执行，参数包括事件名称。</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = start; j &lt; <span class=\"built_in\">arguments</span>.length; j++) &#123;</div><div class=\"line\">              args.push(<span class=\"built_in\">arguments</span>[j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            callback.apply(<span class=\"keyword\">this</span>, args);</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;;</div></pre></td></tr></table></figure>\n<p>both 设置成2,就是执行完一次对于事件回调函数后,还要再执行一次all事件上的回调函数,也是很嗨的。然后它的别名也是蛮多的,<code>emit</code>,<code>fire</code>,所以最上面源码中的<code>proxy.emit</code>也就知道作用了。接下来继续看源代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.once = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">  <span class=\"comment\">//包装回调函数，执行完后自己解绑。</span></div><div class=\"line\">  <span class=\"keyword\">var</span> wrapper = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    callback.apply(self, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">    self.unbind(ev, wrapper);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">this</span>.bind(ev, wrapper);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>通过对callback 进行一层包装,包装后的函数会在运行callback后 <code>self.unbind(ev, wrapper);</code> 进行自我解绑,从而使得callback只会触发执行一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 方法使用优先级 setImmediate -&gt; nextTick -&gt; setTimeout</span></div><div class=\"line\"> <span class=\"keyword\">var</span> later = (<span class=\"keyword\">typeof</span> setImmediate !== <span class=\"string\">'undefined'</span> &amp;&amp; setImmediate) ||</div><div class=\"line\">   (<span class=\"keyword\">typeof</span> process !== <span class=\"string\">'undefined'</span> &amp;&amp; process.nextTick) || <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">   setTimeout(fn, <span class=\"number\">0</span>);</div><div class=\"line\"> &#125;;</div></pre></td></tr></table></figure>\n<p>这里定义了异步方法,各个方法的区别和有关事件循环的内容可以参看我总结的另一篇文章<a href=\"http://weeklyweb.info/2017/05/05/fe-event-loop/\" target=\"_blank\" rel=\"external\">JavaScript &amp; NodeJS 事件循环</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//使得触发事件行为变成异步</span></div><div class=\"line\">EventProxy.prototype.emitLater = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">  later(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    self.trigger.apply(self, args);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>不知道emitLater这个方法使用场景,根据代码可以知道就是延迟触发事件,不明觉厉了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 绑定完事件回调后立马先触发一次</span></div><div class=\"line\">EventProxy.prototype.immediate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev, callback, data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.bind(ev, callback); <span class=\"comment\">// 绑定事件</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.trigger(ev, data); <span class=\"comment\">// 立马触发</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\">EventProxy.prototype.asap = EventProxy.prototype.immediate;</div></pre></td></tr></table></figure>\n<p>immediate 方法和它的别名asap,作用就是绑定事件函数后立马执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _assign = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventname1, eventname2, cb, once</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> proxy = <span class=\"keyword\">this</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> argsLength = <span class=\"built_in\">arguments</span>.length;</div><div class=\"line\">  <span class=\"keyword\">var</span> times = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> flag = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Check the arguments length.</span></div><div class=\"line\">  <span class=\"comment\">//必须提供至少3个参数</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (argsLength &lt; <span class=\"number\">3</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> events = SLICE.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>, <span class=\"number\">-2</span>);</div><div class=\"line\">  <span class=\"keyword\">var</span> callback = <span class=\"built_in\">arguments</span>[argsLength - <span class=\"number\">2</span>];</div><div class=\"line\">  <span class=\"keyword\">var</span> isOnce = <span class=\"built_in\">arguments</span>[argsLength - <span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Check the callback type.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">\"function\"</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  debug(<span class=\"string\">'Assign listener for events %j, once is %s'</span>, events, !!isOnce);</div><div class=\"line\">  <span class=\"keyword\">var</span> bind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123; <span class=\"comment\">//计数 收集数据</span></div><div class=\"line\">    <span class=\"keyword\">var</span> method = isOnce ? <span class=\"string\">\"once\"</span> : <span class=\"string\">\"bind\"</span>;</div><div class=\"line\">    proxy[method](key, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">      proxy._fired[key] = proxy._fired[key] || &#123;&#125;;</div><div class=\"line\">      proxy._fired[key].data = data;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!flag[key]) &#123;</div><div class=\"line\">        flag[key] = <span class=\"literal\">true</span>;</div><div class=\"line\">        times++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> length = events.length;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; length; index++) &#123;</div><div class=\"line\">    bind(events[index]);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> _all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (times &lt; length) &#123; <span class=\"comment\">// 用来保证是否所有事件都已经触发过</span></div><div class=\"line\">      <span class=\"keyword\">return</span>; </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!flag[event]) &#123; <span class=\"comment\">// 确保是提供的参数中包含的事件被触发</span></div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; length; index++) &#123;</div><div class=\"line\">      data.push(proxy._fired[events[index]].data); <span class=\"comment\">// 收集所有数据</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (isOnce) &#123; <span class=\"comment\">// 是否只需要触发一次</span></div><div class=\"line\">      proxy.unbindForAll(_all);</div><div class=\"line\">    &#125;</div><div class=\"line\">    debug(<span class=\"string\">'Events %j all emited with data %j'</span>, events, data);</div><div class=\"line\">    callback.apply(<span class=\"literal\">null</span>, data); <span class=\"comment\">// 调用回调函数</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">  proxy.bindForAll(_all); <span class=\"comment\">// 将新够造的回调函数</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>该方法的作用是收集前面事件触发后传给回调函数的数据，然后最后构成一个数据数组，传给callback（cb）如果调用时传入的 once 为 true,则这个callback 只会被调用一次否则会多次被调用。这个方法是一个内部方法,其中暴露给用户使用的是下面的方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventname1, eventname2, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> args = CONCAT.apply([], <span class=\"built_in\">arguments</span>);</div><div class=\"line\">  args.push(<span class=\"literal\">true</span>);</div><div class=\"line\">  _assign.apply(<span class=\"keyword\">this</span>, args); </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\">EventProxy.prototype.assign = EventProxy.prototype.all;</div><div class=\"line\"></div><div class=\"line\">EventProxy.prototype.tail = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args = CONCAT.apply([], <span class=\"built_in\">arguments</span>);</div><div class=\"line\">    args.push(<span class=\"literal\">false</span>);</div><div class=\"line\">    _assign.apply(<span class=\"keyword\">this</span>, args);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\">EventProxy.prototype.assignAll = EventProxy.prototype.tail;</div><div class=\"line\">EventProxy.prototype.assignAlways = EventProxy.prototype.tail;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>all 方法,别名 assign </p>\n<p>  绑定一系列事件，当这些事件都触发了，callback会被执行一次,执行完就解绑自己,所以后续不会再被触发执行。</p>\n</li>\n<li><p>tail 方法,别名 assignAll , assignAlways</p>\n<p>  绑定一些事件，当所有事件都触发了，callback 会被触发，以后只要这些事件中的事件再次被触发，callback都会被执行。</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.fail = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">   that.once(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">     that.unbind();</div><div class=\"line\">     <span class=\"comment\">// put all arguments to the error handler</span></div><div class=\"line\">     <span class=\"comment\">// fail(function(err, args1, args2, ...)&#123;&#125;)</span></div><div class=\"line\">     callback.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">   &#125;);</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\"> &#125;;</div><div class=\"line\"></div><div class=\"line\"> EventProxy.prototype.throw = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\">   that.emit.apply(that, [<span class=\"string\">'error'</span>].concat(SLICE.call(<span class=\"built_in\">arguments</span>)));</div><div class=\"line\"> &#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>fail 方法</p>\n<p>绑定事件到error上,当出现error事件的时候,执行回调函数,并解绑所有的事件绑定。</p>\n</li>\n<li><p>throw </p>\n<p>error 事件触发的缩写。通过throw方法,就可以触发fail方法绑定的回调函数,这里<code>proxy.fail(next)</code>,这边错误发生执行的回调函数就是next。</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">  EventProxy.prototype.done = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">handler, callback</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"comment\">//重新返回一个回调函数</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"comment\">// put all arguments to the error handler</span></div><div class=\"line\">        <span class=\"comment\">// 如果出现错误,则直接出发erorr事件,并返回</span></div><div class=\"line\">        <span class=\"keyword\">return</span> that.emit.apply(that, [<span class=\"string\">'error'</span>].concat(SLICE.call(<span class=\"built_in\">arguments</span>)));</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// callback(err, args1, args2, ...)</span></div><div class=\"line\">      <span class=\"comment\">// 获取到数据,剔除err参数</span></div><div class=\"line\">      <span class=\"keyword\">var</span> args = SLICE.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"comment\">// 如果handler是字符串</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handler === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// getAsync(query, ep.done('query'));</span></div><div class=\"line\">        <span class=\"comment\">// or</span></div><div class=\"line\">        <span class=\"comment\">// getAsync(query, ep.done('query', function (data) &#123;</span></div><div class=\"line\">        <span class=\"comment\">//   return data.trim();</span></div><div class=\"line\">        <span class=\"comment\">// &#125;));</span></div><div class=\"line\">        <span class=\"comment\">//存在callback</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (callback) &#123;</div><div class=\"line\">          <span class=\"comment\">// 获取 callback 处理的数据。</span></div><div class=\"line\">          <span class=\"comment\">// only replace the args when it really return a result</span></div><div class=\"line\">          <span class=\"keyword\">return</span> that.emit(handler, callback.apply(<span class=\"literal\">null</span>, args));</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// put all arguments to the done handler</span></div><div class=\"line\">          <span class=\"comment\">//ep.done('some');</span></div><div class=\"line\">          <span class=\"comment\">//ep.on('some', function(args1, args2, ...)&#123;&#125;);</span></div><div class=\"line\">          <span class=\"comment\">// 如果callback 未提供,直接触发事件,参数为新回调函数获取到的内容</span></div><div class=\"line\">          <span class=\"keyword\">return</span> that.emit.apply(that, [handler].concat(args));</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// speed improve for mostly case: `callback(err, data)`</span></div><div class=\"line\">      <span class=\"comment\">// 如果handler提供的是function 且 则直接执行</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length &lt;= <span class=\"number\">2</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> handler(data);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// callback(err, args1, args2, ...)</span></div><div class=\"line\">      handler.apply(<span class=\"literal\">null</span>, args);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>done 方法</p>\n<p>事件回调包装函数,handler 事件名称,callback 结果数据处理函数,返回新的结果数据。具体解释参看源码中的注释,主要分几种情况:</p>\n<ul>\n<li><p>handler 参数提供且为字符串</p>\n<ol>\n<li><p>如果提供了 callback 结果处理函数</p>\n<p>调用 <code>that.emit(handler, callback.apply(null, args));</code> 作为参数的数据是经过 callback 处理后的值。</p>\n</li>\n<li><p>如果未提供 callback 参数</p>\n<p>调用 <code>that.emit.apply(that, [handler].concat(args));</code> 数据参数为 handler 加上 args(异步操作结果数据) 。</p>\n</li>\n</ol>\n</li>\n<li><p>handler 为 Function</p>\n<ol>\n<li>如果异步操作结果数据的参数只有两个,类似这种情形<code>callback(err,data)</code> 则直接调用<code>handler(data);</code>。</li>\n<li>如果异步操作结果数据的参数不止两个,类似<code>callback(err,arg1,arg2,...)</code> 这种,则调用<code>handler.apply(null, args);</code>。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>虽然eventproxy的源代码比较简单,但是在阅读的过程中也添加了部分注释,有兴趣可以看下,地址:<a href=\"https://github.com/xdimh/eventproxy-comments/blob/master/eventproxy.js\" target=\"_blank\" rel=\"external\">https://github.com/xdimh/eventproxy-comments/blob/master/eventproxy.js</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>EventProxy 仅仅是一个很轻量的工具，但是能够带来一种事件式编程的思维变化。有几个特点：</p>\n<ol>\n<li>利用事件机制解耦复杂业务逻辑</li>\n<li>移除被广为诟病的深度callback嵌套问题</li>\n<li>将串行等待变成并行等待，提升多异步协作场景下的执行效率</li>\n<li>友好的Error handling</li>\n<li>无平台依赖，适合前后端，能用于浏览器和Node.js</li>\n<li>兼容CMD，AMD以及CommonJS模块环境</li>\n</ol>\n<p>在nodeclub源码中有一段实现代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// nodeclub 首页路由处理函数</span></div><div class=\"line\">exports.index = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res, next</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> page = <span class=\"built_in\">parseInt</span>(req.query.page, <span class=\"number\">10</span>) || <span class=\"number\">1</span>;</div><div class=\"line\">  page = page &gt; <span class=\"number\">0</span> ? page : <span class=\"number\">1</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> tab = req.query.tab || <span class=\"string\">'all'</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> eventproxy();</div><div class=\"line\">  proxy.fail(next);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 取主题</span></div><div class=\"line\">  <span class=\"keyword\">var</span> query = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">if</span> (!tab || tab === <span class=\"string\">'all'</span>) &#123;</div><div class=\"line\">    query.tab = &#123;<span class=\"attr\">$ne</span>: <span class=\"string\">'job'</span>&#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tab === <span class=\"string\">'good'</span>) &#123;</div><div class=\"line\">      query.good = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      query.tab = tab;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> limit = config.list_topic_count;</div><div class=\"line\">  <span class=\"keyword\">var</span> options = &#123; <span class=\"attr\">skip</span>: (page - <span class=\"number\">1</span>) * limit, <span class=\"attr\">limit</span>: limit, <span class=\"attr\">sort</span>: <span class=\"string\">'-top -last_reply_at'</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">  Topic.getTopicsByQuery(query, options, proxy.done(<span class=\"string\">'topics'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">topics</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> topics;</div><div class=\"line\">  &#125;));</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 取排行榜上的用户</span></div><div class=\"line\">  cache.get(<span class=\"string\">'tops'</span>, proxy.done(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tops</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (tops) &#123;</div><div class=\"line\">      proxy.emit(<span class=\"string\">'tops'</span>, tops);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      User.getUsersByQuery(</div><div class=\"line\">        &#123;<span class=\"attr\">is_block</span>: <span class=\"literal\">false</span>&#125;,</div><div class=\"line\">        &#123; <span class=\"attr\">limit</span>: <span class=\"number\">10</span>, <span class=\"attr\">sort</span>: <span class=\"string\">'-score'</span>&#125;,</div><div class=\"line\">        proxy.done(<span class=\"string\">'tops'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">tops</span>) </span>&#123;</div><div class=\"line\">          cache.set(<span class=\"string\">'tops'</span>, tops, <span class=\"number\">60</span> * <span class=\"number\">1</span>);</div><div class=\"line\">          <span class=\"keyword\">return</span> tops;</div><div class=\"line\">        &#125;)</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;));</div><div class=\"line\">  <span class=\"comment\">// END 取排行榜上的用户</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 取0回复的主题</span></div><div class=\"line\">  cache.get(<span class=\"string\">'no_reply_topics'</span>, proxy.done(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">no_reply_topics</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (no_reply_topics) &#123;</div><div class=\"line\">      proxy.emit(<span class=\"string\">'no_reply_topics'</span>, no_reply_topics);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      Topic.getTopicsByQuery(</div><div class=\"line\">        &#123; <span class=\"attr\">reply_count</span>: <span class=\"number\">0</span>, <span class=\"attr\">tab</span>: &#123;<span class=\"attr\">$ne</span>: <span class=\"string\">'job'</span>&#125;&#125;,</div><div class=\"line\">        &#123; <span class=\"attr\">limit</span>: <span class=\"number\">5</span>, <span class=\"attr\">sort</span>: <span class=\"string\">'-create_at'</span>&#125;,</div><div class=\"line\">        proxy.done(<span class=\"string\">'no_reply_topics'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">no_reply_topics</span>) </span>&#123;</div><div class=\"line\">          cache.set(<span class=\"string\">'no_reply_topics'</span>, no_reply_topics, <span class=\"number\">60</span> * <span class=\"number\">1</span>);</div><div class=\"line\">          <span class=\"keyword\">return</span> no_reply_topics;</div><div class=\"line\">        &#125;));</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;));</div><div class=\"line\">  <span class=\"comment\">// END 取0回复的主题</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 取分页数据</span></div><div class=\"line\">  <span class=\"keyword\">var</span> pagesCacheKey = <span class=\"built_in\">JSON</span>.stringify(query) + <span class=\"string\">'pages'</span>;</div><div class=\"line\">  cache.get(pagesCacheKey, proxy.done(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">pages</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pages) &#123;</div><div class=\"line\">      proxy.emit(<span class=\"string\">'pages'</span>, pages);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      Topic.getCountByQuery(query, proxy.done(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">all_topics_count</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> pages = <span class=\"built_in\">Math</span>.ceil(all_topics_count / limit);</div><div class=\"line\">        cache.set(pagesCacheKey, pages, <span class=\"number\">60</span> * <span class=\"number\">1</span>);</div><div class=\"line\">        proxy.emit(<span class=\"string\">'pages'</span>, pages);</div><div class=\"line\">      &#125;));</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;));</div><div class=\"line\">  <span class=\"comment\">// END 取分页数据</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> tabName = renderHelper.tabName(tab);</div><div class=\"line\">  proxy.all(<span class=\"string\">'topics'</span>, <span class=\"string\">'tops'</span>, <span class=\"string\">'no_reply_topics'</span>, <span class=\"string\">'pages'</span>,</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">topics, tops, no_reply_topics, pages</span>) </span>&#123;</div><div class=\"line\">      res.render(<span class=\"string\">'index'</span>, &#123;</div><div class=\"line\">        <span class=\"attr\">topics</span>: topics,</div><div class=\"line\">        <span class=\"attr\">current_page</span>: page,</div><div class=\"line\">        <span class=\"attr\">list_topic_count</span>: limit,</div><div class=\"line\">        <span class=\"attr\">tops</span>: tops,</div><div class=\"line\">        <span class=\"attr\">no_reply_topics</span>: no_reply_topics,</div><div class=\"line\">        <span class=\"attr\">pages</span>: pages,</div><div class=\"line\">        <span class=\"attr\">tabs</span>: config.tabs,</div><div class=\"line\">        <span class=\"attr\">tab</span>: tab,</div><div class=\"line\">        <span class=\"attr\">pageTitle</span>: tabName &amp;&amp; (tabName + <span class=\"string\">'版块'</span>),</div><div class=\"line\">      &#125;);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>代码中看到了 <code>proxy.emit(&#39;ev&#39;)</code> , <code>proxy.done(&#39;ev&#39;,fn)</code>,<code>proxy.fail(next)</code> 所以要看懂这段代码,就必须了解eventproxy使用方法(当然可以猜测具体的作用)。查看了GitHub上的README,遗憾的是api文档现在不能正常访问了,出于学习的态度,简单的阅读了源码实现:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">!(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name, definition</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// Check define</span></div><div class=\"line\">  <span class=\"keyword\">var</span> hasDefine = <span class=\"keyword\">typeof</span> define === <span class=\"string\">'function'</span>,</div><div class=\"line\">    <span class=\"comment\">// Check exports</span></div><div class=\"line\">    hasExports = <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">module</span>.exports;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (hasDefine) &#123;</div><div class=\"line\">    <span class=\"comment\">// AMD Module or CMD Module</span></div><div class=\"line\">    define(<span class=\"string\">'eventproxy_debug'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;&#125;); <span class=\"comment\">// 定义一个eventproxy_debug 模块，返回一个空函数作为debug函数。</span></div><div class=\"line\">    define([<span class=\"string\">'eventproxy_debug'</span>], definition); <span class=\"comment\">// 依赖前面定义的模块，作为debug参数传入definition中。</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hasExports) &#123;</div><div class=\"line\">    <span class=\"comment\">// Node.js Module</span></div><div class=\"line\">    <span class=\"built_in\">module</span>.exports = definition(<span class=\"built_in\">require</span>(<span class=\"string\">'debug'</span>)(<span class=\"string\">'eventproxy'</span>));</div><div class=\"line\">    <span class=\"comment\">// debug 模块，一个简单的输出调试信息模块</span></div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Assign to common namespaces or simply the global object (window)</span></div><div class=\"line\">    <span class=\"keyword\">this</span>[name] = definition();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)(<span class=\"string\">'EventProxy'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">debug</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>首先是定义了一系列的环境支持。像AMD,CMD,UMD,CommonJS。EventProxy 是最终的模块名称,真正的定义需要传入一个debug函数。其实就是日志输出工具,接下来就是具体的定义和实现:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.addListener = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ev, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//....</span></div><div class=\"line\">&#125;</div><div class=\"line\">EventProxy.prototype.bind = EventProxy.prototype.addListener;</div><div class=\"line\">EventProxy.prototype.on = EventProxy.prototype.addListener;</div><div class=\"line\">EventProxy.prototype.subscribe = EventProxy.prototype.addListener;</div></pre></td></tr></table></figure>\n<p>注册事件函数和它的一系列别名,别名也是挺多的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.headbind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev, callback</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">    debug(<span class=\"string\">'Add listener for %s'</span>, ev);</div><div class=\"line\">    <span class=\"keyword\">this</span>._callbacks[ev] = <span class=\"keyword\">this</span>._callbacks[ev] || [];</div><div class=\"line\">    <span class=\"keyword\">this</span>._callbacks[ev].unshift(callback);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>代码比较简单,直接说下具体的作用吧,headbind 顾名思义,就是绑定的同时通过数组的unshift函数将事件回调函数放在最前面,接下来是解绑事件函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.removeListener = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventname, callback</span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> calls = <span class=\"keyword\">this</span>._callbacks;</div><div class=\"line\">   <span class=\"keyword\">if</span> (!eventname) &#123;</div><div class=\"line\">     debug(<span class=\"string\">'Remove all listeners'</span>);</div><div class=\"line\">     <span class=\"keyword\">this</span>._callbacks = &#123;&#125;;</div><div class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">     <span class=\"keyword\">if</span> (!callback) &#123;</div><div class=\"line\">       debug(<span class=\"string\">'Remove all listeners of %s'</span>, eventname);</div><div class=\"line\">       calls[eventname] = [];</div><div class=\"line\">     &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">       <span class=\"keyword\">var</span> list = calls[eventname];</div><div class=\"line\">       <span class=\"keyword\">if</span> (list) &#123;</div><div class=\"line\">         <span class=\"keyword\">var</span> l = list.length;</div><div class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; l; i++) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span> (callback === list[i]) &#123;</div><div class=\"line\">             debug(<span class=\"string\">'Remove a listener of %s'</span>, eventname);</div><div class=\"line\">             list[i] = <span class=\"literal\">null</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\"> &#125;;</div></pre></td></tr></table></figure>\n<p>这个函数作用很简单就是删除(其实是对数组中相应元素下标置为null)绑定的事件回调函数,如果没有指明删除具体哪个回调函数 callback ，则删除这个事件上绑定的所有回调函数,如果连eventname都没有提供则删除所有事件上绑定的所有回调函数,这个方法的别名,<code>unbind</code>。还有根据前面两个绑定和解绑衍生出来的几个方法,<code>removeAllListeners</code>,<code>bindForAll</code>,<code>unbindForAll</code>。 在all事件上绑定处理函数,意味着任何事件触发都会执行all事件上的回调函数,下面源码一看就一目了然了:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.trigger = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventname, data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> list, ev, callback, i, l;</div><div class=\"line\">    <span class=\"keyword\">var</span> both = <span class=\"number\">2</span>; <span class=\"comment\">// 设置为2的目的是，第一次先执行具体事件上的回调函数，第二次执行绑定在ALL_EVENT上的回调函数。</span></div><div class=\"line\">    <span class=\"keyword\">var</span> calls = <span class=\"keyword\">this</span>._callbacks;</div><div class=\"line\">    debug(<span class=\"string\">'Emit event %s with data %j'</span>, eventname, data);</div><div class=\"line\">    <span class=\"keyword\">while</span> (both--) &#123;</div><div class=\"line\">      ev = both ? eventname : ALL_EVENT;</div><div class=\"line\">      list = calls[ev];</div><div class=\"line\">      <span class=\"keyword\">if</span> (list) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>, l = list.length; i &lt; l; i++) &#123;</div><div class=\"line\">          <span class=\"keyword\">if</span> (!(callback = list[i])) &#123; <span class=\"comment\">//如果callback为null，回调函数数组中剔除空元素，修正循环下标和数组长度。</span></div><div class=\"line\">            list.splice(i, <span class=\"number\">1</span>);</div><div class=\"line\">            i--;</div><div class=\"line\">            l--;</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> args = [];</div><div class=\"line\">            <span class=\"keyword\">var</span> start = both ? <span class=\"number\">1</span> : <span class=\"number\">0</span>; <span class=\"comment\">// 如果是具体事件上的回调函数执行，参数不包括事件名称，如果是ALL_EVENT上的回调函数</span></div><div class=\"line\">            <span class=\"comment\">//执行，参数包括事件名称。</span></div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = start; j &lt; <span class=\"built_in\">arguments</span>.length; j++) &#123;</div><div class=\"line\">              args.push(<span class=\"built_in\">arguments</span>[j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            callback.apply(<span class=\"keyword\">this</span>, args);</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;;</div></pre></td></tr></table></figure>\n<p>both 设置成2,就是执行完一次对于事件回调函数后,还要再执行一次all事件上的回调函数,也是很嗨的。然后它的别名也是蛮多的,<code>emit</code>,<code>fire</code>,所以最上面源码中的<code>proxy.emit</code>也就知道作用了。接下来继续看源代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.once = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">  <span class=\"comment\">//包装回调函数，执行完后自己解绑。</span></div><div class=\"line\">  <span class=\"keyword\">var</span> wrapper = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    callback.apply(self, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">    self.unbind(ev, wrapper);</div><div class=\"line\">  &#125;;</div><div class=\"line\">  <span class=\"keyword\">this</span>.bind(ev, wrapper);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>通过对callback 进行一层包装,包装后的函数会在运行callback后 <code>self.unbind(ev, wrapper);</code> 进行自我解绑,从而使得callback只会触发执行一次。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 方法使用优先级 setImmediate -&gt; nextTick -&gt; setTimeout</span></div><div class=\"line\"> <span class=\"keyword\">var</span> later = (<span class=\"keyword\">typeof</span> setImmediate !== <span class=\"string\">'undefined'</span> &amp;&amp; setImmediate) ||</div><div class=\"line\">   (<span class=\"keyword\">typeof</span> process !== <span class=\"string\">'undefined'</span> &amp;&amp; process.nextTick) || <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">   setTimeout(fn, <span class=\"number\">0</span>);</div><div class=\"line\"> &#125;;</div></pre></td></tr></table></figure>\n<p>这里定义了异步方法,各个方法的区别和有关事件循环的内容可以参看我总结的另一篇文章<a href=\"http://weeklyweb.info/2017/05/05/fe-event-loop/\" target=\"_blank\" rel=\"external\">JavaScript &amp; NodeJS 事件循环</a>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"comment\">//使得触发事件行为变成异步</span></div><div class=\"line\">EventProxy.prototype.emitLater = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</div><div class=\"line\">  later(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    self.trigger.apply(self, args);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>不知道emitLater这个方法使用场景,根据代码可以知道就是延迟触发事件,不明觉厉了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 绑定完事件回调后立马先触发一次</span></div><div class=\"line\">EventProxy.prototype.immediate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev, callback, data</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.bind(ev, callback); <span class=\"comment\">// 绑定事件</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.trigger(ev, data); <span class=\"comment\">// 立马触发</span></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\">EventProxy.prototype.asap = EventProxy.prototype.immediate;</div></pre></td></tr></table></figure>\n<p>immediate 方法和它的别名asap,作用就是绑定事件函数后立马执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> _assign = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventname1, eventname2, cb, once</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> proxy = <span class=\"keyword\">this</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> argsLength = <span class=\"built_in\">arguments</span>.length;</div><div class=\"line\">  <span class=\"keyword\">var</span> times = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> flag = &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Check the arguments length.</span></div><div class=\"line\">  <span class=\"comment\">//必须提供至少3个参数</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (argsLength &lt; <span class=\"number\">3</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> events = SLICE.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>, <span class=\"number\">-2</span>);</div><div class=\"line\">  <span class=\"keyword\">var</span> callback = <span class=\"built_in\">arguments</span>[argsLength - <span class=\"number\">2</span>];</div><div class=\"line\">  <span class=\"keyword\">var</span> isOnce = <span class=\"built_in\">arguments</span>[argsLength - <span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Check the callback type.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">\"function\"</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  debug(<span class=\"string\">'Assign listener for events %j, once is %s'</span>, events, !!isOnce);</div><div class=\"line\">  <span class=\"keyword\">var</span> bind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">key</span>) </span>&#123; <span class=\"comment\">//计数 收集数据</span></div><div class=\"line\">    <span class=\"keyword\">var</span> method = isOnce ? <span class=\"string\">\"once\"</span> : <span class=\"string\">\"bind\"</span>;</div><div class=\"line\">    proxy[method](key, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">      proxy._fired[key] = proxy._fired[key] || &#123;&#125;;</div><div class=\"line\">      proxy._fired[key].data = data;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!flag[key]) &#123;</div><div class=\"line\">        flag[key] = <span class=\"literal\">true</span>;</div><div class=\"line\">        times++;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> length = events.length;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; length; index++) &#123;</div><div class=\"line\">    bind(events[index]);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> _all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (times &lt; length) &#123; <span class=\"comment\">// 用来保证是否所有事件都已经触发过</span></div><div class=\"line\">      <span class=\"keyword\">return</span>; </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!flag[event]) &#123; <span class=\"comment\">// 确保是提供的参数中包含的事件被触发</span></div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> data = [];</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; length; index++) &#123;</div><div class=\"line\">      data.push(proxy._fired[events[index]].data); <span class=\"comment\">// 收集所有数据</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (isOnce) &#123; <span class=\"comment\">// 是否只需要触发一次</span></div><div class=\"line\">      proxy.unbindForAll(_all);</div><div class=\"line\">    &#125;</div><div class=\"line\">    debug(<span class=\"string\">'Events %j all emited with data %j'</span>, events, data);</div><div class=\"line\">    callback.apply(<span class=\"literal\">null</span>, data); <span class=\"comment\">// 调用回调函数</span></div><div class=\"line\">  &#125;;</div><div class=\"line\">  proxy.bindForAll(_all); <span class=\"comment\">// 将新够造的回调函数</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>该方法的作用是收集前面事件触发后传给回调函数的数据，然后最后构成一个数据数组，传给callback（cb）如果调用时传入的 once 为 true,则这个callback 只会被调用一次否则会多次被调用。这个方法是一个内部方法,其中暴露给用户使用的是下面的方法:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.all = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventname1, eventname2, callback</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> args = CONCAT.apply([], <span class=\"built_in\">arguments</span>);</div><div class=\"line\">  args.push(<span class=\"literal\">true</span>);</div><div class=\"line\">  _assign.apply(<span class=\"keyword\">this</span>, args); </div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\">EventProxy.prototype.assign = EventProxy.prototype.all;</div><div class=\"line\"></div><div class=\"line\">EventProxy.prototype.tail = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> args = CONCAT.apply([], <span class=\"built_in\">arguments</span>);</div><div class=\"line\">    args.push(<span class=\"literal\">false</span>);</div><div class=\"line\">    _assign.apply(<span class=\"keyword\">this</span>, args);</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\">EventProxy.prototype.assignAll = EventProxy.prototype.tail;</div><div class=\"line\">EventProxy.prototype.assignAlways = EventProxy.prototype.tail;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>all 方法,别名 assign </p>\n<p>  绑定一系列事件，当这些事件都触发了，callback会被执行一次,执行完就解绑自己,所以后续不会再被触发执行。</p>\n</li>\n<li><p>tail 方法,别名 assignAll , assignAlways</p>\n<p>  绑定一些事件，当所有事件都触发了，callback 会被触发，以后只要这些事件中的事件再次被触发，callback都会被执行。</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">EventProxy.prototype.fail = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\"></div><div class=\"line\">   that.once(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">     that.unbind();</div><div class=\"line\">     <span class=\"comment\">// put all arguments to the error handler</span></div><div class=\"line\">     <span class=\"comment\">// fail(function(err, args1, args2, ...)&#123;&#125;)</span></div><div class=\"line\">     callback.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>);</div><div class=\"line\">   &#125;);</div><div class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\"> &#125;;</div><div class=\"line\"></div><div class=\"line\"> EventProxy.prototype.throw = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\">   that.emit.apply(that, [<span class=\"string\">'error'</span>].concat(SLICE.call(<span class=\"built_in\">arguments</span>)));</div><div class=\"line\"> &#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>fail 方法</p>\n<p>绑定事件到error上,当出现error事件的时候,执行回调函数,并解绑所有的事件绑定。</p>\n</li>\n<li><p>throw </p>\n<p>error 事件触发的缩写。通过throw方法,就可以触发fail方法绑定的回调函数,这里<code>proxy.fail(next)</code>,这边错误发生执行的回调函数就是next。</p>\n</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">  EventProxy.prototype.done = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">handler, callback</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"comment\">//重新返回一个回调函数</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">        <span class=\"comment\">// put all arguments to the error handler</span></div><div class=\"line\">        <span class=\"comment\">// 如果出现错误,则直接出发erorr事件,并返回</span></div><div class=\"line\">        <span class=\"keyword\">return</span> that.emit.apply(that, [<span class=\"string\">'error'</span>].concat(SLICE.call(<span class=\"built_in\">arguments</span>)));</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// callback(err, args1, args2, ...)</span></div><div class=\"line\">      <span class=\"comment\">// 获取到数据,剔除err参数</span></div><div class=\"line\">      <span class=\"keyword\">var</span> args = SLICE.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"comment\">// 如果handler是字符串</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> handler === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// getAsync(query, ep.done('query'));</span></div><div class=\"line\">        <span class=\"comment\">// or</span></div><div class=\"line\">        <span class=\"comment\">// getAsync(query, ep.done('query', function (data) &#123;</span></div><div class=\"line\">        <span class=\"comment\">//   return data.trim();</span></div><div class=\"line\">        <span class=\"comment\">// &#125;));</span></div><div class=\"line\">        <span class=\"comment\">//存在callback</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (callback) &#123;</div><div class=\"line\">          <span class=\"comment\">// 获取 callback 处理的数据。</span></div><div class=\"line\">          <span class=\"comment\">// only replace the args when it really return a result</span></div><div class=\"line\">          <span class=\"keyword\">return</span> that.emit(handler, callback.apply(<span class=\"literal\">null</span>, args));</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">// put all arguments to the done handler</span></div><div class=\"line\">          <span class=\"comment\">//ep.done('some');</span></div><div class=\"line\">          <span class=\"comment\">//ep.on('some', function(args1, args2, ...)&#123;&#125;);</span></div><div class=\"line\">          <span class=\"comment\">// 如果callback 未提供,直接触发事件,参数为新回调函数获取到的内容</span></div><div class=\"line\">          <span class=\"keyword\">return</span> that.emit.apply(that, [handler].concat(args));</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// speed improve for mostly case: `callback(err, data)`</span></div><div class=\"line\">      <span class=\"comment\">// 如果handler提供的是function 且 则直接执行</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length &lt;= <span class=\"number\">2</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> handler(data);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// callback(err, args1, args2, ...)</span></div><div class=\"line\">      handler.apply(<span class=\"literal\">null</span>, args);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>done 方法</p>\n<p>事件回调包装函数,handler 事件名称,callback 结果数据处理函数,返回新的结果数据。具体解释参看源码中的注释,主要分几种情况:</p>\n<ul>\n<li><p>handler 参数提供且为字符串</p>\n<ol>\n<li><p>如果提供了 callback 结果处理函数</p>\n<p>调用 <code>that.emit(handler, callback.apply(null, args));</code> 作为参数的数据是经过 callback 处理后的值。</p>\n</li>\n<li><p>如果未提供 callback 参数</p>\n<p>调用 <code>that.emit.apply(that, [handler].concat(args));</code> 数据参数为 handler 加上 args(异步操作结果数据) 。</p>\n</li>\n</ol>\n</li>\n<li><p>handler 为 Function</p>\n<ol>\n<li>如果异步操作结果数据的参数只有两个,类似这种情形<code>callback(err,data)</code> 则直接调用<code>handler(data);</code>。</li>\n<li>如果异步操作结果数据的参数不止两个,类似<code>callback(err,arg1,arg2,...)</code> 这种,则调用<code>handler.apply(null, args);</code>。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>虽然eventproxy的源代码比较简单,但是在阅读的过程中也添加了部分注释,有兴趣可以看下,地址:<a href=\"https://github.com/xdimh/eventproxy-comments/blob/master/eventproxy.js\" target=\"_blank\" rel=\"external\">https://github.com/xdimh/eventproxy-comments/blob/master/eventproxy.js</a></p>\n"},{"title":"浅谈h5页面在安卓端动画卡顿优化","type":"original","date":"2017-08-01T05:42:21.000Z","description":null,"_content":"\n\nweb page 性能优化的几个点\n\n1. 关于资源加载\n2. 浏览器端渲染速度 \n3. 内存泄漏 \n","source":"_drafts/talk-h5-performance-lightly.md","raw":"---\ntitle: 浅谈h5页面在安卓端动画卡顿优化\ntype: original\ntags: []\ncategories: []\ndate: 2017-08-01 13:42:21\ndescription:\n---\n\n\nweb page 性能优化的几个点\n\n1. 关于资源加载\n2. 浏览器端渲染速度 \n3. 内存泄漏 \n","slug":"talk-h5-performance-lightly","published":0,"updated":"2017-08-01T05:44:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhpe0002b37qcn75tt0c","content":"<p>web page 性能优化的几个点</p>\n<ol>\n<li>关于资源加载</li>\n<li>浏览器端渲染速度 </li>\n<li>内存泄漏 </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>web page 性能优化的几个点</p>\n<ol>\n<li>关于资源加载</li>\n<li>浏览器端渲染速度 </li>\n<li>内存泄漏 </li>\n</ol>\n"},{"title":"base64的编码和解码","type":"original","date":"2017-04-26T08:16:54.000Z","description":null,"_content":"\nbase64编码在各种编码中应该算是比较简单的一种了,在前端中很多地方有被应用到,小图片base64后内联,与客户端交互的jsBridge中数据的base64编码传输,小程序中字体图标base64后内联等等。这次在项目中用到了base64的编码和解码,网上搜了一把有很多base64操作的js实现,之前一直对base64编码半知半解,看着代码中的各种位操作也是云里雾里,所以借这次项目机会稍微深入的了解了下base64这个东西。\n\n\n### 什么是base64编码?\n对于base64 我们首先需要先看下ASCII编码,想必大家都知道在计算机内部所有的信息数据都表现为二进制的形式,就是那些0101数字串,每一个二进制位(bit)有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到1111111。ASCII码就是用后7位二进制表示了128个字符,这对英语来说是够用了,所需要的字母都能在这后7位中表现出来。那么base64编码的规则又是什么,base64就是选出64个字符作为一个基本的字符集,然后在将其他文字符号都转换成这个字符集中的字符以予表示。这64个字符分别是``a-z``,``A-Z`` ,``0-9``,符号``+``、``-``,除了前面几位还有``=``占位符,不属于所表示的内容。\n\n### 字符base64编码的几个步骤\n> 1. 将待转换的字符串用二进制的形式表示出来。<br/>\n> 2. 然后每三个字节一组,也就是24个二进制位分成一组。\n> 3. 再将这24个二进制位分成6组,每四个一组,每组6位二进制位。\n> 4. 在每一组最前面添加两个00补全成八位,使得24位变成32位刚好凑成4个字节。\n> 5. 然后计算每个字节所表示的数值(10进制),根据下表查表拼装转换后的字符形成最后base64字符。\n\n|    数值    | 符号   | 数值 | 符号 | 数值 | 符号 | 数值 | 符号 |\n|:---------:|:-----:|:-----:| :-----:|:-----:| :-----:|:-----:| :-----:|\n| 0 | A | 17 | R | 34 | i | 51 | z |\n| 1 | B | 18 | S | 35 | j | 52 | 0 |\n| 2 | C | 18 | T | 36 | k | 53 | 1 |\n| 3 | D | 20 | U | 37 | l | 54 | 2 |\n| 4 | E | 21 | V | 38 | m | 55 | 3 |\n| 5 | F | 22 | W | 39 | n | 56 | 4 |\n| 6 | G | 23 | X | 40 | o | 57 | 5 |\n| 7 | H | 24 | Y | 41 | p | 58 | 6 |\n| 8 | I | 25 | Z | 42 | q | 59 | 7 |\n| 9 | J | 26 | a | 43 | r | 60 | 8 |\n| 10| K | 27 | b | 44 | s | 61 | 9 |\n| 11| L | 28 | c | 45 | t | 62 | + |\n| 12| M | 29 | d | 46 | u | 63 | / |\n| 13| N | 30 | e | 47 | v |    |   |\n| 14| O | 31 | f | 48 | w |    |   |　　\n| 15| P | 32 | g | 49 | x |    |   |\n| 16| Q | 33 | h | 50 | y |    |   |\n\n在转换的过程中可以发现,并不是所有的带转换字符串最后表示的二进制串所含的字节数都是3的倍数。所以针对这些不到3个字节的情况,会有相应的处理方式。\n1. 最后剩两个字节的情况\n    > 分成三组,前两组最前面加``00``组成两个字节,后面剩下的4位最前面加两个0,最后面加两个0,组成一个字节,最后补上一个``=``构成四个字节。\n2. 最后只剩一个字节的情况\n    > 分成两组,第一组6位最前面添加两位0,后面还剩2位,在最前面添加两个0,然后在最后面添加四个0构成两个字节,补上两个``=``,构成四个字节。(为什么前面要补两个00,这样计算二进制一个字节所表示的数值才能一一映射到64个字符中)\n\n### Unicode\n> Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。但并没有规定具体在计算机中的存储方式。Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）。\n\nUTF-8就是其中的一种实现方式。后面会讲Unicode的编码方式如何转换成UTF-8实现方式的。Unicode有17个code plane,其中0x0000 ~ 0xffff 称为基本多语言平面,0x10000 ~ 0x10ffff 16个为辅助平面。其中基本多语言平面已经涵盖了大部分常用字，如大部分的汉字,所以只需要对这个范围进行处理已经够用。[参考Unicode字符平面映射](https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84)\n\n### UTF-8 和 Unicode之间的转换关系 \n首先,UTF-8是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码,是在互联网上使用最广的一种Unicode的实现方式。特点就是一种变长的编码方式,可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n> 1. 128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。\n> 2. 带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。\n> 3. 其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。\n> 4. 其他极少使用的Unicode 辅助平面的字符使用四字节编码\n\n具体的转换对应关系如下表:\n\n| code point | UTF-8字节流 | \n|:---------:|---------:|\n| U+00000000 – U+0000007F | 0xxxxxxx |\n| U+00000080 – U+000007FF | 110xxxxx 10xxxxxx |\n| U+00000800 – U+0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx |\n| U+00010000 – U+001FFFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |\n\n由上表可见,转换后的字节数由第一个字节二进制串从左到右1的位数决定,``0``表示一个字节,``110``表示两个字节,``1110``对应三个字节,``11110``四个字节,后续字节都以``10``开始。根据这个规律我们就可以在代码实现上进行对Unicode和UTF-8之间进行转换。\n\n### JavaScript内部使用的编码方式\n> JavaScript 引擎内部是自由的使用 UCS-2 或者 UTF-16。大多数引擎使用的是 UTF-16，无论它们使用什么方式实现，它只是一个具体的实现，这不会影响到语言的特性。然后对于 ECMAScript/JavaScript 语言本身，实现的效果是通过 UCS-2，而非 UTF-16。[参考:JavaScript 的内部字符编码是 UCS-2 还是 UTF-16](https://www.w3ctech.com/topic/1869)\n\n所以对于JavaScript,无论是UCS-2还是UTF-16都是一样,采用的是两个字节来存储字符。\n\n>ECMAScript source text is represented as a sequence of characters in the Unicode character encoding,version 3.0 or later. ... ... ECMAScript source text is assumed to be a sequence of 16-bit code units for the purposes of this specification. Such a source text may include sequences of 16-bit code units that are not valid UTF-16 character encodings. If an actual source text is encoded in a form other than 16-bit code units it must be processed as if it was first converted to UTF-16. [参考:ECMA-262 5.1 Edition](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)\n\n为了在加密解密中文字符不出现乱码,所以需要在将中文字符编码成``base64``之前,先将``UCS-2/UTF-16`` 转换成 ``UTF-8`` (这里只考虑中文字符是UTF-8的情况),然后再应用``base64``编码规则进行编码得到最终结果。同样在解码的时候需要按照``base64``编码规则反向操作转成``UTF-8``格式,然后再将UTF-8转回成``UCS-2/UTF-16``。\n\n### UTF-8 和 JavaScript 内部编码互相转换实现。\n首先,了解JavaScript中几个方法``String.charCodeAt``,``String.fromCharCode()``,``Number.prototype.toString``。\n* [String.charCodeAt](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)\n  > charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 > 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。\n  \n  ```javascript\n  '中'.charCodeAt(0);\n  20013\n  ```\n* [String.fromCharCode](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode)\n  > charCodeAt的反向操作\n  \n  ```javascript\n  String.fromCharCode(20013);\n  \"中\"\n  ```\n* [Number.prototype.toString](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)\n  > 将十进制码点转换成2进制。\n  \n  ```javascript\n  var code = 20013;\n  code.toString(2);\n  \"100111000101101\"\n  ```\n互相转换源代码如下:\n* UTF-16 -> UTF-8\n  ```javascript\n  const Base64 = {\n      ...,\n       _utf8_encode: function(str) {\n          // 将换行符统一成\\n\n          str = str.replace(/\\r\\n/g, \"\\n\");\n          let out = \"\";\n          for (var n = 0; n < str.length; n++) {\n            let unicode = str.charCodeAt(n);\n            if ((unicode >= 0x0001) && (unicode <= 0x007f)) {\n              //在这个范围内的是ASCII字符,只需一个字节。\n              out += str.charAt(n);\n            } else if (unicode > 0x07ff) {\n              //将16位unicode前四位和1110xxxx 进行拼接\n              out += String.fromCharCode(0xe0 | ((unicode >> 12) & 0x0f));\n              //将接下来的6位和10xxxxxx进行拼接\n              out += String.fromCharCode(0x80 | ((unicode >>  6) & 0x3f));\n              //将接下来的6位和10xxxxxx进行拼接\n              out += String.fromCharCode(0x80 | ((unicode >>  0) & 0x3f));\n            } else {\n              //将16位unicode前5位和110xxxxx 进行拼接\n              out += String.fromCharCode(0xc0 | ((unicode >>  6) & 0x1f));\n              //将接下来的6位和10xxxxxx进行拼接\n              out += String.fromCharCode(0x80 | ((unicode >>  0) & 0x3f));\n            }\n          }\n          return out;\n        },\n      ...\n  }\n  ```\n* UTF8 -> UTF-16\n  ```javascript\n  const Base64 = {\n    ...,\n     _utf8_decode: function(str) {\n        let out = \"\",n = 0, c1,c2,c3;\n        c1 = c2 = c3 = 0;\n        while (n < str.length) {\n          c1 = str.charCodeAt(n);\n          if (c1 < 0x80) {\n            //编码为0xxxxxxx 表示utf8 一个字节\n            out += String.fromCharCode(c1);\n            n++\n          } else if (c1 > 0xc0 && c1 < 0xe0) {\n            //编码为110xxxxx 10xxxxxx 表示2个字节\n            c2 = str.charCodeAt(n + 1);\n            out += String.fromCharCode((c1 & 0x1f) << 6 | c2 & 0x3f);\n            n += 2\n          } else {\n            //编码为1110xxxx 10xxxxxx 0xxxxxxx 表示utf8 三个字节\n            c2 = str.charCodeAt(n + 1);\n            c3 = str.charCodeAt(n + 2);\n            out += String.fromCharCode((c1 & 0x0f) << 12 | (c2 & 0x3f) << 6 | c3 & 0x3f);\n            n += 3\n          }\n        }\n        return out\n      },\n    ...\n  }\n  ```\n  \n### base64编码和解码的实现\n* base64编码 \n  ```javascript\n  const Base64 = {\n    ...,\n    //base64 所用的64个字符和其中的一个补位符'='\n    _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    encode: function(str) {\n      //base64转换算法就是根据具体的规则将3个字符变成四个字符。\n      let out = \"\",c1,c2,c3,\n        outC1,outC2,outC3,outC4,i = 0;\n      str = Base64._utf8_encode(str); //将utf16 转换成utf8,因为JavaScript内部采用的是utf16存储所以要进行一步转换。\n      while (i < str.length) {\n        // 三个三个字符一组进行转换\n        c1 = str.charCodeAt(i++);\n        c2 = str.charCodeAt(i++);\n        c3 = str.charCodeAt(i++);\n        outC1 = c1 >> 2; //第一个字符最前面添加两个0,剩余2位用作后面拼接\n        outC2 = (c1 & 0x03) << 4 | c2 >> 4; // 第一个字符剩下两位和第二个字符前四位拼接,并在前面添加2个0拼成一个字符\n        outC3 = (c2 & 0x0f) << 2 | c3 >> 6; //第二个字符剩余4位和第三个字符的前两位,并在前面添加2个0拼接成一个字符\n        outC4 = c3 & 0x3f; //第三个字符剩下的6位前面添加两个0 拼接成一个字符\n        //如果c2为不存在则最后两个字符为补位符'=' 如果c3不存在 则转换后最后一位为补位'='\n        if (isNaN(c2)) { outC3 = outC4 = 64 } else if (isNaN(c3)) { outC4 = 64 }\n        out = out + this._keyStr.charAt(outC1) + this._keyStr.charAt(outC2) + this._keyStr.charAt(outC3) + this._keyStr.charAt(outC4)\n      }\n      return out\n    },\n    ...\n  }\n  ```\n* base64 解码\n  ```javascript\n  const Base64 = {\n      ...,\n      decode: function(str) {\n          let out = '',c1,c2,c3,c4,outC1,outC2,outC3,i = 0;\n          //去掉非base64字符\n          str = str.replace(/[^A-Za-z0-9+/=]/g, \"\");\n          //循环处理进行解码\n          while (i < str.length) {\n            //4个base64字符一组,解码后将转换成3个字符\n            c1 = this._keyStr.indexOf(str.charAt(i++));\n            c2 = this._keyStr.indexOf(str.charAt(i++));\n            c3 = this._keyStr.indexOf(str.charAt(i++));\n            c4 = this._keyStr.indexOf(str.charAt(i++));\n            //每个字符前面都会有两个前导0\n            outC1 = c1 << 2 | c2 >> 4; //第一个base64字符去掉两个0后和第二个字符的开头两个字符拼成一个字节\n            outC2 = (c2 & 0x0f) << 4 | c3 >> 2; //第二个剩下的4位和第三个开始的四位拼成一个字节\n            outC3 = (c3 & 0x03) << 6 | c4; // 第三个剩下的2位和第四个6位拼成一个字节\n            out = out + String.fromCharCode(outC1);\n            //如果倒数第二个不是补位符'='\n            if (c3 != 64) { out = out + String.fromCharCode(outC2) }\n            //如果倒数第一个不是补位符'='\n            if (c4 != 64) { out = out + String.fromCharCode(outC3) }\n          }\n          out = Base64._utf8_decode(out); // 将utf8转成utf16\n          return out\n        },\n      ...\n  }\n  ```\n\n### Update: 2017-03-15\n  \n根据[rfc3548](https://tools.ietf.org/html/rfc3548#page-6),base64中的某些字符,在一些文件系统环境下或者url中会有特殊的含义,比如斜杠,所以为了得到web safe 的base64编码,则需要将第62个字符和第63个字符(编号从0开始)替换成 ``-``(minus) 和 ``_``(underscore) 减号和下划线。\n可以对编码后的base64进行字符替换如下 :\n\n```javascript\nfunction urlSafeBase64Encode(input) {\n    return input.replace('+', '-').replace('/', '_');\n}\n```\n  \n### [完整代码](https://github.com/xdimh/jsTools/blob/master/base64_with_comment.js)\n\n### 参考资料\n\n1. [维基百科UTF-8](https://zh.wikipedia.org/wiki/UTF-8)\n2. [维基百科Unicode](https://zh.wikipedia.org/wiki/Unicode)\n3. [字符编码笔记：ASCII，Unicode和UTF-8 —— 阮一峰](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n4. [Base64笔记 —— 阮一峰](http://www.ruanyifeng.com/blog/2008/06/base64.html)\n5. [Unicode与JavaScript详解 —— 阮一峰](http://www.ruanyifeng.com/blog/2014/12/unicode.html)\n6. [Unicode编码及其实现：UTF-16、UTF-8，and more](http://blog.csdn.net/thl789/article/details/7506133)\n7. [通过javascript进行UTF-8编码](https://segmentfault.com/a/1190000005794963)\n8. [按位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)","source":"_posts/base64.md","raw":"---\ntitle: base64的编码和解码\ntype: original\ntags: [前端大杂烩]\ncategories: [前端大杂烩]\ndate: 2017-04-26 16:16:54\ndescription:\n---\n\nbase64编码在各种编码中应该算是比较简单的一种了,在前端中很多地方有被应用到,小图片base64后内联,与客户端交互的jsBridge中数据的base64编码传输,小程序中字体图标base64后内联等等。这次在项目中用到了base64的编码和解码,网上搜了一把有很多base64操作的js实现,之前一直对base64编码半知半解,看着代码中的各种位操作也是云里雾里,所以借这次项目机会稍微深入的了解了下base64这个东西。\n\n\n### 什么是base64编码?\n对于base64 我们首先需要先看下ASCII编码,想必大家都知道在计算机内部所有的信息数据都表现为二进制的形式,就是那些0101数字串,每一个二进制位(bit)有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到1111111。ASCII码就是用后7位二进制表示了128个字符,这对英语来说是够用了,所需要的字母都能在这后7位中表现出来。那么base64编码的规则又是什么,base64就是选出64个字符作为一个基本的字符集,然后在将其他文字符号都转换成这个字符集中的字符以予表示。这64个字符分别是``a-z``,``A-Z`` ,``0-9``,符号``+``、``-``,除了前面几位还有``=``占位符,不属于所表示的内容。\n\n### 字符base64编码的几个步骤\n> 1. 将待转换的字符串用二进制的形式表示出来。<br/>\n> 2. 然后每三个字节一组,也就是24个二进制位分成一组。\n> 3. 再将这24个二进制位分成6组,每四个一组,每组6位二进制位。\n> 4. 在每一组最前面添加两个00补全成八位,使得24位变成32位刚好凑成4个字节。\n> 5. 然后计算每个字节所表示的数值(10进制),根据下表查表拼装转换后的字符形成最后base64字符。\n\n|    数值    | 符号   | 数值 | 符号 | 数值 | 符号 | 数值 | 符号 |\n|:---------:|:-----:|:-----:| :-----:|:-----:| :-----:|:-----:| :-----:|\n| 0 | A | 17 | R | 34 | i | 51 | z |\n| 1 | B | 18 | S | 35 | j | 52 | 0 |\n| 2 | C | 18 | T | 36 | k | 53 | 1 |\n| 3 | D | 20 | U | 37 | l | 54 | 2 |\n| 4 | E | 21 | V | 38 | m | 55 | 3 |\n| 5 | F | 22 | W | 39 | n | 56 | 4 |\n| 6 | G | 23 | X | 40 | o | 57 | 5 |\n| 7 | H | 24 | Y | 41 | p | 58 | 6 |\n| 8 | I | 25 | Z | 42 | q | 59 | 7 |\n| 9 | J | 26 | a | 43 | r | 60 | 8 |\n| 10| K | 27 | b | 44 | s | 61 | 9 |\n| 11| L | 28 | c | 45 | t | 62 | + |\n| 12| M | 29 | d | 46 | u | 63 | / |\n| 13| N | 30 | e | 47 | v |    |   |\n| 14| O | 31 | f | 48 | w |    |   |　　\n| 15| P | 32 | g | 49 | x |    |   |\n| 16| Q | 33 | h | 50 | y |    |   |\n\n在转换的过程中可以发现,并不是所有的带转换字符串最后表示的二进制串所含的字节数都是3的倍数。所以针对这些不到3个字节的情况,会有相应的处理方式。\n1. 最后剩两个字节的情况\n    > 分成三组,前两组最前面加``00``组成两个字节,后面剩下的4位最前面加两个0,最后面加两个0,组成一个字节,最后补上一个``=``构成四个字节。\n2. 最后只剩一个字节的情况\n    > 分成两组,第一组6位最前面添加两位0,后面还剩2位,在最前面添加两个0,然后在最后面添加四个0构成两个字节,补上两个``=``,构成四个字节。(为什么前面要补两个00,这样计算二进制一个字节所表示的数值才能一一映射到64个字符中)\n\n### Unicode\n> Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。但并没有规定具体在计算机中的存储方式。Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）。\n\nUTF-8就是其中的一种实现方式。后面会讲Unicode的编码方式如何转换成UTF-8实现方式的。Unicode有17个code plane,其中0x0000 ~ 0xffff 称为基本多语言平面,0x10000 ~ 0x10ffff 16个为辅助平面。其中基本多语言平面已经涵盖了大部分常用字，如大部分的汉字,所以只需要对这个范围进行处理已经够用。[参考Unicode字符平面映射](https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84)\n\n### UTF-8 和 Unicode之间的转换关系 \n首先,UTF-8是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码,是在互联网上使用最广的一种Unicode的实现方式。特点就是一种变长的编码方式,可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。\n> 1. 128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。\n> 2. 带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。\n> 3. 其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。\n> 4. 其他极少使用的Unicode 辅助平面的字符使用四字节编码\n\n具体的转换对应关系如下表:\n\n| code point | UTF-8字节流 | \n|:---------:|---------:|\n| U+00000000 – U+0000007F | 0xxxxxxx |\n| U+00000080 – U+000007FF | 110xxxxx 10xxxxxx |\n| U+00000800 – U+0000FFFF | 1110xxxx 10xxxxxx 10xxxxxx |\n| U+00010000 – U+001FFFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |\n\n由上表可见,转换后的字节数由第一个字节二进制串从左到右1的位数决定,``0``表示一个字节,``110``表示两个字节,``1110``对应三个字节,``11110``四个字节,后续字节都以``10``开始。根据这个规律我们就可以在代码实现上进行对Unicode和UTF-8之间进行转换。\n\n### JavaScript内部使用的编码方式\n> JavaScript 引擎内部是自由的使用 UCS-2 或者 UTF-16。大多数引擎使用的是 UTF-16，无论它们使用什么方式实现，它只是一个具体的实现，这不会影响到语言的特性。然后对于 ECMAScript/JavaScript 语言本身，实现的效果是通过 UCS-2，而非 UTF-16。[参考:JavaScript 的内部字符编码是 UCS-2 还是 UTF-16](https://www.w3ctech.com/topic/1869)\n\n所以对于JavaScript,无论是UCS-2还是UTF-16都是一样,采用的是两个字节来存储字符。\n\n>ECMAScript source text is represented as a sequence of characters in the Unicode character encoding,version 3.0 or later. ... ... ECMAScript source text is assumed to be a sequence of 16-bit code units for the purposes of this specification. Such a source text may include sequences of 16-bit code units that are not valid UTF-16 character encodings. If an actual source text is encoded in a form other than 16-bit code units it must be processed as if it was first converted to UTF-16. [参考:ECMA-262 5.1 Edition](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf)\n\n为了在加密解密中文字符不出现乱码,所以需要在将中文字符编码成``base64``之前,先将``UCS-2/UTF-16`` 转换成 ``UTF-8`` (这里只考虑中文字符是UTF-8的情况),然后再应用``base64``编码规则进行编码得到最终结果。同样在解码的时候需要按照``base64``编码规则反向操作转成``UTF-8``格式,然后再将UTF-8转回成``UCS-2/UTF-16``。\n\n### UTF-8 和 JavaScript 内部编码互相转换实现。\n首先,了解JavaScript中几个方法``String.charCodeAt``,``String.fromCharCode()``,``Number.prototype.toString``。\n* [String.charCodeAt](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt)\n  > charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 > 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。\n  \n  ```javascript\n  '中'.charCodeAt(0);\n  20013\n  ```\n* [String.fromCharCode](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode)\n  > charCodeAt的反向操作\n  \n  ```javascript\n  String.fromCharCode(20013);\n  \"中\"\n  ```\n* [Number.prototype.toString](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)\n  > 将十进制码点转换成2进制。\n  \n  ```javascript\n  var code = 20013;\n  code.toString(2);\n  \"100111000101101\"\n  ```\n互相转换源代码如下:\n* UTF-16 -> UTF-8\n  ```javascript\n  const Base64 = {\n      ...,\n       _utf8_encode: function(str) {\n          // 将换行符统一成\\n\n          str = str.replace(/\\r\\n/g, \"\\n\");\n          let out = \"\";\n          for (var n = 0; n < str.length; n++) {\n            let unicode = str.charCodeAt(n);\n            if ((unicode >= 0x0001) && (unicode <= 0x007f)) {\n              //在这个范围内的是ASCII字符,只需一个字节。\n              out += str.charAt(n);\n            } else if (unicode > 0x07ff) {\n              //将16位unicode前四位和1110xxxx 进行拼接\n              out += String.fromCharCode(0xe0 | ((unicode >> 12) & 0x0f));\n              //将接下来的6位和10xxxxxx进行拼接\n              out += String.fromCharCode(0x80 | ((unicode >>  6) & 0x3f));\n              //将接下来的6位和10xxxxxx进行拼接\n              out += String.fromCharCode(0x80 | ((unicode >>  0) & 0x3f));\n            } else {\n              //将16位unicode前5位和110xxxxx 进行拼接\n              out += String.fromCharCode(0xc0 | ((unicode >>  6) & 0x1f));\n              //将接下来的6位和10xxxxxx进行拼接\n              out += String.fromCharCode(0x80 | ((unicode >>  0) & 0x3f));\n            }\n          }\n          return out;\n        },\n      ...\n  }\n  ```\n* UTF8 -> UTF-16\n  ```javascript\n  const Base64 = {\n    ...,\n     _utf8_decode: function(str) {\n        let out = \"\",n = 0, c1,c2,c3;\n        c1 = c2 = c3 = 0;\n        while (n < str.length) {\n          c1 = str.charCodeAt(n);\n          if (c1 < 0x80) {\n            //编码为0xxxxxxx 表示utf8 一个字节\n            out += String.fromCharCode(c1);\n            n++\n          } else if (c1 > 0xc0 && c1 < 0xe0) {\n            //编码为110xxxxx 10xxxxxx 表示2个字节\n            c2 = str.charCodeAt(n + 1);\n            out += String.fromCharCode((c1 & 0x1f) << 6 | c2 & 0x3f);\n            n += 2\n          } else {\n            //编码为1110xxxx 10xxxxxx 0xxxxxxx 表示utf8 三个字节\n            c2 = str.charCodeAt(n + 1);\n            c3 = str.charCodeAt(n + 2);\n            out += String.fromCharCode((c1 & 0x0f) << 12 | (c2 & 0x3f) << 6 | c3 & 0x3f);\n            n += 3\n          }\n        }\n        return out\n      },\n    ...\n  }\n  ```\n  \n### base64编码和解码的实现\n* base64编码 \n  ```javascript\n  const Base64 = {\n    ...,\n    //base64 所用的64个字符和其中的一个补位符'='\n    _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    encode: function(str) {\n      //base64转换算法就是根据具体的规则将3个字符变成四个字符。\n      let out = \"\",c1,c2,c3,\n        outC1,outC2,outC3,outC4,i = 0;\n      str = Base64._utf8_encode(str); //将utf16 转换成utf8,因为JavaScript内部采用的是utf16存储所以要进行一步转换。\n      while (i < str.length) {\n        // 三个三个字符一组进行转换\n        c1 = str.charCodeAt(i++);\n        c2 = str.charCodeAt(i++);\n        c3 = str.charCodeAt(i++);\n        outC1 = c1 >> 2; //第一个字符最前面添加两个0,剩余2位用作后面拼接\n        outC2 = (c1 & 0x03) << 4 | c2 >> 4; // 第一个字符剩下两位和第二个字符前四位拼接,并在前面添加2个0拼成一个字符\n        outC3 = (c2 & 0x0f) << 2 | c3 >> 6; //第二个字符剩余4位和第三个字符的前两位,并在前面添加2个0拼接成一个字符\n        outC4 = c3 & 0x3f; //第三个字符剩下的6位前面添加两个0 拼接成一个字符\n        //如果c2为不存在则最后两个字符为补位符'=' 如果c3不存在 则转换后最后一位为补位'='\n        if (isNaN(c2)) { outC3 = outC4 = 64 } else if (isNaN(c3)) { outC4 = 64 }\n        out = out + this._keyStr.charAt(outC1) + this._keyStr.charAt(outC2) + this._keyStr.charAt(outC3) + this._keyStr.charAt(outC4)\n      }\n      return out\n    },\n    ...\n  }\n  ```\n* base64 解码\n  ```javascript\n  const Base64 = {\n      ...,\n      decode: function(str) {\n          let out = '',c1,c2,c3,c4,outC1,outC2,outC3,i = 0;\n          //去掉非base64字符\n          str = str.replace(/[^A-Za-z0-9+/=]/g, \"\");\n          //循环处理进行解码\n          while (i < str.length) {\n            //4个base64字符一组,解码后将转换成3个字符\n            c1 = this._keyStr.indexOf(str.charAt(i++));\n            c2 = this._keyStr.indexOf(str.charAt(i++));\n            c3 = this._keyStr.indexOf(str.charAt(i++));\n            c4 = this._keyStr.indexOf(str.charAt(i++));\n            //每个字符前面都会有两个前导0\n            outC1 = c1 << 2 | c2 >> 4; //第一个base64字符去掉两个0后和第二个字符的开头两个字符拼成一个字节\n            outC2 = (c2 & 0x0f) << 4 | c3 >> 2; //第二个剩下的4位和第三个开始的四位拼成一个字节\n            outC3 = (c3 & 0x03) << 6 | c4; // 第三个剩下的2位和第四个6位拼成一个字节\n            out = out + String.fromCharCode(outC1);\n            //如果倒数第二个不是补位符'='\n            if (c3 != 64) { out = out + String.fromCharCode(outC2) }\n            //如果倒数第一个不是补位符'='\n            if (c4 != 64) { out = out + String.fromCharCode(outC3) }\n          }\n          out = Base64._utf8_decode(out); // 将utf8转成utf16\n          return out\n        },\n      ...\n  }\n  ```\n\n### Update: 2017-03-15\n  \n根据[rfc3548](https://tools.ietf.org/html/rfc3548#page-6),base64中的某些字符,在一些文件系统环境下或者url中会有特殊的含义,比如斜杠,所以为了得到web safe 的base64编码,则需要将第62个字符和第63个字符(编号从0开始)替换成 ``-``(minus) 和 ``_``(underscore) 减号和下划线。\n可以对编码后的base64进行字符替换如下 :\n\n```javascript\nfunction urlSafeBase64Encode(input) {\n    return input.replace('+', '-').replace('/', '_');\n}\n```\n  \n### [完整代码](https://github.com/xdimh/jsTools/blob/master/base64_with_comment.js)\n\n### 参考资料\n\n1. [维基百科UTF-8](https://zh.wikipedia.org/wiki/UTF-8)\n2. [维基百科Unicode](https://zh.wikipedia.org/wiki/Unicode)\n3. [字符编码笔记：ASCII，Unicode和UTF-8 —— 阮一峰](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)\n4. [Base64笔记 —— 阮一峰](http://www.ruanyifeng.com/blog/2008/06/base64.html)\n5. [Unicode与JavaScript详解 —— 阮一峰](http://www.ruanyifeng.com/blog/2014/12/unicode.html)\n6. [Unicode编码及其实现：UTF-16、UTF-8，and more](http://blog.csdn.net/thl789/article/details/7506133)\n7. [通过javascript进行UTF-8编码](https://segmentfault.com/a/1190000005794963)\n8. [按位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)","slug":"base64","published":1,"updated":"2017-05-03T05:53:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhpl0005b37qgqylbrko","content":"<p>base64编码在各种编码中应该算是比较简单的一种了,在前端中很多地方有被应用到,小图片base64后内联,与客户端交互的jsBridge中数据的base64编码传输,小程序中字体图标base64后内联等等。这次在项目中用到了base64的编码和解码,网上搜了一把有很多base64操作的js实现,之前一直对base64编码半知半解,看着代码中的各种位操作也是云里雾里,所以借这次项目机会稍微深入的了解了下base64这个东西。</p>\n<h3 id=\"什么是base64编码\"><a href=\"#什么是base64编码\" class=\"headerlink\" title=\"什么是base64编码?\"></a>什么是base64编码?</h3><p>对于base64 我们首先需要先看下ASCII编码,想必大家都知道在计算机内部所有的信息数据都表现为二进制的形式,就是那些0101数字串,每一个二进制位(bit)有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到1111111。ASCII码就是用后7位二进制表示了128个字符,这对英语来说是够用了,所需要的字母都能在这后7位中表现出来。那么base64编码的规则又是什么,base64就是选出64个字符作为一个基本的字符集,然后在将其他文字符号都转换成这个字符集中的字符以予表示。这64个字符分别是<code>a-z</code>,<code>A-Z</code> ,<code>0-9</code>,符号<code>+</code>、<code>-</code>,除了前面几位还有<code>=</code>占位符,不属于所表示的内容。</p>\n<h3 id=\"字符base64编码的几个步骤\"><a href=\"#字符base64编码的几个步骤\" class=\"headerlink\" title=\"字符base64编码的几个步骤\"></a>字符base64编码的几个步骤</h3><blockquote>\n<ol>\n<li>将待转换的字符串用二进制的形式表示出来。<br></li>\n<li>然后每三个字节一组,也就是24个二进制位分成一组。</li>\n<li>再将这24个二进制位分成6组,每四个一组,每组6位二进制位。</li>\n<li>在每一组最前面添加两个00补全成八位,使得24位变成32位刚好凑成4个字节。</li>\n<li>然后计算每个字节所表示的数值(10进制),根据下表查表拼装转换后的字符形成最后base64字符。</li>\n</ol>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数值</th>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:center\">数值</th>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:center\">数值</th>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:center\">数值</th>\n<th style=\"text-align:center\">符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">R</td>\n<td style=\"text-align:center\">34</td>\n<td style=\"text-align:center\">i</td>\n<td style=\"text-align:center\">51</td>\n<td style=\"text-align:center\">z</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">S</td>\n<td style=\"text-align:center\">35</td>\n<td style=\"text-align:center\">j</td>\n<td style=\"text-align:center\">52</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">T</td>\n<td style=\"text-align:center\">36</td>\n<td style=\"text-align:center\">k</td>\n<td style=\"text-align:center\">53</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">U</td>\n<td style=\"text-align:center\">37</td>\n<td style=\"text-align:center\">l</td>\n<td style=\"text-align:center\">54</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">V</td>\n<td style=\"text-align:center\">38</td>\n<td style=\"text-align:center\">m</td>\n<td style=\"text-align:center\">55</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">W</td>\n<td style=\"text-align:center\">39</td>\n<td style=\"text-align:center\">n</td>\n<td style=\"text-align:center\">56</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">X</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">o</td>\n<td style=\"text-align:center\">57</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">H</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">41</td>\n<td style=\"text-align:center\">p</td>\n<td style=\"text-align:center\">58</td>\n<td style=\"text-align:center\">6</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">I</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">Z</td>\n<td style=\"text-align:center\">42</td>\n<td style=\"text-align:center\">q</td>\n<td style=\"text-align:center\">59</td>\n<td style=\"text-align:center\">7</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">J</td>\n<td style=\"text-align:center\">26</td>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">43</td>\n<td style=\"text-align:center\">r</td>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">K</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">b</td>\n<td style=\"text-align:center\">44</td>\n<td style=\"text-align:center\">s</td>\n<td style=\"text-align:center\">61</td>\n<td style=\"text-align:center\">9</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">L</td>\n<td style=\"text-align:center\">28</td>\n<td style=\"text-align:center\">c</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">t</td>\n<td style=\"text-align:center\">62</td>\n<td style=\"text-align:center\">+</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">M</td>\n<td style=\"text-align:center\">29</td>\n<td style=\"text-align:center\">d</td>\n<td style=\"text-align:center\">46</td>\n<td style=\"text-align:center\">u</td>\n<td style=\"text-align:center\">63</td>\n<td style=\"text-align:center\">/</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">e</td>\n<td style=\"text-align:center\">47</td>\n<td style=\"text-align:center\">v</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">O</td>\n<td style=\"text-align:center\">31</td>\n<td style=\"text-align:center\">f</td>\n<td style=\"text-align:center\">48</td>\n<td style=\"text-align:center\">w</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td>　　</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">P</td>\n<td style=\"text-align:center\">32</td>\n<td style=\"text-align:center\">g</td>\n<td style=\"text-align:center\">49</td>\n<td style=\"text-align:center\">x</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">Q</td>\n<td style=\"text-align:center\">33</td>\n<td style=\"text-align:center\">h</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<p>在转换的过程中可以发现,并不是所有的带转换字符串最后表示的二进制串所含的字节数都是3的倍数。所以针对这些不到3个字节的情况,会有相应的处理方式。</p>\n<ol>\n<li>最后剩两个字节的情况<blockquote>\n<p>分成三组,前两组最前面加<code>00</code>组成两个字节,后面剩下的4位最前面加两个0,最后面加两个0,组成一个字节,最后补上一个<code>=</code>构成四个字节。</p>\n</blockquote>\n</li>\n<li>最后只剩一个字节的情况<blockquote>\n<p>分成两组,第一组6位最前面添加两位0,后面还剩2位,在最前面添加两个0,然后在最后面添加四个0构成两个字节,补上两个<code>=</code>,构成四个字节。(为什么前面要补两个00,这样计算二进制一个字节所表示的数值才能一一映射到64个字符中)</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><blockquote>\n<p>Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。但并没有规定具体在计算机中的存储方式。Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）。</p>\n</blockquote>\n<p>UTF-8就是其中的一种实现方式。后面会讲Unicode的编码方式如何转换成UTF-8实现方式的。Unicode有17个code plane,其中0x0000 ~ 0xffff 称为基本多语言平面,0x10000 ~ 0x10ffff 16个为辅助平面。其中基本多语言平面已经涵盖了大部分常用字，如大部分的汉字,所以只需要对这个范围进行处理已经够用。<a href=\"https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84\" target=\"_blank\" rel=\"external\">参考Unicode字符平面映射</a></p>\n<h3 id=\"UTF-8-和-Unicode之间的转换关系\"><a href=\"#UTF-8-和-Unicode之间的转换关系\" class=\"headerlink\" title=\"UTF-8 和 Unicode之间的转换关系\"></a>UTF-8 和 Unicode之间的转换关系</h3><p>首先,UTF-8是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码,是在互联网上使用最广的一种Unicode的实现方式。特点就是一种变长的编码方式,可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<blockquote>\n<ol>\n<li>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。</li>\n<li>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。</li>\n<li>其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。</li>\n<li>其他极少使用的Unicode 辅助平面的字符使用四字节编码</li>\n</ol>\n</blockquote>\n<p>具体的转换对应关系如下表:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">code point</th>\n<th style=\"text-align:right\">UTF-8字节流</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">U+00000000 – U+0000007F</td>\n<td style=\"text-align:right\">0xxxxxxx</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+00000080 – U+000007FF</td>\n<td style=\"text-align:right\">110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+00000800 – U+0000FFFF</td>\n<td style=\"text-align:right\">1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+00010000 – U+001FFFFF</td>\n<td style=\"text-align:right\">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n<p>由上表可见,转换后的字节数由第一个字节二进制串从左到右1的位数决定,<code>0</code>表示一个字节,<code>110</code>表示两个字节,<code>1110</code>对应三个字节,<code>11110</code>四个字节,后续字节都以<code>10</code>开始。根据这个规律我们就可以在代码实现上进行对Unicode和UTF-8之间进行转换。</p>\n<h3 id=\"JavaScript内部使用的编码方式\"><a href=\"#JavaScript内部使用的编码方式\" class=\"headerlink\" title=\"JavaScript内部使用的编码方式\"></a>JavaScript内部使用的编码方式</h3><blockquote>\n<p>JavaScript 引擎内部是自由的使用 UCS-2 或者 UTF-16。大多数引擎使用的是 UTF-16，无论它们使用什么方式实现，它只是一个具体的实现，这不会影响到语言的特性。然后对于 ECMAScript/JavaScript 语言本身，实现的效果是通过 UCS-2，而非 UTF-16。<a href=\"https://www.w3ctech.com/topic/1869\" target=\"_blank\" rel=\"external\">参考:JavaScript 的内部字符编码是 UCS-2 还是 UTF-16</a></p>\n</blockquote>\n<p>所以对于JavaScript,无论是UCS-2还是UTF-16都是一样,采用的是两个字节来存储字符。</p>\n<blockquote>\n<p>ECMAScript source text is represented as a sequence of characters in the Unicode character encoding,version 3.0 or later. … … ECMAScript source text is assumed to be a sequence of 16-bit code units for the purposes of this specification. Such a source text may include sequences of 16-bit code units that are not valid UTF-16 character encodings. If an actual source text is encoded in a form other than 16-bit code units it must be processed as if it was first converted to UTF-16. <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\" target=\"_blank\" rel=\"external\">参考:ECMA-262 5.1 Edition</a></p>\n</blockquote>\n<p>为了在加密解密中文字符不出现乱码,所以需要在将中文字符编码成<code>base64</code>之前,先将<code>UCS-2/UTF-16</code> 转换成 <code>UTF-8</code> (这里只考虑中文字符是UTF-8的情况),然后再应用<code>base64</code>编码规则进行编码得到最终结果。同样在解码的时候需要按照<code>base64</code>编码规则反向操作转成<code>UTF-8</code>格式,然后再将UTF-8转回成<code>UCS-2/UTF-16</code>。</p>\n<h3 id=\"UTF-8-和-JavaScript-内部编码互相转换实现。\"><a href=\"#UTF-8-和-JavaScript-内部编码互相转换实现。\" class=\"headerlink\" title=\"UTF-8 和 JavaScript 内部编码互相转换实现。\"></a>UTF-8 和 JavaScript 内部编码互相转换实现。</h3><p>首先,了解JavaScript中几个方法<code>String.charCodeAt</code>,<code>String.fromCharCode()</code>,<code>Number.prototype.toString</code>。</p>\n<ul>\n<li><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt\" target=\"_blank\" rel=\"external\">String.charCodeAt</a></p>\n<blockquote>\n<p>charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 &gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'中'</span>.charCodeAt(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">20013</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode\" target=\"_blank\" rel=\"external\">String.fromCharCode</a></p>\n<blockquote>\n<p>charCodeAt的反向操作</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">20013</span>);</div><div class=\"line\"><span class=\"string\">\"中\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString\" target=\"_blank\" rel=\"external\">Number.prototype.toString</a></p>\n<blockquote>\n<p>将十进制码点转换成2进制。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> code = <span class=\"number\">20013</span>;</div><div class=\"line\">code.toString(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"string\">\"100111000101101\"</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>互相转换源代码如下:</p>\n<ul>\n<li><p>UTF-16 -&gt; UTF-8</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Base64 = &#123;</div><div class=\"line\">    ...,</div><div class=\"line\">     <span class=\"attr\">_utf8_encode</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 将换行符统一成\\n</span></div><div class=\"line\">        str = str.replace(<span class=\"regexp\">/\\r\\n/g</span>, <span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">let</span> out = <span class=\"string\">\"\"</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> n = <span class=\"number\">0</span>; n &lt; str.length; n++) &#123;</div><div class=\"line\">          <span class=\"keyword\">let</span> unicode = str.charCodeAt(n);</div><div class=\"line\">          <span class=\"keyword\">if</span> ((unicode &gt;= <span class=\"number\">0x0001</span>) &amp;&amp; (unicode &lt;= <span class=\"number\">0x007f</span>)) &#123;</div><div class=\"line\">            <span class=\"comment\">//在这个范围内的是ASCII字符,只需一个字节。</span></div><div class=\"line\">            out += str.charAt(n);</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (unicode &gt; <span class=\"number\">0x07ff</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//将16位unicode前四位和1110xxxx 进行拼接</span></div><div class=\"line\">            out += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0xe0</span> | ((unicode &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x0f</span>));</div><div class=\"line\">            <span class=\"comment\">//将接下来的6位和10xxxxxx进行拼接</span></div><div class=\"line\">            out += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x80</span> | ((unicode &gt;&gt;  <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>));</div><div class=\"line\">            <span class=\"comment\">//将接下来的6位和10xxxxxx进行拼接</span></div><div class=\"line\">            out += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x80</span> | ((unicode &gt;&gt;  <span class=\"number\">0</span>) &amp; <span class=\"number\">0x3f</span>));</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//将16位unicode前5位和110xxxxx 进行拼接</span></div><div class=\"line\">            out += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0xc0</span> | ((unicode &gt;&gt;  <span class=\"number\">6</span>) &amp; <span class=\"number\">0x1f</span>));</div><div class=\"line\">            <span class=\"comment\">//将接下来的6位和10xxxxxx进行拼接</span></div><div class=\"line\">            out += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x80</span> | ((unicode &gt;&gt;  <span class=\"number\">0</span>) &amp; <span class=\"number\">0x3f</span>));</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> out;</div><div class=\"line\">      &#125;,</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>UTF8 -&gt; UTF-16</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Base64 = &#123;</div><div class=\"line\">  ...,</div><div class=\"line\">   <span class=\"attr\">_utf8_decode</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> out = <span class=\"string\">\"\"</span>,n = <span class=\"number\">0</span>, c1,c2,c3;</div><div class=\"line\">      c1 = c2 = c3 = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span> (n &lt; str.length) &#123;</div><div class=\"line\">        c1 = str.charCodeAt(n);</div><div class=\"line\">        <span class=\"keyword\">if</span> (c1 &lt; <span class=\"number\">0x80</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">//编码为0xxxxxxx 表示utf8 一个字节</span></div><div class=\"line\">          out += <span class=\"built_in\">String</span>.fromCharCode(c1);</div><div class=\"line\">          n++</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c1 &gt; <span class=\"number\">0xc0</span> &amp;&amp; c1 &lt; <span class=\"number\">0xe0</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">//编码为110xxxxx 10xxxxxx 表示2个字节</span></div><div class=\"line\">          c2 = str.charCodeAt(n + <span class=\"number\">1</span>);</div><div class=\"line\">          out += <span class=\"built_in\">String</span>.fromCharCode((c1 &amp; <span class=\"number\">0x1f</span>) &lt;&lt; <span class=\"number\">6</span> | c2 &amp; <span class=\"number\">0x3f</span>);</div><div class=\"line\">          n += <span class=\"number\">2</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">//编码为1110xxxx 10xxxxxx 0xxxxxxx 表示utf8 三个字节</span></div><div class=\"line\">          c2 = str.charCodeAt(n + <span class=\"number\">1</span>);</div><div class=\"line\">          c3 = str.charCodeAt(n + <span class=\"number\">2</span>);</div><div class=\"line\">          out += <span class=\"built_in\">String</span>.fromCharCode((c1 &amp; <span class=\"number\">0x0f</span>) &lt;&lt; <span class=\"number\">12</span> | (c2 &amp; <span class=\"number\">0x3f</span>) &lt;&lt; <span class=\"number\">6</span> | c3 &amp; <span class=\"number\">0x3f</span>);</div><div class=\"line\">          n += <span class=\"number\">3</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> out</div><div class=\"line\">    &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"base64编码和解码的实现\"><a href=\"#base64编码和解码的实现\" class=\"headerlink\" title=\"base64编码和解码的实现\"></a>base64编码和解码的实现</h3><ul>\n<li><p>base64编码 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Base64 = &#123;</div><div class=\"line\">  ...,</div><div class=\"line\">  <span class=\"comment\">//base64 所用的64个字符和其中的一个补位符'='</span></div><div class=\"line\">  _keyStr: <span class=\"string\">\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"</span>,</div><div class=\"line\">  <span class=\"attr\">encode</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//base64转换算法就是根据具体的规则将3个字符变成四个字符。</span></div><div class=\"line\">    <span class=\"keyword\">let</span> out = <span class=\"string\">\"\"</span>,c1,c2,c3,</div><div class=\"line\">      outC1,outC2,outC3,outC4,i = <span class=\"number\">0</span>;</div><div class=\"line\">    str = Base64._utf8_encode(str); <span class=\"comment\">//将utf16 转换成utf8,因为JavaScript内部采用的是utf16存储所以要进行一步转换。</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (i &lt; str.length) &#123;</div><div class=\"line\">      <span class=\"comment\">// 三个三个字符一组进行转换</span></div><div class=\"line\">      c1 = str.charCodeAt(i++);</div><div class=\"line\">      c2 = str.charCodeAt(i++);</div><div class=\"line\">      c3 = str.charCodeAt(i++);</div><div class=\"line\">      outC1 = c1 &gt;&gt; <span class=\"number\">2</span>; <span class=\"comment\">//第一个字符最前面添加两个0,剩余2位用作后面拼接</span></div><div class=\"line\">      outC2 = (c1 &amp; <span class=\"number\">0x03</span>) &lt;&lt; <span class=\"number\">4</span> | c2 &gt;&gt; <span class=\"number\">4</span>; <span class=\"comment\">// 第一个字符剩下两位和第二个字符前四位拼接,并在前面添加2个0拼成一个字符</span></div><div class=\"line\">      outC3 = (c2 &amp; <span class=\"number\">0x0f</span>) &lt;&lt; <span class=\"number\">2</span> | c3 &gt;&gt; <span class=\"number\">6</span>; <span class=\"comment\">//第二个字符剩余4位和第三个字符的前两位,并在前面添加2个0拼接成一个字符</span></div><div class=\"line\">      outC4 = c3 &amp; <span class=\"number\">0x3f</span>; <span class=\"comment\">//第三个字符剩下的6位前面添加两个0 拼接成一个字符</span></div><div class=\"line\">      <span class=\"comment\">//如果c2为不存在则最后两个字符为补位符'=' 如果c3不存在 则转换后最后一位为补位'='</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">isNaN</span>(c2)) &#123; outC3 = outC4 = <span class=\"number\">64</span> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">isNaN</span>(c3)) &#123; outC4 = <span class=\"number\">64</span> &#125;</div><div class=\"line\">      out = out + <span class=\"keyword\">this</span>._keyStr.charAt(outC1) + <span class=\"keyword\">this</span>._keyStr.charAt(outC2) + <span class=\"keyword\">this</span>._keyStr.charAt(outC3) + <span class=\"keyword\">this</span>._keyStr.charAt(outC4)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> out</div><div class=\"line\">  &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>base64 解码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Base64 = &#123;</div><div class=\"line\">    ...,</div><div class=\"line\">    <span class=\"attr\">decode</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> out = <span class=\"string\">''</span>,c1,c2,c3,c4,outC1,outC2,outC3,i = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">//去掉非base64字符</span></div><div class=\"line\">        str = str.replace(<span class=\"regexp\">/[^A-Za-z0-9+/=]/g</span>, <span class=\"string\">\"\"</span>);</div><div class=\"line\">        <span class=\"comment\">//循环处理进行解码</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (i &lt; str.length) &#123;</div><div class=\"line\">          <span class=\"comment\">//4个base64字符一组,解码后将转换成3个字符</span></div><div class=\"line\">          c1 = <span class=\"keyword\">this</span>._keyStr.indexOf(str.charAt(i++));</div><div class=\"line\">          c2 = <span class=\"keyword\">this</span>._keyStr.indexOf(str.charAt(i++));</div><div class=\"line\">          c3 = <span class=\"keyword\">this</span>._keyStr.indexOf(str.charAt(i++));</div><div class=\"line\">          c4 = <span class=\"keyword\">this</span>._keyStr.indexOf(str.charAt(i++));</div><div class=\"line\">          <span class=\"comment\">//每个字符前面都会有两个前导0</span></div><div class=\"line\">          outC1 = c1 &lt;&lt; <span class=\"number\">2</span> | c2 &gt;&gt; <span class=\"number\">4</span>; <span class=\"comment\">//第一个base64字符去掉两个0后和第二个字符的开头两个字符拼成一个字节</span></div><div class=\"line\">          outC2 = (c2 &amp; <span class=\"number\">0x0f</span>) &lt;&lt; <span class=\"number\">4</span> | c3 &gt;&gt; <span class=\"number\">2</span>; <span class=\"comment\">//第二个剩下的4位和第三个开始的四位拼成一个字节</span></div><div class=\"line\">          outC3 = (c3 &amp; <span class=\"number\">0x03</span>) &lt;&lt; <span class=\"number\">6</span> | c4; <span class=\"comment\">// 第三个剩下的2位和第四个6位拼成一个字节</span></div><div class=\"line\">          out = out + <span class=\"built_in\">String</span>.fromCharCode(outC1);</div><div class=\"line\">          <span class=\"comment\">//如果倒数第二个不是补位符'='</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (c3 != <span class=\"number\">64</span>) &#123; out = out + <span class=\"built_in\">String</span>.fromCharCode(outC2) &#125;</div><div class=\"line\">          <span class=\"comment\">//如果倒数第一个不是补位符'='</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (c4 != <span class=\"number\">64</span>) &#123; out = out + <span class=\"built_in\">String</span>.fromCharCode(outC3) &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        out = Base64._utf8_decode(out); <span class=\"comment\">// 将utf8转成utf16</span></div><div class=\"line\">        <span class=\"keyword\">return</span> out</div><div class=\"line\">      &#125;,</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Update-2017-03-15\"><a href=\"#Update-2017-03-15\" class=\"headerlink\" title=\"Update: 2017-03-15\"></a>Update: 2017-03-15</h3><p>根据<a href=\"https://tools.ietf.org/html/rfc3548#page-6\" target=\"_blank\" rel=\"external\">rfc3548</a>,base64中的某些字符,在一些文件系统环境下或者url中会有特殊的含义,比如斜杠,所以为了得到web safe 的base64编码,则需要将第62个字符和第63个字符(编号从0开始)替换成 <code>-</code>(minus) 和 <code>_</code>(underscore) 减号和下划线。<br>可以对编码后的base64进行字符替换如下 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">urlSafeBase64Encode</span>(<span class=\"params\">input</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> input.replace(<span class=\"string\">'+'</span>, <span class=\"string\">'-'</span>).replace(<span class=\"string\">'/'</span>, <span class=\"string\">'_'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a><a href=\"https://github.com/xdimh/jsTools/blob/master/base64_with_comment.js\" target=\"_blank\" rel=\"external\">完整代码</a></h3><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/UTF-8\" target=\"_blank\" rel=\"external\">维基百科UTF-8</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Unicode\" target=\"_blank\" rel=\"external\">维基百科Unicode</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"external\">字符编码笔记：ASCII，Unicode和UTF-8 —— 阮一峰</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2008/06/base64.html\" target=\"_blank\" rel=\"external\">Base64笔记 —— 阮一峰</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/12/unicode.html\" target=\"_blank\" rel=\"external\">Unicode与JavaScript详解 —— 阮一峰</a></li>\n<li><a href=\"http://blog.csdn.net/thl789/article/details/7506133\" target=\"_blank\" rel=\"external\">Unicode编码及其实现：UTF-16、UTF-8，and more</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000005794963\" target=\"_blank\" rel=\"external\">通过javascript进行UTF-8编码</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" target=\"_blank\" rel=\"external\">按位操作符</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>base64编码在各种编码中应该算是比较简单的一种了,在前端中很多地方有被应用到,小图片base64后内联,与客户端交互的jsBridge中数据的base64编码传输,小程序中字体图标base64后内联等等。这次在项目中用到了base64的编码和解码,网上搜了一把有很多base64操作的js实现,之前一直对base64编码半知半解,看着代码中的各种位操作也是云里雾里,所以借这次项目机会稍微深入的了解了下base64这个东西。</p>\n<h3 id=\"什么是base64编码\"><a href=\"#什么是base64编码\" class=\"headerlink\" title=\"什么是base64编码?\"></a>什么是base64编码?</h3><p>对于base64 我们首先需要先看下ASCII编码,想必大家都知道在计算机内部所有的信息数据都表现为二进制的形式,就是那些0101数字串,每一个二进制位(bit)有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到1111111。ASCII码就是用后7位二进制表示了128个字符,这对英语来说是够用了,所需要的字母都能在这后7位中表现出来。那么base64编码的规则又是什么,base64就是选出64个字符作为一个基本的字符集,然后在将其他文字符号都转换成这个字符集中的字符以予表示。这64个字符分别是<code>a-z</code>,<code>A-Z</code> ,<code>0-9</code>,符号<code>+</code>、<code>-</code>,除了前面几位还有<code>=</code>占位符,不属于所表示的内容。</p>\n<h3 id=\"字符base64编码的几个步骤\"><a href=\"#字符base64编码的几个步骤\" class=\"headerlink\" title=\"字符base64编码的几个步骤\"></a>字符base64编码的几个步骤</h3><blockquote>\n<ol>\n<li>将待转换的字符串用二进制的形式表示出来。<br></li>\n<li>然后每三个字节一组,也就是24个二进制位分成一组。</li>\n<li>再将这24个二进制位分成6组,每四个一组,每组6位二进制位。</li>\n<li>在每一组最前面添加两个00补全成八位,使得24位变成32位刚好凑成4个字节。</li>\n<li>然后计算每个字节所表示的数值(10进制),根据下表查表拼装转换后的字符形成最后base64字符。</li>\n</ol>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数值</th>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:center\">数值</th>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:center\">数值</th>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:center\">数值</th>\n<th style=\"text-align:center\">符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:center\">17</td>\n<td style=\"text-align:center\">R</td>\n<td style=\"text-align:center\">34</td>\n<td style=\"text-align:center\">i</td>\n<td style=\"text-align:center\">51</td>\n<td style=\"text-align:center\">z</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">B</td>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">S</td>\n<td style=\"text-align:center\">35</td>\n<td style=\"text-align:center\">j</td>\n<td style=\"text-align:center\">52</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:center\">18</td>\n<td style=\"text-align:center\">T</td>\n<td style=\"text-align:center\">36</td>\n<td style=\"text-align:center\">k</td>\n<td style=\"text-align:center\">53</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">D</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">U</td>\n<td style=\"text-align:center\">37</td>\n<td style=\"text-align:center\">l</td>\n<td style=\"text-align:center\">54</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">E</td>\n<td style=\"text-align:center\">21</td>\n<td style=\"text-align:center\">V</td>\n<td style=\"text-align:center\">38</td>\n<td style=\"text-align:center\">m</td>\n<td style=\"text-align:center\">55</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">F</td>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:center\">W</td>\n<td style=\"text-align:center\">39</td>\n<td style=\"text-align:center\">n</td>\n<td style=\"text-align:center\">56</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">G</td>\n<td style=\"text-align:center\">23</td>\n<td style=\"text-align:center\">X</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">o</td>\n<td style=\"text-align:center\">57</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">H</td>\n<td style=\"text-align:center\">24</td>\n<td style=\"text-align:center\">Y</td>\n<td style=\"text-align:center\">41</td>\n<td style=\"text-align:center\">p</td>\n<td style=\"text-align:center\">58</td>\n<td style=\"text-align:center\">6</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">I</td>\n<td style=\"text-align:center\">25</td>\n<td style=\"text-align:center\">Z</td>\n<td style=\"text-align:center\">42</td>\n<td style=\"text-align:center\">q</td>\n<td style=\"text-align:center\">59</td>\n<td style=\"text-align:center\">7</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">J</td>\n<td style=\"text-align:center\">26</td>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">43</td>\n<td style=\"text-align:center\">r</td>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">K</td>\n<td style=\"text-align:center\">27</td>\n<td style=\"text-align:center\">b</td>\n<td style=\"text-align:center\">44</td>\n<td style=\"text-align:center\">s</td>\n<td style=\"text-align:center\">61</td>\n<td style=\"text-align:center\">9</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">L</td>\n<td style=\"text-align:center\">28</td>\n<td style=\"text-align:center\">c</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">t</td>\n<td style=\"text-align:center\">62</td>\n<td style=\"text-align:center\">+</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:center\">M</td>\n<td style=\"text-align:center\">29</td>\n<td style=\"text-align:center\">d</td>\n<td style=\"text-align:center\">46</td>\n<td style=\"text-align:center\">u</td>\n<td style=\"text-align:center\">63</td>\n<td style=\"text-align:center\">/</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">13</td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">e</td>\n<td style=\"text-align:center\">47</td>\n<td style=\"text-align:center\">v</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">O</td>\n<td style=\"text-align:center\">31</td>\n<td style=\"text-align:center\">f</td>\n<td style=\"text-align:center\">48</td>\n<td style=\"text-align:center\">w</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n<td>　　</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">P</td>\n<td style=\"text-align:center\">32</td>\n<td style=\"text-align:center\">g</td>\n<td style=\"text-align:center\">49</td>\n<td style=\"text-align:center\">x</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">Q</td>\n<td style=\"text-align:center\">33</td>\n<td style=\"text-align:center\">h</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">y</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<p>在转换的过程中可以发现,并不是所有的带转换字符串最后表示的二进制串所含的字节数都是3的倍数。所以针对这些不到3个字节的情况,会有相应的处理方式。</p>\n<ol>\n<li>最后剩两个字节的情况<blockquote>\n<p>分成三组,前两组最前面加<code>00</code>组成两个字节,后面剩下的4位最前面加两个0,最后面加两个0,组成一个字节,最后补上一个<code>=</code>构成四个字节。</p>\n</blockquote>\n</li>\n<li>最后只剩一个字节的情况<blockquote>\n<p>分成两组,第一组6位最前面添加两位0,后面还剩2位,在最前面添加两个0,然后在最后面添加四个0构成两个字节,补上两个<code>=</code>,构成四个字节。(为什么前面要补两个00,这样计算二进制一个字节所表示的数值才能一一映射到64个字符中)</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><blockquote>\n<p>Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。但并没有规定具体在计算机中的存储方式。Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）。</p>\n</blockquote>\n<p>UTF-8就是其中的一种实现方式。后面会讲Unicode的编码方式如何转换成UTF-8实现方式的。Unicode有17个code plane,其中0x0000 ~ 0xffff 称为基本多语言平面,0x10000 ~ 0x10ffff 16个为辅助平面。其中基本多语言平面已经涵盖了大部分常用字，如大部分的汉字,所以只需要对这个范围进行处理已经够用。<a href=\"https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84\" target=\"_blank\" rel=\"external\">参考Unicode字符平面映射</a></p>\n<h3 id=\"UTF-8-和-Unicode之间的转换关系\"><a href=\"#UTF-8-和-Unicode之间的转换关系\" class=\"headerlink\" title=\"UTF-8 和 Unicode之间的转换关系\"></a>UTF-8 和 Unicode之间的转换关系</h3><p>首先,UTF-8是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码,是在互联网上使用最广的一种Unicode的实现方式。特点就是一种变长的编码方式,可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。</p>\n<blockquote>\n<ol>\n<li>128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。</li>\n<li>带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。</li>\n<li>其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。</li>\n<li>其他极少使用的Unicode 辅助平面的字符使用四字节编码</li>\n</ol>\n</blockquote>\n<p>具体的转换对应关系如下表:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">code point</th>\n<th style=\"text-align:right\">UTF-8字节流</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">U+00000000 – U+0000007F</td>\n<td style=\"text-align:right\">0xxxxxxx</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+00000080 – U+000007FF</td>\n<td style=\"text-align:right\">110xxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+00000800 – U+0000FFFF</td>\n<td style=\"text-align:right\">1110xxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">U+00010000 – U+001FFFFF</td>\n<td style=\"text-align:right\">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>\n</tr>\n</tbody>\n</table>\n<p>由上表可见,转换后的字节数由第一个字节二进制串从左到右1的位数决定,<code>0</code>表示一个字节,<code>110</code>表示两个字节,<code>1110</code>对应三个字节,<code>11110</code>四个字节,后续字节都以<code>10</code>开始。根据这个规律我们就可以在代码实现上进行对Unicode和UTF-8之间进行转换。</p>\n<h3 id=\"JavaScript内部使用的编码方式\"><a href=\"#JavaScript内部使用的编码方式\" class=\"headerlink\" title=\"JavaScript内部使用的编码方式\"></a>JavaScript内部使用的编码方式</h3><blockquote>\n<p>JavaScript 引擎内部是自由的使用 UCS-2 或者 UTF-16。大多数引擎使用的是 UTF-16，无论它们使用什么方式实现，它只是一个具体的实现，这不会影响到语言的特性。然后对于 ECMAScript/JavaScript 语言本身，实现的效果是通过 UCS-2，而非 UTF-16。<a href=\"https://www.w3ctech.com/topic/1869\" target=\"_blank\" rel=\"external\">参考:JavaScript 的内部字符编码是 UCS-2 还是 UTF-16</a></p>\n</blockquote>\n<p>所以对于JavaScript,无论是UCS-2还是UTF-16都是一样,采用的是两个字节来存储字符。</p>\n<blockquote>\n<p>ECMAScript source text is represented as a sequence of characters in the Unicode character encoding,version 3.0 or later. … … ECMAScript source text is assumed to be a sequence of 16-bit code units for the purposes of this specification. Such a source text may include sequences of 16-bit code units that are not valid UTF-16 character encodings. If an actual source text is encoded in a form other than 16-bit code units it must be processed as if it was first converted to UTF-16. <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\" target=\"_blank\" rel=\"external\">参考:ECMA-262 5.1 Edition</a></p>\n</blockquote>\n<p>为了在加密解密中文字符不出现乱码,所以需要在将中文字符编码成<code>base64</code>之前,先将<code>UCS-2/UTF-16</code> 转换成 <code>UTF-8</code> (这里只考虑中文字符是UTF-8的情况),然后再应用<code>base64</code>编码规则进行编码得到最终结果。同样在解码的时候需要按照<code>base64</code>编码规则反向操作转成<code>UTF-8</code>格式,然后再将UTF-8转回成<code>UCS-2/UTF-16</code>。</p>\n<h3 id=\"UTF-8-和-JavaScript-内部编码互相转换实现。\"><a href=\"#UTF-8-和-JavaScript-内部编码互相转换实现。\" class=\"headerlink\" title=\"UTF-8 和 JavaScript 内部编码互相转换实现。\"></a>UTF-8 和 JavaScript 内部编码互相转换实现。</h3><p>首先,了解JavaScript中几个方法<code>String.charCodeAt</code>,<code>String.fromCharCode()</code>,<code>Number.prototype.toString</code>。</p>\n<ul>\n<li><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt\" target=\"_blank\" rel=\"external\">String.charCodeAt</a></p>\n<blockquote>\n<p>charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 &gt; 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'中'</span>.charCodeAt(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"number\">20013</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode\" target=\"_blank\" rel=\"external\">String.fromCharCode</a></p>\n<blockquote>\n<p>charCodeAt的反向操作</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">20013</span>);</div><div class=\"line\"><span class=\"string\">\"中\"</span></div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString\" target=\"_blank\" rel=\"external\">Number.prototype.toString</a></p>\n<blockquote>\n<p>将十进制码点转换成2进制。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> code = <span class=\"number\">20013</span>;</div><div class=\"line\">code.toString(<span class=\"number\">2</span>);</div><div class=\"line\"><span class=\"string\">\"100111000101101\"</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>互相转换源代码如下:</p>\n<ul>\n<li><p>UTF-16 -&gt; UTF-8</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Base64 = &#123;</div><div class=\"line\">    ...,</div><div class=\"line\">     <span class=\"attr\">_utf8_encode</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 将换行符统一成\\n</span></div><div class=\"line\">        str = str.replace(<span class=\"regexp\">/\\r\\n/g</span>, <span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">let</span> out = <span class=\"string\">\"\"</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> n = <span class=\"number\">0</span>; n &lt; str.length; n++) &#123;</div><div class=\"line\">          <span class=\"keyword\">let</span> unicode = str.charCodeAt(n);</div><div class=\"line\">          <span class=\"keyword\">if</span> ((unicode &gt;= <span class=\"number\">0x0001</span>) &amp;&amp; (unicode &lt;= <span class=\"number\">0x007f</span>)) &#123;</div><div class=\"line\">            <span class=\"comment\">//在这个范围内的是ASCII字符,只需一个字节。</span></div><div class=\"line\">            out += str.charAt(n);</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (unicode &gt; <span class=\"number\">0x07ff</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//将16位unicode前四位和1110xxxx 进行拼接</span></div><div class=\"line\">            out += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0xe0</span> | ((unicode &gt;&gt; <span class=\"number\">12</span>) &amp; <span class=\"number\">0x0f</span>));</div><div class=\"line\">            <span class=\"comment\">//将接下来的6位和10xxxxxx进行拼接</span></div><div class=\"line\">            out += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x80</span> | ((unicode &gt;&gt;  <span class=\"number\">6</span>) &amp; <span class=\"number\">0x3f</span>));</div><div class=\"line\">            <span class=\"comment\">//将接下来的6位和10xxxxxx进行拼接</span></div><div class=\"line\">            out += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x80</span> | ((unicode &gt;&gt;  <span class=\"number\">0</span>) &amp; <span class=\"number\">0x3f</span>));</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"comment\">//将16位unicode前5位和110xxxxx 进行拼接</span></div><div class=\"line\">            out += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0xc0</span> | ((unicode &gt;&gt;  <span class=\"number\">6</span>) &amp; <span class=\"number\">0x1f</span>));</div><div class=\"line\">            <span class=\"comment\">//将接下来的6位和10xxxxxx进行拼接</span></div><div class=\"line\">            out += <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x80</span> | ((unicode &gt;&gt;  <span class=\"number\">0</span>) &amp; <span class=\"number\">0x3f</span>));</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> out;</div><div class=\"line\">      &#125;,</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>UTF8 -&gt; UTF-16</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Base64 = &#123;</div><div class=\"line\">  ...,</div><div class=\"line\">   <span class=\"attr\">_utf8_decode</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">let</span> out = <span class=\"string\">\"\"</span>,n = <span class=\"number\">0</span>, c1,c2,c3;</div><div class=\"line\">      c1 = c2 = c3 = <span class=\"number\">0</span>;</div><div class=\"line\">      <span class=\"keyword\">while</span> (n &lt; str.length) &#123;</div><div class=\"line\">        c1 = str.charCodeAt(n);</div><div class=\"line\">        <span class=\"keyword\">if</span> (c1 &lt; <span class=\"number\">0x80</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">//编码为0xxxxxxx 表示utf8 一个字节</span></div><div class=\"line\">          out += <span class=\"built_in\">String</span>.fromCharCode(c1);</div><div class=\"line\">          n++</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c1 &gt; <span class=\"number\">0xc0</span> &amp;&amp; c1 &lt; <span class=\"number\">0xe0</span>) &#123;</div><div class=\"line\">          <span class=\"comment\">//编码为110xxxxx 10xxxxxx 表示2个字节</span></div><div class=\"line\">          c2 = str.charCodeAt(n + <span class=\"number\">1</span>);</div><div class=\"line\">          out += <span class=\"built_in\">String</span>.fromCharCode((c1 &amp; <span class=\"number\">0x1f</span>) &lt;&lt; <span class=\"number\">6</span> | c2 &amp; <span class=\"number\">0x3f</span>);</div><div class=\"line\">          n += <span class=\"number\">2</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">          <span class=\"comment\">//编码为1110xxxx 10xxxxxx 0xxxxxxx 表示utf8 三个字节</span></div><div class=\"line\">          c2 = str.charCodeAt(n + <span class=\"number\">1</span>);</div><div class=\"line\">          c3 = str.charCodeAt(n + <span class=\"number\">2</span>);</div><div class=\"line\">          out += <span class=\"built_in\">String</span>.fromCharCode((c1 &amp; <span class=\"number\">0x0f</span>) &lt;&lt; <span class=\"number\">12</span> | (c2 &amp; <span class=\"number\">0x3f</span>) &lt;&lt; <span class=\"number\">6</span> | c3 &amp; <span class=\"number\">0x3f</span>);</div><div class=\"line\">          n += <span class=\"number\">3</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">return</span> out</div><div class=\"line\">    &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"base64编码和解码的实现\"><a href=\"#base64编码和解码的实现\" class=\"headerlink\" title=\"base64编码和解码的实现\"></a>base64编码和解码的实现</h3><ul>\n<li><p>base64编码 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Base64 = &#123;</div><div class=\"line\">  ...,</div><div class=\"line\">  <span class=\"comment\">//base64 所用的64个字符和其中的一个补位符'='</span></div><div class=\"line\">  _keyStr: <span class=\"string\">\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"</span>,</div><div class=\"line\">  <span class=\"attr\">encode</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//base64转换算法就是根据具体的规则将3个字符变成四个字符。</span></div><div class=\"line\">    <span class=\"keyword\">let</span> out = <span class=\"string\">\"\"</span>,c1,c2,c3,</div><div class=\"line\">      outC1,outC2,outC3,outC4,i = <span class=\"number\">0</span>;</div><div class=\"line\">    str = Base64._utf8_encode(str); <span class=\"comment\">//将utf16 转换成utf8,因为JavaScript内部采用的是utf16存储所以要进行一步转换。</span></div><div class=\"line\">    <span class=\"keyword\">while</span> (i &lt; str.length) &#123;</div><div class=\"line\">      <span class=\"comment\">// 三个三个字符一组进行转换</span></div><div class=\"line\">      c1 = str.charCodeAt(i++);</div><div class=\"line\">      c2 = str.charCodeAt(i++);</div><div class=\"line\">      c3 = str.charCodeAt(i++);</div><div class=\"line\">      outC1 = c1 &gt;&gt; <span class=\"number\">2</span>; <span class=\"comment\">//第一个字符最前面添加两个0,剩余2位用作后面拼接</span></div><div class=\"line\">      outC2 = (c1 &amp; <span class=\"number\">0x03</span>) &lt;&lt; <span class=\"number\">4</span> | c2 &gt;&gt; <span class=\"number\">4</span>; <span class=\"comment\">// 第一个字符剩下两位和第二个字符前四位拼接,并在前面添加2个0拼成一个字符</span></div><div class=\"line\">      outC3 = (c2 &amp; <span class=\"number\">0x0f</span>) &lt;&lt; <span class=\"number\">2</span> | c3 &gt;&gt; <span class=\"number\">6</span>; <span class=\"comment\">//第二个字符剩余4位和第三个字符的前两位,并在前面添加2个0拼接成一个字符</span></div><div class=\"line\">      outC4 = c3 &amp; <span class=\"number\">0x3f</span>; <span class=\"comment\">//第三个字符剩下的6位前面添加两个0 拼接成一个字符</span></div><div class=\"line\">      <span class=\"comment\">//如果c2为不存在则最后两个字符为补位符'=' 如果c3不存在 则转换后最后一位为补位'='</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">isNaN</span>(c2)) &#123; outC3 = outC4 = <span class=\"number\">64</span> &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">isNaN</span>(c3)) &#123; outC4 = <span class=\"number\">64</span> &#125;</div><div class=\"line\">      out = out + <span class=\"keyword\">this</span>._keyStr.charAt(outC1) + <span class=\"keyword\">this</span>._keyStr.charAt(outC2) + <span class=\"keyword\">this</span>._keyStr.charAt(outC3) + <span class=\"keyword\">this</span>._keyStr.charAt(outC4)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> out</div><div class=\"line\">  &#125;,</div><div class=\"line\">  ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>base64 解码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Base64 = &#123;</div><div class=\"line\">    ...,</div><div class=\"line\">    <span class=\"attr\">decode</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> out = <span class=\"string\">''</span>,c1,c2,c3,c4,outC1,outC2,outC3,i = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"comment\">//去掉非base64字符</span></div><div class=\"line\">        str = str.replace(<span class=\"regexp\">/[^A-Za-z0-9+/=]/g</span>, <span class=\"string\">\"\"</span>);</div><div class=\"line\">        <span class=\"comment\">//循环处理进行解码</span></div><div class=\"line\">        <span class=\"keyword\">while</span> (i &lt; str.length) &#123;</div><div class=\"line\">          <span class=\"comment\">//4个base64字符一组,解码后将转换成3个字符</span></div><div class=\"line\">          c1 = <span class=\"keyword\">this</span>._keyStr.indexOf(str.charAt(i++));</div><div class=\"line\">          c2 = <span class=\"keyword\">this</span>._keyStr.indexOf(str.charAt(i++));</div><div class=\"line\">          c3 = <span class=\"keyword\">this</span>._keyStr.indexOf(str.charAt(i++));</div><div class=\"line\">          c4 = <span class=\"keyword\">this</span>._keyStr.indexOf(str.charAt(i++));</div><div class=\"line\">          <span class=\"comment\">//每个字符前面都会有两个前导0</span></div><div class=\"line\">          outC1 = c1 &lt;&lt; <span class=\"number\">2</span> | c2 &gt;&gt; <span class=\"number\">4</span>; <span class=\"comment\">//第一个base64字符去掉两个0后和第二个字符的开头两个字符拼成一个字节</span></div><div class=\"line\">          outC2 = (c2 &amp; <span class=\"number\">0x0f</span>) &lt;&lt; <span class=\"number\">4</span> | c3 &gt;&gt; <span class=\"number\">2</span>; <span class=\"comment\">//第二个剩下的4位和第三个开始的四位拼成一个字节</span></div><div class=\"line\">          outC3 = (c3 &amp; <span class=\"number\">0x03</span>) &lt;&lt; <span class=\"number\">6</span> | c4; <span class=\"comment\">// 第三个剩下的2位和第四个6位拼成一个字节</span></div><div class=\"line\">          out = out + <span class=\"built_in\">String</span>.fromCharCode(outC1);</div><div class=\"line\">          <span class=\"comment\">//如果倒数第二个不是补位符'='</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (c3 != <span class=\"number\">64</span>) &#123; out = out + <span class=\"built_in\">String</span>.fromCharCode(outC2) &#125;</div><div class=\"line\">          <span class=\"comment\">//如果倒数第一个不是补位符'='</span></div><div class=\"line\">          <span class=\"keyword\">if</span> (c4 != <span class=\"number\">64</span>) &#123; out = out + <span class=\"built_in\">String</span>.fromCharCode(outC3) &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        out = Base64._utf8_decode(out); <span class=\"comment\">// 将utf8转成utf16</span></div><div class=\"line\">        <span class=\"keyword\">return</span> out</div><div class=\"line\">      &#125;,</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Update-2017-03-15\"><a href=\"#Update-2017-03-15\" class=\"headerlink\" title=\"Update: 2017-03-15\"></a>Update: 2017-03-15</h3><p>根据<a href=\"https://tools.ietf.org/html/rfc3548#page-6\" target=\"_blank\" rel=\"external\">rfc3548</a>,base64中的某些字符,在一些文件系统环境下或者url中会有特殊的含义,比如斜杠,所以为了得到web safe 的base64编码,则需要将第62个字符和第63个字符(编号从0开始)替换成 <code>-</code>(minus) 和 <code>_</code>(underscore) 减号和下划线。<br>可以对编码后的base64进行字符替换如下 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">urlSafeBase64Encode</span>(<span class=\"params\">input</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> input.replace(<span class=\"string\">'+'</span>, <span class=\"string\">'-'</span>).replace(<span class=\"string\">'/'</span>, <span class=\"string\">'_'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a><a href=\"https://github.com/xdimh/jsTools/blob/master/base64_with_comment.js\" target=\"_blank\" rel=\"external\">完整代码</a></h3><h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://zh.wikipedia.org/wiki/UTF-8\" target=\"_blank\" rel=\"external\">维基百科UTF-8</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/Unicode\" target=\"_blank\" rel=\"external\">维基百科Unicode</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html\" target=\"_blank\" rel=\"external\">字符编码笔记：ASCII，Unicode和UTF-8 —— 阮一峰</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2008/06/base64.html\" target=\"_blank\" rel=\"external\">Base64笔记 —— 阮一峰</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/12/unicode.html\" target=\"_blank\" rel=\"external\">Unicode与JavaScript详解 —— 阮一峰</a></li>\n<li><a href=\"http://blog.csdn.net/thl789/article/details/7506133\" target=\"_blank\" rel=\"external\">Unicode编码及其实现：UTF-16、UTF-8，and more</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000005794963\" target=\"_blank\" rel=\"external\">通过javascript进行UTF-8编码</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators\" target=\"_blank\" rel=\"external\">按位操作符</a></li>\n</ol>\n"},{"title":"JavaScript 和 NodeJS 事件循环","type":"original","date":"2017-05-05T03:20:12.000Z","description":null,"_content":"\n\n## 写在前面\n\n　　在学习nodeclub源码的过程中,遇到了[eventproxy](https://github.com/JacksonTian/eventproxy) 这个解决金字塔回调问题的框架,为了更好的理解代码和出于好奇心,看了下 eventproxy 的源码实现,其中看到一段代码如下:\n\n```javascript\nvar later = (typeof setImmediate !== 'undefined' && setImmediate) ||\n(typeof process !== 'undefined' && process.nextTick) || function (fn) {\n    setTimeout(fn, 0);\n};\n```\n对setImmediate,process.nextTick,setTimeout 三者的区别不是很清晰,甚至对process.nextTick的作用和传入回调的执行时机也并不清楚。所以要弄清楚这些内容,就必须搞清楚 NodeJS 事件循环。\n\n## JavaScript 浏览器端的事件循环\n\n　　在深入到NodeJS的事件循环之前我们先来了解下浏览器端的事件循环,因为JavaScript是单线程的,如果没有事件循环机制的话,页面UI会因为一个耗时操作而卡死,详细内容见我之前的一篇翻译[什么是JavaScript 事件循环 ?](http://weeklyweb.info/2017/05/03/javascript-event-loop/)。这里只是做简单的介绍。\n\n![Event-Loop](http://rainypin.qiniudn.com/blog/images/event-loop.png)\n\n如图所示,在JS程序执行的时候,同步的 JavaScript 代码会在调用栈中被执行,异步的代码,如按钮点击事件处理函数,定时器,在图中就是webapis部分,在特定的事件触发或者时间到了定时器指定的耗时后,会从webapis区域移到任务队列部分,如果此时调用栈为空,没有任何代码正在执行的话,事件循环机制就会从队列中选择第一个待被执行的任务到调用栈中进行执行。那么 NodeJS 中的事件循环是怎样的呢?\n\n\n## NodeJS 事件循环\n\n　　相比浏览器中的事件循环,在NodeJS中要更加复杂一些,当 Node.js 启动时，它会初始化event loop，处理提供的代码（代码里可能会有异步API调用，timer，以及process.nextTick()），然后开始处理event loop。NodeJS中的事件循环分为几个阶段,按顺序执行。如下图:\n\n![NodeJS Event Loop Phases](https://cdn-images-1.medium.com/max/1600/1*Qmtck5vGwGU3pMoMq0WhXg.png)\n\n每个阶段都有一个FIFO(先进先出)的回调函数队列,并且各个阶段都有自己特有的操作,当事件循环进入到一个特定的阶段中,会先执行这些阶段特有的操作后,开始执行队列中的回调函数,一直到队列中的回调函数执行完,或者到达执行上限为止,事件循环才会进入下一个阶段。\n\n## 阶段概述\n\n* __timers__ : 这个阶段执行setTimeout()和setInterval()设定的回调。\n* __I/O callbacks__ : 执行几乎所有的回调，除了close回调，timer的回调，和setImmediate()的回调。\n* __idle, prepare__ : 仅内部使用。\n* __poll__ : 获取新的I/O事件；node会在适当条件下阻塞在这里。\n* __check__ : 执行setImmediate()设定的回调。\n* __close callbacks__: 执行比如socket.on('close', ...)的回调。\n\n## 阶段详情\n\n主要详细说明下几个相对比较特殊的阶段。\n\n### timers \n\ntimers阶段,如上所述,这个阶段执行setTimeout()和setInterval()设定的回调。但仅仅能做到尽可能的按照定时器设定的时间点去执行回调函数,例如``setTimeout(fn,1000);``这里虽然设定了1s后执行fn,但是并不能真正保证1s后fn就会被执行,1s这个时间是最好的情况下,系统的调度程序或者其他正在执行的回调函数都有可能使其大于1s后,fn才会被执行。\n\n### poll\n\npoll 阶段有两个功能:\n\n* 执行那些定时器触发的回调函数代码\n* 处理poll队列中的事件\n\n当事件循环进入了poll阶段并且没有相关的定时器调度,会有两种情况:\n\n* 当poll队列不为空的情况,队列里面的回调函数会被执行,直到达到上限。\n* 如果poll队列为空,又会出现两种情况:\n    * 如果有代码调用了 ``setImmediate()``, 则事件循环会结束poll阶段,转而到check阶段执行由``setImmediate()``传入的脚本代码。\n    * 如果没有调用``setImmediate()``,则事件循环会一直在该阶段等待新的待执行的回调函数加入到poll队列,然后立即执行它。\n\n一旦poll队列为空,事件循环会检查timers阶段队列中是否有回调函数(定时器已经触发的回调函数),如果有则结束poll阶段,转而到timers阶段执行该阶段队列中的回调方法。\n\n### check\n\n这个阶段允许你立即执行脚本,当poll阶段空闲且有脚本通过``setImmediate()``加入到队列中时。\n\n## setImmediate() vs setTimeout()\n\n对于这两个方法的区别只要记住两点就行了:\n\n* setImmediate()被设计在 poll 阶段结束后立即执行回调。\n* setTimeout()被设计在指定下限时间到达后执行回调。\n\n两者的调用顺序根据不同的上下文而呈现不同。如果都在main中调用,两者的调用顺序不定,如果都在I/O中被调用,如下:\n\n```JavaScript\n// timeout_vs_immediate.js\nvar fs = require('fs')\n\nfs.readFile(__filename, () => {\n  setTimeout(() => {\n    console.log('timeout')\n  }, 0)\n  setImmediate(() => {\n    console.log('immediate')\n  })\n})\n```\n则 ``setImmediate()`` 传入的回调始终先于 ``setTimeout()`` 被调用。\n\n\n## process.nextTick()\n\n到了重点需要理解的部分了，``process.nextTick()``。因为从技术上来说，它并不是event loop的一部分。可以看到``process.nextTick()``并不在上面的图中,虽然说它是异步回调API的一部分。相反的，process.nextTick()会把回调塞入nextTickQueue，nextTickQueue将在当前阶段的当前操作完成后处理，不管目前处于event loop的哪个阶段。所以,``process.nextTick() `` 不管在任何时候调用，都会在所处的这个阶段最后，在event loop进入下个阶段前，处理完所有nextTickQueue里的回调。这就会带来一个问题,如果递归调用``process.nextTick()``,就会导致poll阶段被饿死,因为程序一直在执行nextTickQueue里的回调。\n\n## process.nextTick() vs setImmediate()\n\n这两个方法很相似,作用也类似,但是还是有区别的:\n\n* ``process.nextTick()`` 在同一个阶段会被立即执行。\n* ``setImmediate()`` 会在接下来的迭代或者事件循环的一个循环被执行。\n\n从本质上说,两个方法的名称应该对调,``process.nextTick()`` 其实触发的更加及时。但这算是NodeJS API设计的遗留问题吧,也不可能去变更了,毕竟一变更,不知多少npm模块会受到影响。\n\n## 最后 \n\n我们推荐优先使用``setImmediate()``,因为它更加好理解,拥有更好的兼容性。\n\n\n## 参考内容\n\n1. [The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)\n2. [Node Event Loop](https://medium.com/@ehnertm/node-event-loop-838c13a7c4e)\n3. [Node.js的event loop及timer/setImmediate/nextTick](https://github.com/creeperyang/blog/issues/26)","source":"_posts/fe-event-loop.md","raw":"---\ntitle: JavaScript 和 NodeJS 事件循环\ntype: original\ntags: [NodeJS,JavaScript]\ncategories: [NodeJS,nodeclub源码学习]\ndate: 2017-05-05 11:20:12\ndescription:\n---\n\n\n## 写在前面\n\n　　在学习nodeclub源码的过程中,遇到了[eventproxy](https://github.com/JacksonTian/eventproxy) 这个解决金字塔回调问题的框架,为了更好的理解代码和出于好奇心,看了下 eventproxy 的源码实现,其中看到一段代码如下:\n\n```javascript\nvar later = (typeof setImmediate !== 'undefined' && setImmediate) ||\n(typeof process !== 'undefined' && process.nextTick) || function (fn) {\n    setTimeout(fn, 0);\n};\n```\n对setImmediate,process.nextTick,setTimeout 三者的区别不是很清晰,甚至对process.nextTick的作用和传入回调的执行时机也并不清楚。所以要弄清楚这些内容,就必须搞清楚 NodeJS 事件循环。\n\n## JavaScript 浏览器端的事件循环\n\n　　在深入到NodeJS的事件循环之前我们先来了解下浏览器端的事件循环,因为JavaScript是单线程的,如果没有事件循环机制的话,页面UI会因为一个耗时操作而卡死,详细内容见我之前的一篇翻译[什么是JavaScript 事件循环 ?](http://weeklyweb.info/2017/05/03/javascript-event-loop/)。这里只是做简单的介绍。\n\n![Event-Loop](http://rainypin.qiniudn.com/blog/images/event-loop.png)\n\n如图所示,在JS程序执行的时候,同步的 JavaScript 代码会在调用栈中被执行,异步的代码,如按钮点击事件处理函数,定时器,在图中就是webapis部分,在特定的事件触发或者时间到了定时器指定的耗时后,会从webapis区域移到任务队列部分,如果此时调用栈为空,没有任何代码正在执行的话,事件循环机制就会从队列中选择第一个待被执行的任务到调用栈中进行执行。那么 NodeJS 中的事件循环是怎样的呢?\n\n\n## NodeJS 事件循环\n\n　　相比浏览器中的事件循环,在NodeJS中要更加复杂一些,当 Node.js 启动时，它会初始化event loop，处理提供的代码（代码里可能会有异步API调用，timer，以及process.nextTick()），然后开始处理event loop。NodeJS中的事件循环分为几个阶段,按顺序执行。如下图:\n\n![NodeJS Event Loop Phases](https://cdn-images-1.medium.com/max/1600/1*Qmtck5vGwGU3pMoMq0WhXg.png)\n\n每个阶段都有一个FIFO(先进先出)的回调函数队列,并且各个阶段都有自己特有的操作,当事件循环进入到一个特定的阶段中,会先执行这些阶段特有的操作后,开始执行队列中的回调函数,一直到队列中的回调函数执行完,或者到达执行上限为止,事件循环才会进入下一个阶段。\n\n## 阶段概述\n\n* __timers__ : 这个阶段执行setTimeout()和setInterval()设定的回调。\n* __I/O callbacks__ : 执行几乎所有的回调，除了close回调，timer的回调，和setImmediate()的回调。\n* __idle, prepare__ : 仅内部使用。\n* __poll__ : 获取新的I/O事件；node会在适当条件下阻塞在这里。\n* __check__ : 执行setImmediate()设定的回调。\n* __close callbacks__: 执行比如socket.on('close', ...)的回调。\n\n## 阶段详情\n\n主要详细说明下几个相对比较特殊的阶段。\n\n### timers \n\ntimers阶段,如上所述,这个阶段执行setTimeout()和setInterval()设定的回调。但仅仅能做到尽可能的按照定时器设定的时间点去执行回调函数,例如``setTimeout(fn,1000);``这里虽然设定了1s后执行fn,但是并不能真正保证1s后fn就会被执行,1s这个时间是最好的情况下,系统的调度程序或者其他正在执行的回调函数都有可能使其大于1s后,fn才会被执行。\n\n### poll\n\npoll 阶段有两个功能:\n\n* 执行那些定时器触发的回调函数代码\n* 处理poll队列中的事件\n\n当事件循环进入了poll阶段并且没有相关的定时器调度,会有两种情况:\n\n* 当poll队列不为空的情况,队列里面的回调函数会被执行,直到达到上限。\n* 如果poll队列为空,又会出现两种情况:\n    * 如果有代码调用了 ``setImmediate()``, 则事件循环会结束poll阶段,转而到check阶段执行由``setImmediate()``传入的脚本代码。\n    * 如果没有调用``setImmediate()``,则事件循环会一直在该阶段等待新的待执行的回调函数加入到poll队列,然后立即执行它。\n\n一旦poll队列为空,事件循环会检查timers阶段队列中是否有回调函数(定时器已经触发的回调函数),如果有则结束poll阶段,转而到timers阶段执行该阶段队列中的回调方法。\n\n### check\n\n这个阶段允许你立即执行脚本,当poll阶段空闲且有脚本通过``setImmediate()``加入到队列中时。\n\n## setImmediate() vs setTimeout()\n\n对于这两个方法的区别只要记住两点就行了:\n\n* setImmediate()被设计在 poll 阶段结束后立即执行回调。\n* setTimeout()被设计在指定下限时间到达后执行回调。\n\n两者的调用顺序根据不同的上下文而呈现不同。如果都在main中调用,两者的调用顺序不定,如果都在I/O中被调用,如下:\n\n```JavaScript\n// timeout_vs_immediate.js\nvar fs = require('fs')\n\nfs.readFile(__filename, () => {\n  setTimeout(() => {\n    console.log('timeout')\n  }, 0)\n  setImmediate(() => {\n    console.log('immediate')\n  })\n})\n```\n则 ``setImmediate()`` 传入的回调始终先于 ``setTimeout()`` 被调用。\n\n\n## process.nextTick()\n\n到了重点需要理解的部分了，``process.nextTick()``。因为从技术上来说，它并不是event loop的一部分。可以看到``process.nextTick()``并不在上面的图中,虽然说它是异步回调API的一部分。相反的，process.nextTick()会把回调塞入nextTickQueue，nextTickQueue将在当前阶段的当前操作完成后处理，不管目前处于event loop的哪个阶段。所以,``process.nextTick() `` 不管在任何时候调用，都会在所处的这个阶段最后，在event loop进入下个阶段前，处理完所有nextTickQueue里的回调。这就会带来一个问题,如果递归调用``process.nextTick()``,就会导致poll阶段被饿死,因为程序一直在执行nextTickQueue里的回调。\n\n## process.nextTick() vs setImmediate()\n\n这两个方法很相似,作用也类似,但是还是有区别的:\n\n* ``process.nextTick()`` 在同一个阶段会被立即执行。\n* ``setImmediate()`` 会在接下来的迭代或者事件循环的一个循环被执行。\n\n从本质上说,两个方法的名称应该对调,``process.nextTick()`` 其实触发的更加及时。但这算是NodeJS API设计的遗留问题吧,也不可能去变更了,毕竟一变更,不知多少npm模块会受到影响。\n\n## 最后 \n\n我们推荐优先使用``setImmediate()``,因为它更加好理解,拥有更好的兼容性。\n\n\n## 参考内容\n\n1. [The Node.js Event Loop, Timers, and process.nextTick()](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)\n2. [Node Event Loop](https://medium.com/@ehnertm/node-event-loop-838c13a7c4e)\n3. [Node.js的event loop及timer/setImmediate/nextTick](https://github.com/creeperyang/blog/issues/26)","slug":"fe-event-loop","published":1,"updated":"2017-05-09T14:52:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhpn0006b37qu4lv3lvv","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>　　在学习nodeclub源码的过程中,遇到了<a href=\"https://github.com/JacksonTian/eventproxy\" target=\"_blank\" rel=\"external\">eventproxy</a> 这个解决金字塔回调问题的框架,为了更好的理解代码和出于好奇心,看了下 eventproxy 的源码实现,其中看到一段代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> later = (<span class=\"keyword\">typeof</span> setImmediate !== <span class=\"string\">'undefined'</span> &amp;&amp; setImmediate) ||</div><div class=\"line\">(<span class=\"keyword\">typeof</span> process !== <span class=\"string\">'undefined'</span> &amp;&amp; process.nextTick) || <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">    setTimeout(fn, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>对setImmediate,process.nextTick,setTimeout 三者的区别不是很清晰,甚至对process.nextTick的作用和传入回调的执行时机也并不清楚。所以要弄清楚这些内容,就必须搞清楚 NodeJS 事件循环。</p>\n<h2 id=\"JavaScript-浏览器端的事件循环\"><a href=\"#JavaScript-浏览器端的事件循环\" class=\"headerlink\" title=\"JavaScript 浏览器端的事件循环\"></a>JavaScript 浏览器端的事件循环</h2><p>　　在深入到NodeJS的事件循环之前我们先来了解下浏览器端的事件循环,因为JavaScript是单线程的,如果没有事件循环机制的话,页面UI会因为一个耗时操作而卡死,详细内容见我之前的一篇翻译<a href=\"http://weeklyweb.info/2017/05/03/javascript-event-loop/\" target=\"_blank\" rel=\"external\">什么是JavaScript 事件循环 ?</a>。这里只是做简单的介绍。</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/event-loop.png\" alt=\"Event-Loop\"></p>\n<p>如图所示,在JS程序执行的时候,同步的 JavaScript 代码会在调用栈中被执行,异步的代码,如按钮点击事件处理函数,定时器,在图中就是webapis部分,在特定的事件触发或者时间到了定时器指定的耗时后,会从webapis区域移到任务队列部分,如果此时调用栈为空,没有任何代码正在执行的话,事件循环机制就会从队列中选择第一个待被执行的任务到调用栈中进行执行。那么 NodeJS 中的事件循环是怎样的呢?</p>\n<h2 id=\"NodeJS-事件循环\"><a href=\"#NodeJS-事件循环\" class=\"headerlink\" title=\"NodeJS 事件循环\"></a>NodeJS 事件循环</h2><p>　　相比浏览器中的事件循环,在NodeJS中要更加复杂一些,当 Node.js 启动时，它会初始化event loop，处理提供的代码（代码里可能会有异步API调用，timer，以及process.nextTick()），然后开始处理event loop。NodeJS中的事件循环分为几个阶段,按顺序执行。如下图:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*Qmtck5vGwGU3pMoMq0WhXg.png\" alt=\"NodeJS Event Loop Phases\"></p>\n<p>每个阶段都有一个FIFO(先进先出)的回调函数队列,并且各个阶段都有自己特有的操作,当事件循环进入到一个特定的阶段中,会先执行这些阶段特有的操作后,开始执行队列中的回调函数,一直到队列中的回调函数执行完,或者到达执行上限为止,事件循环才会进入下一个阶段。</p>\n<h2 id=\"阶段概述\"><a href=\"#阶段概述\" class=\"headerlink\" title=\"阶段概述\"></a>阶段概述</h2><ul>\n<li><strong>timers</strong> : 这个阶段执行setTimeout()和setInterval()设定的回调。</li>\n<li><strong>I/O callbacks</strong> : 执行几乎所有的回调，除了close回调，timer的回调，和setImmediate()的回调。</li>\n<li><strong>idle, prepare</strong> : 仅内部使用。</li>\n<li><strong>poll</strong> : 获取新的I/O事件；node会在适当条件下阻塞在这里。</li>\n<li><strong>check</strong> : 执行setImmediate()设定的回调。</li>\n<li><strong>close callbacks</strong>: 执行比如socket.on(‘close’, …)的回调。</li>\n</ul>\n<h2 id=\"阶段详情\"><a href=\"#阶段详情\" class=\"headerlink\" title=\"阶段详情\"></a>阶段详情</h2><p>主要详细说明下几个相对比较特殊的阶段。</p>\n<h3 id=\"timers\"><a href=\"#timers\" class=\"headerlink\" title=\"timers\"></a>timers</h3><p>timers阶段,如上所述,这个阶段执行setTimeout()和setInterval()设定的回调。但仅仅能做到尽可能的按照定时器设定的时间点去执行回调函数,例如<code>setTimeout(fn,1000);</code>这里虽然设定了1s后执行fn,但是并不能真正保证1s后fn就会被执行,1s这个时间是最好的情况下,系统的调度程序或者其他正在执行的回调函数都有可能使其大于1s后,fn才会被执行。</p>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><p>poll 阶段有两个功能:</p>\n<ul>\n<li>执行那些定时器触发的回调函数代码</li>\n<li>处理poll队列中的事件</li>\n</ul>\n<p>当事件循环进入了poll阶段并且没有相关的定时器调度,会有两种情况:</p>\n<ul>\n<li>当poll队列不为空的情况,队列里面的回调函数会被执行,直到达到上限。</li>\n<li>如果poll队列为空,又会出现两种情况:<ul>\n<li>如果有代码调用了 <code>setImmediate()</code>, 则事件循环会结束poll阶段,转而到check阶段执行由<code>setImmediate()</code>传入的脚本代码。</li>\n<li>如果没有调用<code>setImmediate()</code>,则事件循环会一直在该阶段等待新的待执行的回调函数加入到poll队列,然后立即执行它。</li>\n</ul>\n</li>\n</ul>\n<p>一旦poll队列为空,事件循环会检查timers阶段队列中是否有回调函数(定时器已经触发的回调函数),如果有则结束poll阶段,转而到timers阶段执行该阶段队列中的回调方法。</p>\n<h3 id=\"check\"><a href=\"#check\" class=\"headerlink\" title=\"check\"></a>check</h3><p>这个阶段允许你立即执行脚本,当poll阶段空闲且有脚本通过<code>setImmediate()</code>加入到队列中时。</p>\n<h2 id=\"setImmediate-vs-setTimeout\"><a href=\"#setImmediate-vs-setTimeout\" class=\"headerlink\" title=\"setImmediate() vs setTimeout()\"></a>setImmediate() vs setTimeout()</h2><p>对于这两个方法的区别只要记住两点就行了:</p>\n<ul>\n<li>setImmediate()被设计在 poll 阶段结束后立即执行回调。</li>\n<li>setTimeout()被设计在指定下限时间到达后执行回调。</li>\n</ul>\n<p>两者的调用顺序根据不同的上下文而呈现不同。如果都在main中调用,两者的调用顺序不定,如果都在I/O中被调用,如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// timeout_vs_immediate.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"></div><div class=\"line\">fs.readFile(__filename, () =&gt; &#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout'</span>)</div><div class=\"line\">  &#125;, <span class=\"number\">0</span>)</div><div class=\"line\">  setImmediate(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'immediate'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>则 <code>setImmediate()</code> 传入的回调始终先于 <code>setTimeout()</code> 被调用。</p>\n<h2 id=\"process-nextTick\"><a href=\"#process-nextTick\" class=\"headerlink\" title=\"process.nextTick()\"></a>process.nextTick()</h2><p>到了重点需要理解的部分了，<code>process.nextTick()</code>。因为从技术上来说，它并不是event loop的一部分。可以看到<code>process.nextTick()</code>并不在上面的图中,虽然说它是异步回调API的一部分。相反的，process.nextTick()会把回调塞入nextTickQueue，nextTickQueue将在当前阶段的当前操作完成后处理，不管目前处于event loop的哪个阶段。所以,<code>process.nextTick()</code> 不管在任何时候调用，都会在所处的这个阶段最后，在event loop进入下个阶段前，处理完所有nextTickQueue里的回调。这就会带来一个问题,如果递归调用<code>process.nextTick()</code>,就会导致poll阶段被饿死,因为程序一直在执行nextTickQueue里的回调。</p>\n<h2 id=\"process-nextTick-vs-setImmediate\"><a href=\"#process-nextTick-vs-setImmediate\" class=\"headerlink\" title=\"process.nextTick() vs setImmediate()\"></a>process.nextTick() vs setImmediate()</h2><p>这两个方法很相似,作用也类似,但是还是有区别的:</p>\n<ul>\n<li><code>process.nextTick()</code> 在同一个阶段会被立即执行。</li>\n<li><code>setImmediate()</code> 会在接下来的迭代或者事件循环的一个循环被执行。</li>\n</ul>\n<p>从本质上说,两个方法的名称应该对调,<code>process.nextTick()</code> 其实触发的更加及时。但这算是NodeJS API设计的遗留问题吧,也不可能去变更了,毕竟一变更,不知多少npm模块会受到影响。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>我们推荐优先使用<code>setImmediate()</code>,因为它更加好理解,拥有更好的兼容性。</p>\n<h2 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h2><ol>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"external\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n<li><a href=\"https://medium.com/@ehnertm/node-event-loop-838c13a7c4e\" target=\"_blank\" rel=\"external\">Node Event Loop</a></li>\n<li><a href=\"https://github.com/creeperyang/blog/issues/26\" target=\"_blank\" rel=\"external\">Node.js的event loop及timer/setImmediate/nextTick</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>　　在学习nodeclub源码的过程中,遇到了<a href=\"https://github.com/JacksonTian/eventproxy\" target=\"_blank\" rel=\"external\">eventproxy</a> 这个解决金字塔回调问题的框架,为了更好的理解代码和出于好奇心,看了下 eventproxy 的源码实现,其中看到一段代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> later = (<span class=\"keyword\">typeof</span> setImmediate !== <span class=\"string\">'undefined'</span> &amp;&amp; setImmediate) ||</div><div class=\"line\">(<span class=\"keyword\">typeof</span> process !== <span class=\"string\">'undefined'</span> &amp;&amp; process.nextTick) || <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">    setTimeout(fn, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>对setImmediate,process.nextTick,setTimeout 三者的区别不是很清晰,甚至对process.nextTick的作用和传入回调的执行时机也并不清楚。所以要弄清楚这些内容,就必须搞清楚 NodeJS 事件循环。</p>\n<h2 id=\"JavaScript-浏览器端的事件循环\"><a href=\"#JavaScript-浏览器端的事件循环\" class=\"headerlink\" title=\"JavaScript 浏览器端的事件循环\"></a>JavaScript 浏览器端的事件循环</h2><p>　　在深入到NodeJS的事件循环之前我们先来了解下浏览器端的事件循环,因为JavaScript是单线程的,如果没有事件循环机制的话,页面UI会因为一个耗时操作而卡死,详细内容见我之前的一篇翻译<a href=\"http://weeklyweb.info/2017/05/03/javascript-event-loop/\" target=\"_blank\" rel=\"external\">什么是JavaScript 事件循环 ?</a>。这里只是做简单的介绍。</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/event-loop.png\" alt=\"Event-Loop\"></p>\n<p>如图所示,在JS程序执行的时候,同步的 JavaScript 代码会在调用栈中被执行,异步的代码,如按钮点击事件处理函数,定时器,在图中就是webapis部分,在特定的事件触发或者时间到了定时器指定的耗时后,会从webapis区域移到任务队列部分,如果此时调用栈为空,没有任何代码正在执行的话,事件循环机制就会从队列中选择第一个待被执行的任务到调用栈中进行执行。那么 NodeJS 中的事件循环是怎样的呢?</p>\n<h2 id=\"NodeJS-事件循环\"><a href=\"#NodeJS-事件循环\" class=\"headerlink\" title=\"NodeJS 事件循环\"></a>NodeJS 事件循环</h2><p>　　相比浏览器中的事件循环,在NodeJS中要更加复杂一些,当 Node.js 启动时，它会初始化event loop，处理提供的代码（代码里可能会有异步API调用，timer，以及process.nextTick()），然后开始处理event loop。NodeJS中的事件循环分为几个阶段,按顺序执行。如下图:</p>\n<p><img src=\"https://cdn-images-1.medium.com/max/1600/1*Qmtck5vGwGU3pMoMq0WhXg.png\" alt=\"NodeJS Event Loop Phases\"></p>\n<p>每个阶段都有一个FIFO(先进先出)的回调函数队列,并且各个阶段都有自己特有的操作,当事件循环进入到一个特定的阶段中,会先执行这些阶段特有的操作后,开始执行队列中的回调函数,一直到队列中的回调函数执行完,或者到达执行上限为止,事件循环才会进入下一个阶段。</p>\n<h2 id=\"阶段概述\"><a href=\"#阶段概述\" class=\"headerlink\" title=\"阶段概述\"></a>阶段概述</h2><ul>\n<li><strong>timers</strong> : 这个阶段执行setTimeout()和setInterval()设定的回调。</li>\n<li><strong>I/O callbacks</strong> : 执行几乎所有的回调，除了close回调，timer的回调，和setImmediate()的回调。</li>\n<li><strong>idle, prepare</strong> : 仅内部使用。</li>\n<li><strong>poll</strong> : 获取新的I/O事件；node会在适当条件下阻塞在这里。</li>\n<li><strong>check</strong> : 执行setImmediate()设定的回调。</li>\n<li><strong>close callbacks</strong>: 执行比如socket.on(‘close’, …)的回调。</li>\n</ul>\n<h2 id=\"阶段详情\"><a href=\"#阶段详情\" class=\"headerlink\" title=\"阶段详情\"></a>阶段详情</h2><p>主要详细说明下几个相对比较特殊的阶段。</p>\n<h3 id=\"timers\"><a href=\"#timers\" class=\"headerlink\" title=\"timers\"></a>timers</h3><p>timers阶段,如上所述,这个阶段执行setTimeout()和setInterval()设定的回调。但仅仅能做到尽可能的按照定时器设定的时间点去执行回调函数,例如<code>setTimeout(fn,1000);</code>这里虽然设定了1s后执行fn,但是并不能真正保证1s后fn就会被执行,1s这个时间是最好的情况下,系统的调度程序或者其他正在执行的回调函数都有可能使其大于1s后,fn才会被执行。</p>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><p>poll 阶段有两个功能:</p>\n<ul>\n<li>执行那些定时器触发的回调函数代码</li>\n<li>处理poll队列中的事件</li>\n</ul>\n<p>当事件循环进入了poll阶段并且没有相关的定时器调度,会有两种情况:</p>\n<ul>\n<li>当poll队列不为空的情况,队列里面的回调函数会被执行,直到达到上限。</li>\n<li>如果poll队列为空,又会出现两种情况:<ul>\n<li>如果有代码调用了 <code>setImmediate()</code>, 则事件循环会结束poll阶段,转而到check阶段执行由<code>setImmediate()</code>传入的脚本代码。</li>\n<li>如果没有调用<code>setImmediate()</code>,则事件循环会一直在该阶段等待新的待执行的回调函数加入到poll队列,然后立即执行它。</li>\n</ul>\n</li>\n</ul>\n<p>一旦poll队列为空,事件循环会检查timers阶段队列中是否有回调函数(定时器已经触发的回调函数),如果有则结束poll阶段,转而到timers阶段执行该阶段队列中的回调方法。</p>\n<h3 id=\"check\"><a href=\"#check\" class=\"headerlink\" title=\"check\"></a>check</h3><p>这个阶段允许你立即执行脚本,当poll阶段空闲且有脚本通过<code>setImmediate()</code>加入到队列中时。</p>\n<h2 id=\"setImmediate-vs-setTimeout\"><a href=\"#setImmediate-vs-setTimeout\" class=\"headerlink\" title=\"setImmediate() vs setTimeout()\"></a>setImmediate() vs setTimeout()</h2><p>对于这两个方法的区别只要记住两点就行了:</p>\n<ul>\n<li>setImmediate()被设计在 poll 阶段结束后立即执行回调。</li>\n<li>setTimeout()被设计在指定下限时间到达后执行回调。</li>\n</ul>\n<p>两者的调用顺序根据不同的上下文而呈现不同。如果都在main中调用,两者的调用顺序不定,如果都在I/O中被调用,如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// timeout_vs_immediate.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</div><div class=\"line\"></div><div class=\"line\">fs.readFile(__filename, () =&gt; &#123;</div><div class=\"line\">  setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout'</span>)</div><div class=\"line\">  &#125;, <span class=\"number\">0</span>)</div><div class=\"line\">  setImmediate(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'immediate'</span>)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>则 <code>setImmediate()</code> 传入的回调始终先于 <code>setTimeout()</code> 被调用。</p>\n<h2 id=\"process-nextTick\"><a href=\"#process-nextTick\" class=\"headerlink\" title=\"process.nextTick()\"></a>process.nextTick()</h2><p>到了重点需要理解的部分了，<code>process.nextTick()</code>。因为从技术上来说，它并不是event loop的一部分。可以看到<code>process.nextTick()</code>并不在上面的图中,虽然说它是异步回调API的一部分。相反的，process.nextTick()会把回调塞入nextTickQueue，nextTickQueue将在当前阶段的当前操作完成后处理，不管目前处于event loop的哪个阶段。所以,<code>process.nextTick()</code> 不管在任何时候调用，都会在所处的这个阶段最后，在event loop进入下个阶段前，处理完所有nextTickQueue里的回调。这就会带来一个问题,如果递归调用<code>process.nextTick()</code>,就会导致poll阶段被饿死,因为程序一直在执行nextTickQueue里的回调。</p>\n<h2 id=\"process-nextTick-vs-setImmediate\"><a href=\"#process-nextTick-vs-setImmediate\" class=\"headerlink\" title=\"process.nextTick() vs setImmediate()\"></a>process.nextTick() vs setImmediate()</h2><p>这两个方法很相似,作用也类似,但是还是有区别的:</p>\n<ul>\n<li><code>process.nextTick()</code> 在同一个阶段会被立即执行。</li>\n<li><code>setImmediate()</code> 会在接下来的迭代或者事件循环的一个循环被执行。</li>\n</ul>\n<p>从本质上说,两个方法的名称应该对调,<code>process.nextTick()</code> 其实触发的更加及时。但这算是NodeJS API设计的遗留问题吧,也不可能去变更了,毕竟一变更,不知多少npm模块会受到影响。</p>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>我们推荐优先使用<code>setImmediate()</code>,因为它更加好理解,拥有更好的兼容性。</p>\n<h2 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h2><ol>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"external\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n<li><a href=\"https://medium.com/@ehnertm/node-event-loop-838c13a7c4e\" target=\"_blank\" rel=\"external\">Node Event Loop</a></li>\n<li><a href=\"https://github.com/creeperyang/blog/issues/26\" target=\"_blank\" rel=\"external\">Node.js的event loop及timer/setImmediate/nextTick</a></li>\n</ol>\n"},{"title":"git 和 npm 常用命令汇总","type":"original","date":"2017-06-24T05:12:17.000Z","description":null,"_content":"\n　　最近几个星期一直忙着公司各种业务,再加上王者农药简直不要太火,一不小心入坑了,所以记录中断了一阵。对于前端开发工程师来说工具中用的最多的莫过于 git 和 npm 了,随着做得业务越来越多,也封装了一些通用组件出来,为了能够更方便的在多个项目之间共享通用组件,也更好的对组件进行维护,所以在公司内部搭了一个私有的npm服务。具体如何搭建可以参考这篇文章:http://www.cnblogs.com/wyzfzu/p/4149310.html,在配置的过程中注意以下几点配置:\n\n```javascript\n{  // default system admins\n   admins: {\n     // name: email\n     fengmk2: 'fengmk2@gmail.com',\n     admin: 'admin@cnpmjs.org',\n     dead_horse: 'dead_horse@qq.com',\n   },\n  // enable private mode or not\n  // private mode: only admins can publish, other users just can sync package from source npm\n  // public mode: all users can publish\n  enablePrivate: false,\n\n  // registry scopes, if don't set, means do not support scopes\n  scopes: [ '@cnpm', '@cnpmtest', '@cnpm-test' ],\n // if set true, will 302 redirect to `nfs.url(dist.key)`\n downloadRedirectToNFS: false,\n\n // registry url name\n registryHost: 'r.cnpmjs.org'\n}\n```\n\n如果你不允许其他人未经授权的情况下提交模块到私有npm服务器上,这里enablePrivate 就需要设置为false。此时只有在 admins 中列举的用户才能够提交模块到npm服务器上。如果你希望你上传的组件,模块团队成员其他人也能够下载安装,那么 downloadRedirectToNFS 你就需要设置为true,registryHost 也需要设置成你自己的地址如``http://192.168.1.6:7001`` 上面的scope类似一个命名空间,这样在不同scope中同名的模块也不会出现冲突。\n\n\n　　搭好了服务器后,我们需要知道一些常用的 npm 命令,首先我们需要新建一个用户,然后登陆npm 服务才能进行提交模块。\n\n* npm adduser\n\n创建用户,通常需要指定 registry, 如果不指定,采用默认的。我们可以通过nrm 这个模块来方便快捷的切换不同的registry。 \n\n```\n  npm ---- https://registry.npmjs.org/\n  cnpm --- http://r.cnpmjs.org/\n* taobao - http://registry.npm.taobao.org/\n  edunpm - http://registry.enpmjs.org/\n  eu ----- http://registry.npmjs.eu/\n  au ----- http://registry.npmjs.org.au/\n  sl ----- http://npm.strongloop.com/\n  nj ----- https://registry.nodejitsu.com/\n  pt ----- http://registry.npmjs.pt/\n  yzj ---- http://192.168.101.243:7001/\n\n```\n带星号的表示当前正在使用的 registry 。\n\n* npm login \n\n> npm login is an alias to adduser and behaves exactly the same way.\n  \n* npm publish \n\n提交模块到指定的 registry\n\n* npm unpublish [<@scope>/]<pkg>[@<version>] [--force]\n\n删除服务器上的模块,可能有人想知道这里scope 具体使用方式,下面就简单介绍下好了。\n\nscope 就像命名空间一样,不过这个是用在npm 模块上的,如果一个模块以@开通那么他就是一个scope 模块。例如 ``@scope/project-name`` , 每一个npm 用户都有一个默认的scope,这个scope就是用户名, ``@username/project-name`` 。 怎么提交自己的模块到scope中呢?\n其实比较简单,只要在 package.json 中name字段加上scope名就行,如下:\n\n```javascript\n{\n  \"name\": \"@yzj/rn-component\",\n  \"version\": \"0.1.1\"\n}\n```\n\n安装的时候需要提供包括scope的模块名称,如 ``npm install -S @yzj/rn-component`` ,这样会在你 node_modules 目录出现 @yzj 目录。\n\n![npm scope](http://rainypin.qiniudn.com/blog/images/npm-scope.png)\n\n可以在package.json 文件中看到具体的依赖\n\n```\n\"dependencies\": {\n    \"@yzj/rn-component\": \"^0.1.1\"\n}\n```\n\nscope 带来的好处,这样能够清楚的知道哪些模块是公共npm下载的,哪些是私有npm上的,如果哪天公共模块不能满足需求,我们在其基础之上改了代码,发布成同名的模块,我们最好在前面带个scope 这样能够很好很清晰的进行区分。\n\n* npm owner add <user> [<@scope>/]<pkg>\n \n给项目添加维护人员。如果一个模块有好几个人共同维护提交,那么就需要通过这个命令,添加共同维护人员。\n\n* npm owner rm <user> [<@scope>/]<pkg>\n   \n看名字就是删除某个维护人员\n\n* npm owner ls [<@scope>/]<pkg> \n\n列举出这个模块的所有维护人员。\n\n\n## Git 常用命令汇总\n\n如果我们在github上面看到一个好的项目,但是我们想改变其源码使其能够契合我们的业务场景,可以通过命令:\n\n``git clone project-url [rename]`` \n\n克隆远程仓库到本地。然后通过 ``git pull`` 同步远程最新内容到本地。这个时候往往我们处于本地的master分支上,如果你想看本地又多少分支,可以通过命令 ``git branch`` 查看,其中分支名前面带星号的是我们正处于的分支。\n\n```\n* master\n```\n如果你还想知道远程仓库有几个分支,可以通过命令 ``git branch -a`` 来查看\n\n```\n* master\n  remotes/blog/master\n```\n如果这个时候,我们不想直接在master上修改代码,我们可以通过命令``git checkout  -b new_branch_name``从master创建分支 new_branch_name 并切换到这个分支上。当你修改完代码后,你可以通过命令``git status``看下我们有几个文件被修改,这些修改的内容有没有处于待提交状态\n\n```\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   .deploy_git (new commits)\n        modified:   source/_posts/event-proxy.md\n        modified:   source/_posts/fe-event-loop.md\n        modified:   source/_posts/webpack1-to-webpack2.md\n        modified:   themes/weekly/source/js/coupon.js\n        modified:   themes/weekly/source/js/couponfs.js\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n        public/\n        source/_drafts/\n        source/_posts/git-and-npm.md\n\n```\n\n可以看到有些文件虽然被修改了 但是还是处于untracked状态,那么我们可以通过``git add . `` 命令一次将显示的所有untracked文件变成待提交状态。这个时候我们就可以通过``git commit -m 'msg'`` 来提交这次修改,如果我们想把这个分支也同步到远程仓库去就需要通过命令``git push origin new_branch_name`` , 这样远程仓库就也有一个和本地一样的分支,团队中的其他成员就可以checkout,并在同一个分支上进行就改,如果不需要将这个分支push到远程仓库,那么你也可以通过``git checkout master `` 先切换到master分支,然后通过命令 ``git merge new_branch_name`` 将分支内容合并到本地master 分支上,然后``git pull && git add . && git commit -m 'msg' && git push origin master`` 将master新提交的内容同步到远程。然后通过命令 ``git branch -d new_branch_name``删除本地分支。 当代码到达一个阶段趋于稳定后,我们就会进行一个发版,这个时候就需要给代码打一个tag,作为一个阶段节点,我们可以通过命令``git tag -a v1.1.4 -m '版本更新内容'`` 新建一个tag,这个时候如果发现我们tag版本更新内容写错了,我们可以将刚刚建立的tag,删除掉,通过``git tag -d v1.1.4`` 重新建一个,然后我们将tag标签push到远程仓库 ``git push origin v1.1.4``。\n\n\n## Git 常见问题 \n\n1. 如何删除远程仓库的一次错误提交 ?\n    \n    * git reset commit-id \n     \n        本地先切换到正确提交节点\n    \n    * git push origin -d branch-name / git push origin :branch-name \n        \n        上面两种方式选一种删除远程分支\n        \n    * git push origin branch-name\n        \n        将本地分支重新推送到远程\n    \n\n2. 如何删除远程仓库的一次错误tag ?\n\n    * git tag -d <tagname> && git push origin :refs/tags/<tagname>\n     \n        删除本地tag,然后推送一个空tag到远程,等同于删除远程tag\n\n\n3. 如何解决更新的时候因为本地有修改,不能成功更新的问题?\n    \n    * git stash \n        \n        暂存本地修改内容\n    \n    * git pull \n        \n        拉取更新\n    \n    * git stash pop \n        \n        弹出本地内容进行合并,如果有冲突则进行冲突解决\n\n4. 如何从tag检出代码?\n        \n    * git checkout -b branch_name tag_name\n\n\n## 参考 \n1. http://zengrong.net/post/1746.htm\n2. http://zengrong.net/post/1746.htm\n3. https://docs.npmjs.com/getting-started/scoped-packages\n","source":"_posts/git-and-npm.md","raw":"---\ntitle: git 和 npm 常用命令汇总\ntype: original\ntags: [git,npm]\ncategories: [前端大杂烩]\ndate: 2017-06-24 13:12:17\ndescription: \n---\n\n　　最近几个星期一直忙着公司各种业务,再加上王者农药简直不要太火,一不小心入坑了,所以记录中断了一阵。对于前端开发工程师来说工具中用的最多的莫过于 git 和 npm 了,随着做得业务越来越多,也封装了一些通用组件出来,为了能够更方便的在多个项目之间共享通用组件,也更好的对组件进行维护,所以在公司内部搭了一个私有的npm服务。具体如何搭建可以参考这篇文章:http://www.cnblogs.com/wyzfzu/p/4149310.html,在配置的过程中注意以下几点配置:\n\n```javascript\n{  // default system admins\n   admins: {\n     // name: email\n     fengmk2: 'fengmk2@gmail.com',\n     admin: 'admin@cnpmjs.org',\n     dead_horse: 'dead_horse@qq.com',\n   },\n  // enable private mode or not\n  // private mode: only admins can publish, other users just can sync package from source npm\n  // public mode: all users can publish\n  enablePrivate: false,\n\n  // registry scopes, if don't set, means do not support scopes\n  scopes: [ '@cnpm', '@cnpmtest', '@cnpm-test' ],\n // if set true, will 302 redirect to `nfs.url(dist.key)`\n downloadRedirectToNFS: false,\n\n // registry url name\n registryHost: 'r.cnpmjs.org'\n}\n```\n\n如果你不允许其他人未经授权的情况下提交模块到私有npm服务器上,这里enablePrivate 就需要设置为false。此时只有在 admins 中列举的用户才能够提交模块到npm服务器上。如果你希望你上传的组件,模块团队成员其他人也能够下载安装,那么 downloadRedirectToNFS 你就需要设置为true,registryHost 也需要设置成你自己的地址如``http://192.168.1.6:7001`` 上面的scope类似一个命名空间,这样在不同scope中同名的模块也不会出现冲突。\n\n\n　　搭好了服务器后,我们需要知道一些常用的 npm 命令,首先我们需要新建一个用户,然后登陆npm 服务才能进行提交模块。\n\n* npm adduser\n\n创建用户,通常需要指定 registry, 如果不指定,采用默认的。我们可以通过nrm 这个模块来方便快捷的切换不同的registry。 \n\n```\n  npm ---- https://registry.npmjs.org/\n  cnpm --- http://r.cnpmjs.org/\n* taobao - http://registry.npm.taobao.org/\n  edunpm - http://registry.enpmjs.org/\n  eu ----- http://registry.npmjs.eu/\n  au ----- http://registry.npmjs.org.au/\n  sl ----- http://npm.strongloop.com/\n  nj ----- https://registry.nodejitsu.com/\n  pt ----- http://registry.npmjs.pt/\n  yzj ---- http://192.168.101.243:7001/\n\n```\n带星号的表示当前正在使用的 registry 。\n\n* npm login \n\n> npm login is an alias to adduser and behaves exactly the same way.\n  \n* npm publish \n\n提交模块到指定的 registry\n\n* npm unpublish [<@scope>/]<pkg>[@<version>] [--force]\n\n删除服务器上的模块,可能有人想知道这里scope 具体使用方式,下面就简单介绍下好了。\n\nscope 就像命名空间一样,不过这个是用在npm 模块上的,如果一个模块以@开通那么他就是一个scope 模块。例如 ``@scope/project-name`` , 每一个npm 用户都有一个默认的scope,这个scope就是用户名, ``@username/project-name`` 。 怎么提交自己的模块到scope中呢?\n其实比较简单,只要在 package.json 中name字段加上scope名就行,如下:\n\n```javascript\n{\n  \"name\": \"@yzj/rn-component\",\n  \"version\": \"0.1.1\"\n}\n```\n\n安装的时候需要提供包括scope的模块名称,如 ``npm install -S @yzj/rn-component`` ,这样会在你 node_modules 目录出现 @yzj 目录。\n\n![npm scope](http://rainypin.qiniudn.com/blog/images/npm-scope.png)\n\n可以在package.json 文件中看到具体的依赖\n\n```\n\"dependencies\": {\n    \"@yzj/rn-component\": \"^0.1.1\"\n}\n```\n\nscope 带来的好处,这样能够清楚的知道哪些模块是公共npm下载的,哪些是私有npm上的,如果哪天公共模块不能满足需求,我们在其基础之上改了代码,发布成同名的模块,我们最好在前面带个scope 这样能够很好很清晰的进行区分。\n\n* npm owner add <user> [<@scope>/]<pkg>\n \n给项目添加维护人员。如果一个模块有好几个人共同维护提交,那么就需要通过这个命令,添加共同维护人员。\n\n* npm owner rm <user> [<@scope>/]<pkg>\n   \n看名字就是删除某个维护人员\n\n* npm owner ls [<@scope>/]<pkg> \n\n列举出这个模块的所有维护人员。\n\n\n## Git 常用命令汇总\n\n如果我们在github上面看到一个好的项目,但是我们想改变其源码使其能够契合我们的业务场景,可以通过命令:\n\n``git clone project-url [rename]`` \n\n克隆远程仓库到本地。然后通过 ``git pull`` 同步远程最新内容到本地。这个时候往往我们处于本地的master分支上,如果你想看本地又多少分支,可以通过命令 ``git branch`` 查看,其中分支名前面带星号的是我们正处于的分支。\n\n```\n* master\n```\n如果你还想知道远程仓库有几个分支,可以通过命令 ``git branch -a`` 来查看\n\n```\n* master\n  remotes/blog/master\n```\n如果这个时候,我们不想直接在master上修改代码,我们可以通过命令``git checkout  -b new_branch_name``从master创建分支 new_branch_name 并切换到这个分支上。当你修改完代码后,你可以通过命令``git status``看下我们有几个文件被修改,这些修改的内容有没有处于待提交状态\n\n```\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   .deploy_git (new commits)\n        modified:   source/_posts/event-proxy.md\n        modified:   source/_posts/fe-event-loop.md\n        modified:   source/_posts/webpack1-to-webpack2.md\n        modified:   themes/weekly/source/js/coupon.js\n        modified:   themes/weekly/source/js/couponfs.js\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n        public/\n        source/_drafts/\n        source/_posts/git-and-npm.md\n\n```\n\n可以看到有些文件虽然被修改了 但是还是处于untracked状态,那么我们可以通过``git add . `` 命令一次将显示的所有untracked文件变成待提交状态。这个时候我们就可以通过``git commit -m 'msg'`` 来提交这次修改,如果我们想把这个分支也同步到远程仓库去就需要通过命令``git push origin new_branch_name`` , 这样远程仓库就也有一个和本地一样的分支,团队中的其他成员就可以checkout,并在同一个分支上进行就改,如果不需要将这个分支push到远程仓库,那么你也可以通过``git checkout master `` 先切换到master分支,然后通过命令 ``git merge new_branch_name`` 将分支内容合并到本地master 分支上,然后``git pull && git add . && git commit -m 'msg' && git push origin master`` 将master新提交的内容同步到远程。然后通过命令 ``git branch -d new_branch_name``删除本地分支。 当代码到达一个阶段趋于稳定后,我们就会进行一个发版,这个时候就需要给代码打一个tag,作为一个阶段节点,我们可以通过命令``git tag -a v1.1.4 -m '版本更新内容'`` 新建一个tag,这个时候如果发现我们tag版本更新内容写错了,我们可以将刚刚建立的tag,删除掉,通过``git tag -d v1.1.4`` 重新建一个,然后我们将tag标签push到远程仓库 ``git push origin v1.1.4``。\n\n\n## Git 常见问题 \n\n1. 如何删除远程仓库的一次错误提交 ?\n    \n    * git reset commit-id \n     \n        本地先切换到正确提交节点\n    \n    * git push origin -d branch-name / git push origin :branch-name \n        \n        上面两种方式选一种删除远程分支\n        \n    * git push origin branch-name\n        \n        将本地分支重新推送到远程\n    \n\n2. 如何删除远程仓库的一次错误tag ?\n\n    * git tag -d <tagname> && git push origin :refs/tags/<tagname>\n     \n        删除本地tag,然后推送一个空tag到远程,等同于删除远程tag\n\n\n3. 如何解决更新的时候因为本地有修改,不能成功更新的问题?\n    \n    * git stash \n        \n        暂存本地修改内容\n    \n    * git pull \n        \n        拉取更新\n    \n    * git stash pop \n        \n        弹出本地内容进行合并,如果有冲突则进行冲突解决\n\n4. 如何从tag检出代码?\n        \n    * git checkout -b branch_name tag_name\n\n\n## 参考 \n1. http://zengrong.net/post/1746.htm\n2. http://zengrong.net/post/1746.htm\n3. https://docs.npmjs.com/getting-started/scoped-packages\n","slug":"git-and-npm","published":1,"updated":"2017-08-01T05:40:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhps0007b37q6wqd5srr","content":"<p>　　最近几个星期一直忙着公司各种业务,再加上王者农药简直不要太火,一不小心入坑了,所以记录中断了一阵。对于前端开发工程师来说工具中用的最多的莫过于 git 和 npm 了,随着做得业务越来越多,也封装了一些通用组件出来,为了能够更方便的在多个项目之间共享通用组件,也更好的对组件进行维护,所以在公司内部搭了一个私有的npm服务。具体如何搭建可以参考这篇文章:<a href=\"http://www.cnblogs.com/wyzfzu/p/4149310.html,在配置的过程中注意以下几点配置\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/wyzfzu/p/4149310.html,在配置的过程中注意以下几点配置</a>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;  <span class=\"comment\">// default system admins</span></div><div class=\"line\">   admins: &#123;</div><div class=\"line\">     <span class=\"comment\">// name: email</span></div><div class=\"line\">     fengmk2: <span class=\"string\">'fengmk2@gmail.com'</span>,</div><div class=\"line\">     <span class=\"attr\">admin</span>: <span class=\"string\">'admin@cnpmjs.org'</span>,</div><div class=\"line\">     <span class=\"attr\">dead_horse</span>: <span class=\"string\">'dead_horse@qq.com'</span>,</div><div class=\"line\">   &#125;,</div><div class=\"line\">  <span class=\"comment\">// enable private mode or not</span></div><div class=\"line\">  <span class=\"comment\">// private mode: only admins can publish, other users just can sync package from source npm</span></div><div class=\"line\">  <span class=\"comment\">// public mode: all users can publish</span></div><div class=\"line\">  enablePrivate: <span class=\"literal\">false</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// registry scopes, if don't set, means do not support scopes</span></div><div class=\"line\">  scopes: [ <span class=\"string\">'@cnpm'</span>, <span class=\"string\">'@cnpmtest'</span>, <span class=\"string\">'@cnpm-test'</span> ],</div><div class=\"line\"> <span class=\"comment\">// if set true, will 302 redirect to `nfs.url(dist.key)`</span></div><div class=\"line\"> downloadRedirectToNFS: <span class=\"literal\">false</span>,</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// registry url name</span></div><div class=\"line\"> registryHost: <span class=\"string\">'r.cnpmjs.org'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你不允许其他人未经授权的情况下提交模块到私有npm服务器上,这里enablePrivate 就需要设置为false。此时只有在 admins 中列举的用户才能够提交模块到npm服务器上。如果你希望你上传的组件,模块团队成员其他人也能够下载安装,那么 downloadRedirectToNFS 你就需要设置为true,registryHost 也需要设置成你自己的地址如<code>http://192.168.1.6:7001</code> 上面的scope类似一个命名空间,这样在不同scope中同名的模块也不会出现冲突。</p>\n<p>　　搭好了服务器后,我们需要知道一些常用的 npm 命令,首先我们需要新建一个用户,然后登陆npm 服务才能进行提交模块。</p>\n<ul>\n<li>npm adduser</li>\n</ul>\n<p>创建用户,通常需要指定 registry, 如果不指定,采用默认的。我们可以通过nrm 这个模块来方便快捷的切换不同的registry。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">  npm ---- https://registry.npmjs.org/</div><div class=\"line\">  cnpm --- http://r.cnpmjs.org/</div><div class=\"line\">* taobao - http://registry.npm.taobao.org/</div><div class=\"line\">  edunpm - http://registry.enpmjs.org/</div><div class=\"line\">  eu ----- http://registry.npmjs.eu/</div><div class=\"line\">  au ----- http://registry.npmjs.org.au/</div><div class=\"line\">  sl ----- http://npm.strongloop.com/</div><div class=\"line\">  nj ----- https://registry.nodejitsu.com/</div><div class=\"line\">  pt ----- http://registry.npmjs.pt/</div><div class=\"line\">  yzj ---- http://192.168.101.243:7001/</div></pre></td></tr></table></figure>\n<p>带星号的表示当前正在使用的 registry 。</p>\n<ul>\n<li>npm login </li>\n</ul>\n<blockquote>\n<p>npm login is an alias to adduser and behaves exactly the same way.</p>\n</blockquote>\n<ul>\n<li>npm publish </li>\n</ul>\n<p>提交模块到指定的 registry</p>\n<ul>\n<li>npm unpublish [&lt;@scope&gt;/]<pkg>[@<version>] [–force]</version></pkg></li>\n</ul>\n<p>删除服务器上的模块,可能有人想知道这里scope 具体使用方式,下面就简单介绍下好了。</p>\n<p>scope 就像命名空间一样,不过这个是用在npm 模块上的,如果一个模块以@开通那么他就是一个scope 模块。例如 <code>@scope/project-name</code> , 每一个npm 用户都有一个默认的scope,这个scope就是用户名, <code>@username/project-name</code> 。 怎么提交自己的模块到scope中呢?<br>其实比较简单,只要在 package.json 中name字段加上scope名就行,如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"@yzj/rn-component\"</span>,</div><div class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.1.1\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>安装的时候需要提供包括scope的模块名称,如 <code>npm install -S @yzj/rn-component</code> ,这样会在你 node_modules 目录出现 @yzj 目录。</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/npm-scope.png\" alt=\"npm scope\"></p>\n<p>可以在package.json 文件中看到具体的依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;dependencies&quot;: &#123;</div><div class=\"line\">    &quot;@yzj/rn-component&quot;: &quot;^0.1.1&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>scope 带来的好处,这样能够清楚的知道哪些模块是公共npm下载的,哪些是私有npm上的,如果哪天公共模块不能满足需求,我们在其基础之上改了代码,发布成同名的模块,我们最好在前面带个scope 这样能够很好很清晰的进行区分。</p>\n<ul>\n<li>npm owner add <user> [&lt;@scope&gt;/]<pkg></pkg></user></li>\n</ul>\n<p>给项目添加维护人员。如果一个模块有好几个人共同维护提交,那么就需要通过这个命令,添加共同维护人员。</p>\n<ul>\n<li>npm owner rm <user> [&lt;@scope&gt;/]<pkg></pkg></user></li>\n</ul>\n<p>看名字就是删除某个维护人员</p>\n<ul>\n<li>npm owner ls [&lt;@scope&gt;/]<pkg> </pkg></li>\n</ul>\n<p>列举出这个模块的所有维护人员。</p>\n<h2 id=\"Git-常用命令汇总\"><a href=\"#Git-常用命令汇总\" class=\"headerlink\" title=\"Git 常用命令汇总\"></a>Git 常用命令汇总</h2><p>如果我们在github上面看到一个好的项目,但是我们想改变其源码使其能够契合我们的业务场景,可以通过命令:</p>\n<p><code>git clone project-url [rename]</code> </p>\n<p>克隆远程仓库到本地。然后通过 <code>git pull</code> 同步远程最新内容到本地。这个时候往往我们处于本地的master分支上,如果你想看本地又多少分支,可以通过命令 <code>git branch</code> 查看,其中分支名前面带星号的是我们正处于的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">* master</div></pre></td></tr></table></figure>\n<p>如果你还想知道远程仓库有几个分支,可以通过命令 <code>git branch -a</code> 来查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">* master</div><div class=\"line\">  remotes/blog/master</div></pre></td></tr></table></figure>\n<p>如果这个时候,我们不想直接在master上修改代码,我们可以通过命令<code>git checkout  -b new_branch_name</code>从master创建分支 new_branch_name 并切换到这个分支上。当你修改完代码后,你可以通过命令<code>git status</code>看下我们有几个文件被修改,这些修改的内容有没有处于待提交状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">Changes not staged for commit:</div><div class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class=\"line\">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class=\"line\"></div><div class=\"line\">        modified:   .deploy_git (new commits)</div><div class=\"line\">        modified:   source/_posts/event-proxy.md</div><div class=\"line\">        modified:   source/_posts/fe-event-loop.md</div><div class=\"line\">        modified:   source/_posts/webpack1-to-webpack2.md</div><div class=\"line\">        modified:   themes/weekly/source/js/coupon.js</div><div class=\"line\">        modified:   themes/weekly/source/js/couponfs.js</div><div class=\"line\"></div><div class=\"line\">Untracked files:</div><div class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</div><div class=\"line\"></div><div class=\"line\">        public/</div><div class=\"line\">        source/_drafts/</div><div class=\"line\">        source/_posts/git-and-npm.md</div></pre></td></tr></table></figure>\n<p>可以看到有些文件虽然被修改了 但是还是处于untracked状态,那么我们可以通过<code>git add .</code> 命令一次将显示的所有untracked文件变成待提交状态。这个时候我们就可以通过<code>git commit -m &#39;msg&#39;</code> 来提交这次修改,如果我们想把这个分支也同步到远程仓库去就需要通过命令<code>git push origin new_branch_name</code> , 这样远程仓库就也有一个和本地一样的分支,团队中的其他成员就可以checkout,并在同一个分支上进行就改,如果不需要将这个分支push到远程仓库,那么你也可以通过<code>git checkout master</code> 先切换到master分支,然后通过命令 <code>git merge new_branch_name</code> 将分支内容合并到本地master 分支上,然后<code>git pull &amp;&amp; git add . &amp;&amp; git commit -m &#39;msg&#39; &amp;&amp; git push origin master</code> 将master新提交的内容同步到远程。然后通过命令 <code>git branch -d new_branch_name</code>删除本地分支。 当代码到达一个阶段趋于稳定后,我们就会进行一个发版,这个时候就需要给代码打一个tag,作为一个阶段节点,我们可以通过命令<code>git tag -a v1.1.4 -m &#39;版本更新内容&#39;</code> 新建一个tag,这个时候如果发现我们tag版本更新内容写错了,我们可以将刚刚建立的tag,删除掉,通过<code>git tag -d v1.1.4</code> 重新建一个,然后我们将tag标签push到远程仓库 <code>git push origin v1.1.4</code>。</p>\n<h2 id=\"Git-常见问题\"><a href=\"#Git-常见问题\" class=\"headerlink\" title=\"Git 常见问题\"></a>Git 常见问题</h2><ol>\n<li><p>如何删除远程仓库的一次错误提交 ?</p>\n<ul>\n<li><p>git reset commit-id </p>\n<p>  本地先切换到正确提交节点</p>\n</li>\n<li><p>git push origin -d branch-name / git push origin :branch-name </p>\n<p>  上面两种方式选一种删除远程分支</p>\n</li>\n<li><p>git push origin branch-name</p>\n<p>  将本地分支重新推送到远程</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>如何删除远程仓库的一次错误tag ?</p>\n<ul>\n<li><p>git tag -d <tagname> &amp;&amp; git push origin :refs/tags/<tagname></tagname></tagname></p>\n<p>  删除本地tag,然后推送一个空tag到远程,等同于删除远程tag</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>如何解决更新的时候因为本地有修改,不能成功更新的问题?</p>\n<ul>\n<li><p>git stash </p>\n<p>  暂存本地修改内容</p>\n</li>\n<li><p>git pull </p>\n<p>  拉取更新</p>\n</li>\n<li><p>git stash pop </p>\n<p>  弹出本地内容进行合并,如果有冲突则进行冲突解决</p>\n</li>\n</ul>\n</li>\n<li><p>如何从tag检出代码?</p>\n<ul>\n<li>git checkout -b branch_name tag_name</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://zengrong.net/post/1746.htm\" target=\"_blank\" rel=\"external\">http://zengrong.net/post/1746.htm</a></li>\n<li><a href=\"http://zengrong.net/post/1746.htm\" target=\"_blank\" rel=\"external\">http://zengrong.net/post/1746.htm</a></li>\n<li><a href=\"https://docs.npmjs.com/getting-started/scoped-packages\" target=\"_blank\" rel=\"external\">https://docs.npmjs.com/getting-started/scoped-packages</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>　　最近几个星期一直忙着公司各种业务,再加上王者农药简直不要太火,一不小心入坑了,所以记录中断了一阵。对于前端开发工程师来说工具中用的最多的莫过于 git 和 npm 了,随着做得业务越来越多,也封装了一些通用组件出来,为了能够更方便的在多个项目之间共享通用组件,也更好的对组件进行维护,所以在公司内部搭了一个私有的npm服务。具体如何搭建可以参考这篇文章:<a href=\"http://www.cnblogs.com/wyzfzu/p/4149310.html,在配置的过程中注意以下几点配置\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/wyzfzu/p/4149310.html,在配置的过程中注意以下几点配置</a>:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;  <span class=\"comment\">// default system admins</span></div><div class=\"line\">   admins: &#123;</div><div class=\"line\">     <span class=\"comment\">// name: email</span></div><div class=\"line\">     fengmk2: <span class=\"string\">'fengmk2@gmail.com'</span>,</div><div class=\"line\">     <span class=\"attr\">admin</span>: <span class=\"string\">'admin@cnpmjs.org'</span>,</div><div class=\"line\">     <span class=\"attr\">dead_horse</span>: <span class=\"string\">'dead_horse@qq.com'</span>,</div><div class=\"line\">   &#125;,</div><div class=\"line\">  <span class=\"comment\">// enable private mode or not</span></div><div class=\"line\">  <span class=\"comment\">// private mode: only admins can publish, other users just can sync package from source npm</span></div><div class=\"line\">  <span class=\"comment\">// public mode: all users can publish</span></div><div class=\"line\">  enablePrivate: <span class=\"literal\">false</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// registry scopes, if don't set, means do not support scopes</span></div><div class=\"line\">  scopes: [ <span class=\"string\">'@cnpm'</span>, <span class=\"string\">'@cnpmtest'</span>, <span class=\"string\">'@cnpm-test'</span> ],</div><div class=\"line\"> <span class=\"comment\">// if set true, will 302 redirect to `nfs.url(dist.key)`</span></div><div class=\"line\"> downloadRedirectToNFS: <span class=\"literal\">false</span>,</div><div class=\"line\"></div><div class=\"line\"> <span class=\"comment\">// registry url name</span></div><div class=\"line\"> registryHost: <span class=\"string\">'r.cnpmjs.org'</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你不允许其他人未经授权的情况下提交模块到私有npm服务器上,这里enablePrivate 就需要设置为false。此时只有在 admins 中列举的用户才能够提交模块到npm服务器上。如果你希望你上传的组件,模块团队成员其他人也能够下载安装,那么 downloadRedirectToNFS 你就需要设置为true,registryHost 也需要设置成你自己的地址如<code>http://192.168.1.6:7001</code> 上面的scope类似一个命名空间,这样在不同scope中同名的模块也不会出现冲突。</p>\n<p>　　搭好了服务器后,我们需要知道一些常用的 npm 命令,首先我们需要新建一个用户,然后登陆npm 服务才能进行提交模块。</p>\n<ul>\n<li>npm adduser</li>\n</ul>\n<p>创建用户,通常需要指定 registry, 如果不指定,采用默认的。我们可以通过nrm 这个模块来方便快捷的切换不同的registry。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">  npm ---- https://registry.npmjs.org/</div><div class=\"line\">  cnpm --- http://r.cnpmjs.org/</div><div class=\"line\">* taobao - http://registry.npm.taobao.org/</div><div class=\"line\">  edunpm - http://registry.enpmjs.org/</div><div class=\"line\">  eu ----- http://registry.npmjs.eu/</div><div class=\"line\">  au ----- http://registry.npmjs.org.au/</div><div class=\"line\">  sl ----- http://npm.strongloop.com/</div><div class=\"line\">  nj ----- https://registry.nodejitsu.com/</div><div class=\"line\">  pt ----- http://registry.npmjs.pt/</div><div class=\"line\">  yzj ---- http://192.168.101.243:7001/</div></pre></td></tr></table></figure>\n<p>带星号的表示当前正在使用的 registry 。</p>\n<ul>\n<li>npm login </li>\n</ul>\n<blockquote>\n<p>npm login is an alias to adduser and behaves exactly the same way.</p>\n</blockquote>\n<ul>\n<li>npm publish </li>\n</ul>\n<p>提交模块到指定的 registry</p>\n<ul>\n<li>npm unpublish [&lt;@scope&gt;/]<pkg>[@<version>] [–force]</version></pkg></li>\n</ul>\n<p>删除服务器上的模块,可能有人想知道这里scope 具体使用方式,下面就简单介绍下好了。</p>\n<p>scope 就像命名空间一样,不过这个是用在npm 模块上的,如果一个模块以@开通那么他就是一个scope 模块。例如 <code>@scope/project-name</code> , 每一个npm 用户都有一个默认的scope,这个scope就是用户名, <code>@username/project-name</code> 。 怎么提交自己的模块到scope中呢?<br>其实比较简单,只要在 package.json 中name字段加上scope名就行,如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"@yzj/rn-component\"</span>,</div><div class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.1.1\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>安装的时候需要提供包括scope的模块名称,如 <code>npm install -S @yzj/rn-component</code> ,这样会在你 node_modules 目录出现 @yzj 目录。</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/npm-scope.png\" alt=\"npm scope\"></p>\n<p>可以在package.json 文件中看到具体的依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;dependencies&quot;: &#123;</div><div class=\"line\">    &quot;@yzj/rn-component&quot;: &quot;^0.1.1&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>scope 带来的好处,这样能够清楚的知道哪些模块是公共npm下载的,哪些是私有npm上的,如果哪天公共模块不能满足需求,我们在其基础之上改了代码,发布成同名的模块,我们最好在前面带个scope 这样能够很好很清晰的进行区分。</p>\n<ul>\n<li>npm owner add <user> [&lt;@scope&gt;/]<pkg></pkg></user></li>\n</ul>\n<p>给项目添加维护人员。如果一个模块有好几个人共同维护提交,那么就需要通过这个命令,添加共同维护人员。</p>\n<ul>\n<li>npm owner rm <user> [&lt;@scope&gt;/]<pkg></pkg></user></li>\n</ul>\n<p>看名字就是删除某个维护人员</p>\n<ul>\n<li>npm owner ls [&lt;@scope&gt;/]<pkg> </pkg></li>\n</ul>\n<p>列举出这个模块的所有维护人员。</p>\n<h2 id=\"Git-常用命令汇总\"><a href=\"#Git-常用命令汇总\" class=\"headerlink\" title=\"Git 常用命令汇总\"></a>Git 常用命令汇总</h2><p>如果我们在github上面看到一个好的项目,但是我们想改变其源码使其能够契合我们的业务场景,可以通过命令:</p>\n<p><code>git clone project-url [rename]</code> </p>\n<p>克隆远程仓库到本地。然后通过 <code>git pull</code> 同步远程最新内容到本地。这个时候往往我们处于本地的master分支上,如果你想看本地又多少分支,可以通过命令 <code>git branch</code> 查看,其中分支名前面带星号的是我们正处于的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">* master</div></pre></td></tr></table></figure>\n<p>如果你还想知道远程仓库有几个分支,可以通过命令 <code>git branch -a</code> 来查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">* master</div><div class=\"line\">  remotes/blog/master</div></pre></td></tr></table></figure>\n<p>如果这个时候,我们不想直接在master上修改代码,我们可以通过命令<code>git checkout  -b new_branch_name</code>从master创建分支 new_branch_name 并切换到这个分支上。当你修改完代码后,你可以通过命令<code>git status</code>看下我们有几个文件被修改,这些修改的内容有没有处于待提交状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">Changes not staged for commit:</div><div class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</div><div class=\"line\">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</div><div class=\"line\"></div><div class=\"line\">        modified:   .deploy_git (new commits)</div><div class=\"line\">        modified:   source/_posts/event-proxy.md</div><div class=\"line\">        modified:   source/_posts/fe-event-loop.md</div><div class=\"line\">        modified:   source/_posts/webpack1-to-webpack2.md</div><div class=\"line\">        modified:   themes/weekly/source/js/coupon.js</div><div class=\"line\">        modified:   themes/weekly/source/js/couponfs.js</div><div class=\"line\"></div><div class=\"line\">Untracked files:</div><div class=\"line\">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</div><div class=\"line\"></div><div class=\"line\">        public/</div><div class=\"line\">        source/_drafts/</div><div class=\"line\">        source/_posts/git-and-npm.md</div></pre></td></tr></table></figure>\n<p>可以看到有些文件虽然被修改了 但是还是处于untracked状态,那么我们可以通过<code>git add .</code> 命令一次将显示的所有untracked文件变成待提交状态。这个时候我们就可以通过<code>git commit -m &#39;msg&#39;</code> 来提交这次修改,如果我们想把这个分支也同步到远程仓库去就需要通过命令<code>git push origin new_branch_name</code> , 这样远程仓库就也有一个和本地一样的分支,团队中的其他成员就可以checkout,并在同一个分支上进行就改,如果不需要将这个分支push到远程仓库,那么你也可以通过<code>git checkout master</code> 先切换到master分支,然后通过命令 <code>git merge new_branch_name</code> 将分支内容合并到本地master 分支上,然后<code>git pull &amp;&amp; git add . &amp;&amp; git commit -m &#39;msg&#39; &amp;&amp; git push origin master</code> 将master新提交的内容同步到远程。然后通过命令 <code>git branch -d new_branch_name</code>删除本地分支。 当代码到达一个阶段趋于稳定后,我们就会进行一个发版,这个时候就需要给代码打一个tag,作为一个阶段节点,我们可以通过命令<code>git tag -a v1.1.4 -m &#39;版本更新内容&#39;</code> 新建一个tag,这个时候如果发现我们tag版本更新内容写错了,我们可以将刚刚建立的tag,删除掉,通过<code>git tag -d v1.1.4</code> 重新建一个,然后我们将tag标签push到远程仓库 <code>git push origin v1.1.4</code>。</p>\n<h2 id=\"Git-常见问题\"><a href=\"#Git-常见问题\" class=\"headerlink\" title=\"Git 常见问题\"></a>Git 常见问题</h2><ol>\n<li><p>如何删除远程仓库的一次错误提交 ?</p>\n<ul>\n<li><p>git reset commit-id </p>\n<p>  本地先切换到正确提交节点</p>\n</li>\n<li><p>git push origin -d branch-name / git push origin :branch-name </p>\n<p>  上面两种方式选一种删除远程分支</p>\n</li>\n<li><p>git push origin branch-name</p>\n<p>  将本地分支重新推送到远程</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>如何删除远程仓库的一次错误tag ?</p>\n<ul>\n<li><p>git tag -d <tagname> &amp;&amp; git push origin :refs/tags/<tagname></tagname></tagname></p>\n<p>  删除本地tag,然后推送一个空tag到远程,等同于删除远程tag</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p>如何解决更新的时候因为本地有修改,不能成功更新的问题?</p>\n<ul>\n<li><p>git stash </p>\n<p>  暂存本地修改内容</p>\n</li>\n<li><p>git pull </p>\n<p>  拉取更新</p>\n</li>\n<li><p>git stash pop </p>\n<p>  弹出本地内容进行合并,如果有冲突则进行冲突解决</p>\n</li>\n</ul>\n</li>\n<li><p>如何从tag检出代码?</p>\n<ul>\n<li>git checkout -b branch_name tag_name</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://zengrong.net/post/1746.htm\" target=\"_blank\" rel=\"external\">http://zengrong.net/post/1746.htm</a></li>\n<li><a href=\"http://zengrong.net/post/1746.htm\" target=\"_blank\" rel=\"external\">http://zengrong.net/post/1746.htm</a></li>\n<li><a href=\"https://docs.npmjs.com/getting-started/scoped-packages\" target=\"_blank\" rel=\"external\">https://docs.npmjs.com/getting-started/scoped-packages</a></li>\n</ol>\n"},{"title":"gulp-prefix插件源码阅读","type":"original","date":"2017-04-26T08:08:56.000Z","description":null,"_content":"\n为什么会阅读这个插件的源码呢,因为在维护老项目的时候看到这个插件并没有给所有需要加前缀的url加上前缀,并因为ios需要支持https,而安卓客户端却不需要,为了能够自适应不同的客户端系统,则需要给url添加以双斜杠(``//``)开头的url,但是该插件却将双斜杠替换成了单斜杠,所以打算阅读下源代码看这个插件内部到底做了什么。\n\n先列出[gulp-prefix的源码](https://github.com/007design/gulp-prefix/blob/master/index.js)如下:\n\n```javascript\n'use strict';\nvar through = require('through2'),\n    url = require(\"url\"),\n    urljoin = require(\"url-join\"),\n    trumpet = require(\"trumpet\"),\n    concat  = require(\"concat-stream\"),\n    _prefixer;\n\n_prefixer = function(prefix, attr, invalid) {\n  return function(node) {\n    node.getAttribute(attr, function(uri) {\n\n      uri = url.parse(uri, false, true);\n\n      if(uri.host || !uri.path)\n        return;\n      \n      if (!/^[!#$&-;=?-\\[\\]_a-z~\\.\\/\\{\\}]+$/.test(uri.path)) {\n        return;\n      }\n\n      if (invalid && new RegExp(invalid).test(uri.path)){\n        return;\n      }\n\n      var file_prefix = (typeof prefix === 'function') ? prefix(uri) : prefix;\n\n      node.setAttribute(attr, urljoin(file_prefix, uri.path));\n    });\n  };\n};\n\nmodule.exports = function(prefix, selectors, ignore) {\n\n  return through.obj(function(file, enc, cb) {\n\n    if (!selectors) {\n      selectors = [\n      { match: \"script[src]\", attr: \"src\" },\n      { match: \"link[href]\", attr: \"href\"},\n      { match: \"img[src]\", attr: \"src\"},\n      { match: \"input[src]\", attr: \"src\"},\n      { match: \"img[data-ng-src]\", attr: \"data-ng-src\"}\n      ];\n    }\n    \n    if(!prefix)\n      cb(null, file);\n\n    else {\n      var tr = trumpet();\n      \n      for (var a in selectors)\n        tr.selectAll(selectors[a].match, _prefixer(prefix, selectors[a].attr, ignore))\n\n      tr.pipe(concat(function (data) {\n        if (Array.isArray(data) && data.length === 0) data = null;\n        file.contents = data;\n        cb(null, file);\n      }));\n\n      file.pipe(tr);\n    } \n  });\n};\n```\n\n代码的开头是依赖模块的引入和一些变量的定义,这个插件主要依赖了``url``,``though2``,``url-join``,``trumpet``,``concat-stream``等模块。\n\n* [url](https://nodejs.org/api/url.html) 模块\n\n  > url模块是node内置模块,用来对url进行解析处理并生成由url各个部分组成的解析结果对象。\n  \n* [though2](https://github.com/rvagg/through2)\n\n  > 用来生成transform stream。 具体stream的一些概念参看[Node Stream初窥](/node/node-stream.md),though2的具体使用参看文档。\n  \n* [url-join](https://github.com/jfromaniello/url-join/blob/master/lib/url-join.js)\n  \n  > 作用将url的各个部分链接起来,形成合法的url。\n  \n* [trumpet](https://github.com/substack/node-trumpet)\n  \n  > 使用css 选择器解析处理stream 形式的html。\n  \n  ```javascript\n  //使用方法\n  var trumpet = require('trumpet');\n  //Create a new trumpet stream. This stream is readable and writable. Pipe an html stream into tr and get back a transformed html stream.\n  var tr = trumpet(); \n  \n  //将html 可读流和tr链接\n  var fs = require('fs');\n  fs.createReadStream(__dirname + '/html/read_all.html').pipe(tr);\n  //将产生的transformed html stream,选择其中满足css selector,创建一个可读流链接到输出流\n  //这里如果span.createReadStream() 不加任何参数的话,默认取得是标签内的内容,不带标签,如果要获取到完整的html片段,则需要调用时增加选项参数{outer:true}\n  tr.selectAll('.b span', function (span) {\n        span.createReadStream().pipe(process.stdout);\n  });\n\n  ```\n* [concat-stream](https://github.com/maxogden/concat-stream)\n  \n  > 从名字可以猜这个模块应该是用来连接什么的,文档介绍说如果你有将stream中的所有buffer连接成一个buffer,然后再进行处理的需求的话,那么这个模块就是你想要的,由于stream的特性,导致每次得到的数据只是一个chunk buffer,所以有时你需要得到全部的数据你才能进行某些操作,那么就可以通过这个模块到达想要的结果。\n  \n  ```\n  //使用例子\n  var fs = require('fs')\n  var concat = require('concat-stream')\n  \n  function gotPicture(imageBuffer) {\n    // imageBuffer is all of `cat.png` as a node.js Buffer\n  }\n  \n  function handleError(err) {\n    // handle your error appropriately here, e.g.:\n    console.error(err) // print the error to STDERR\n    process.exit(1) // exit program with non-zero exit code\n  }\n  \n  var readStream = fs.createReadStream('cat.png')\n  var concatStream = concat(gotPicture)\n  \n  readStream.on('error', handleError)\n  readStream.pipe(concatStream)\n  ```\n\n在了解了上面gulp-prefix所依赖的插件后,我们就可以开始看这个插件到底做了什么事情了。首先看``module.exports``,导出一个函数这个函数可以接受三个参数:\n* prefix\n\n  > 字符串或者用于生成url前缀的函数。\n   \n* selectors\n\n  > 对象数组,需要被替换的html标签,以及标签属性。具体格式如下:\n  \n  ```javascript\n  [\n    { match: \"script[src]\", attr: \"src\" },\n    { match: \"link[href]\", attr: \"href\"},\n    { match: \"img[src]\", attr: \"src\"},\n    { match: \"input[src]\", attr: \"src\"},\n    { match: \"img[data-ng-src]\", attr: \"data-ng-src\"}\n  ]\n  ```\n  \n* ignore\n \n > 要被过滤的路径,new Regex(ignore).test(path) 为true的话,则不进行添加前缀操作。\n \n\n再来看这段代码:\n\n```javascript\nif(!prefix)\n  cb(null, file);\n\nelse {\n  var tr = trumpet();\n  \n  for (var a in selectors)\n    tr.selectAll(selectors[a].match, _prefixer(prefix, selectors[a].attr, ignore))\n\n  tr.pipe(concat(function (data) {\n    if (Array.isArray(data) && data.length === 0) data = null;\n    file.contents = data;\n    cb(null, file);\n  }));\n\n  file.pipe(tr);\n} \n```\n对prefix进行判断,如果为空,则将file交给下一个插件进行处理,如果不为空,则进行如下处理,创建tr,用于和file链接,遍历selectors,然后选择匹配选择器的元素交由_prefixer的方法进行处理,这个方法会返回一个回调函数,这个回调函数的参数node就是匹配选择器的元素。然后在将tr处理后的file流向concat创建的流,当整个文件处理完,调用传入concat的回调,然后设置file内容为处理后的内容,流向下个插件。\n\n其中_prefixer,是真正修改url的地方,我们看下代码内容:\n\n```javascript\nfunction(prefix, attr, invalid) {\n  return function(node) {\n    node.getAttribute(attr, function(uri) {\n\n      uri = url.parse(uri, false, true);\n\n      if(uri.host || !uri.path)\n        return;\n      \n      if (!/^[!#$&-;=?-\\[\\]_a-z~\\.\\/\\{\\}]+$/.test(uri.path)) {\n        return;\n      }\n\n      if (invalid && new RegExp(invalid).test(uri.path)){\n        return;\n      }\n\n      var file_prefix = (typeof prefix === 'function') ? prefix(uri) : prefix;\n\n      node.setAttribute(attr, urljoin(file_prefix, uri.path));\n    });\n  };\n};\n\n```\n\n从代码中看出返回的回调函数,从node中取出attr属性值(url路径),然后通过url模块进行解析,url.parse的参数含义参考文档[url.parse](https://nodejs.org/api/url.html#url_url_parse_urlstring_parsequerystring_slashesdenotehost),最后一个参数设置为true,考虑了路径为双斜杠开头的情况,那么后面// 到 /之间的值就是host了。如果存在host或者path不存在,则认为这种情况不需要添加前缀了。如果是合法path则接下去进行处理,如果path匹配ignore(invalid),则不处理,最后进行前缀添加,如果prefix是函数,执行函数并返回file_prefix文件前缀。然后通过url-join模块合并前缀和path,重新设置node(节点)的属性值。\n\n当读到这里的时候,发现img标签中的data-lazyload-src没有被加前缀的原因是默认的selectors中没有对应的selector,添加后修复了这个问题。但是双斜杠的问题还是存在,从整个代码来看,最可能出问题的地方就是urljoin这里了,后来看了url-join模块的源码,才发现gulp-prefix用的是很早的版本,从package.json中可以看出:\n\n```javascript\n \"dependencies\": {\n    \"through2\": \"~1.0.0\",\n    \"url\": \"~0.10.1\",\n    \"trumpet\": \"~1.7.0\",\n    \"concat-stream\": \"~1.4.5\",\n    \"url-join\": \"0.0.1\" //这里版本为0.0.1,现在已经是v1.1.0\n}\n```\n\n0.0.1版本的url-join源代码如下:\n\n```javascript\nfunction normalize (str) {\n  return str\n          .replace(/[\\/]+/g, '/')\n          .replace(/\\/\\?/g, '?')\n          .replace(/\\/\\#/g, '#')\n          .replace(/\\:\\//g, '://');\n}\n\nmodule.exports = function () {\n  var joined = [].slice.call(arguments, 0).join('/');\n  return normalize(joined);\n};\n```\n很明显这个地方将双斜杠给替换成了单斜杠,给作者提了pull request,作者并没有鸟,尝试自己升级了url-join最后解决了双斜杠被删成单斜杠的问题。\n\n### gulp-prefix 可以改进的地方\n* selectors 参数格式,数组的话作者并没有增量合并,而是需要自己枚举所有情况。\n* url-join 在package.json中写死了版本,导致双斜杠变单斜杠的问题。\n\n查了一波MIT证书的限制,对于MIT证书来说,只要用户在项目副本中包含了版权声明和许可声明,你可以拿这个代码做任何事情。所以决定对代码略作修改使其更好的用在自己的平常构建任务中。改造后重命名为``gulp-prefix-url``,并写了测试用例进行测试。插件的GitHub地址为:https://github.com/xdimh/gulp-prefix-url。 \n\n\n### 参考\n\n1. [各种 License](https://segmentfault.com/a/1190000002397061)\n2. [choosealicense](https://choosealicense.com/)","source":"_posts/gulp-prefix.md","raw":"---\ntitle: gulp-prefix插件源码阅读\ntype: original\ntags: [前端大杂烩]\ncategories: [前端大杂烩]\ndate: 2017-04-26 16:08:56\ndescription:\n---\n\n为什么会阅读这个插件的源码呢,因为在维护老项目的时候看到这个插件并没有给所有需要加前缀的url加上前缀,并因为ios需要支持https,而安卓客户端却不需要,为了能够自适应不同的客户端系统,则需要给url添加以双斜杠(``//``)开头的url,但是该插件却将双斜杠替换成了单斜杠,所以打算阅读下源代码看这个插件内部到底做了什么。\n\n先列出[gulp-prefix的源码](https://github.com/007design/gulp-prefix/blob/master/index.js)如下:\n\n```javascript\n'use strict';\nvar through = require('through2'),\n    url = require(\"url\"),\n    urljoin = require(\"url-join\"),\n    trumpet = require(\"trumpet\"),\n    concat  = require(\"concat-stream\"),\n    _prefixer;\n\n_prefixer = function(prefix, attr, invalid) {\n  return function(node) {\n    node.getAttribute(attr, function(uri) {\n\n      uri = url.parse(uri, false, true);\n\n      if(uri.host || !uri.path)\n        return;\n      \n      if (!/^[!#$&-;=?-\\[\\]_a-z~\\.\\/\\{\\}]+$/.test(uri.path)) {\n        return;\n      }\n\n      if (invalid && new RegExp(invalid).test(uri.path)){\n        return;\n      }\n\n      var file_prefix = (typeof prefix === 'function') ? prefix(uri) : prefix;\n\n      node.setAttribute(attr, urljoin(file_prefix, uri.path));\n    });\n  };\n};\n\nmodule.exports = function(prefix, selectors, ignore) {\n\n  return through.obj(function(file, enc, cb) {\n\n    if (!selectors) {\n      selectors = [\n      { match: \"script[src]\", attr: \"src\" },\n      { match: \"link[href]\", attr: \"href\"},\n      { match: \"img[src]\", attr: \"src\"},\n      { match: \"input[src]\", attr: \"src\"},\n      { match: \"img[data-ng-src]\", attr: \"data-ng-src\"}\n      ];\n    }\n    \n    if(!prefix)\n      cb(null, file);\n\n    else {\n      var tr = trumpet();\n      \n      for (var a in selectors)\n        tr.selectAll(selectors[a].match, _prefixer(prefix, selectors[a].attr, ignore))\n\n      tr.pipe(concat(function (data) {\n        if (Array.isArray(data) && data.length === 0) data = null;\n        file.contents = data;\n        cb(null, file);\n      }));\n\n      file.pipe(tr);\n    } \n  });\n};\n```\n\n代码的开头是依赖模块的引入和一些变量的定义,这个插件主要依赖了``url``,``though2``,``url-join``,``trumpet``,``concat-stream``等模块。\n\n* [url](https://nodejs.org/api/url.html) 模块\n\n  > url模块是node内置模块,用来对url进行解析处理并生成由url各个部分组成的解析结果对象。\n  \n* [though2](https://github.com/rvagg/through2)\n\n  > 用来生成transform stream。 具体stream的一些概念参看[Node Stream初窥](/node/node-stream.md),though2的具体使用参看文档。\n  \n* [url-join](https://github.com/jfromaniello/url-join/blob/master/lib/url-join.js)\n  \n  > 作用将url的各个部分链接起来,形成合法的url。\n  \n* [trumpet](https://github.com/substack/node-trumpet)\n  \n  > 使用css 选择器解析处理stream 形式的html。\n  \n  ```javascript\n  //使用方法\n  var trumpet = require('trumpet');\n  //Create a new trumpet stream. This stream is readable and writable. Pipe an html stream into tr and get back a transformed html stream.\n  var tr = trumpet(); \n  \n  //将html 可读流和tr链接\n  var fs = require('fs');\n  fs.createReadStream(__dirname + '/html/read_all.html').pipe(tr);\n  //将产生的transformed html stream,选择其中满足css selector,创建一个可读流链接到输出流\n  //这里如果span.createReadStream() 不加任何参数的话,默认取得是标签内的内容,不带标签,如果要获取到完整的html片段,则需要调用时增加选项参数{outer:true}\n  tr.selectAll('.b span', function (span) {\n        span.createReadStream().pipe(process.stdout);\n  });\n\n  ```\n* [concat-stream](https://github.com/maxogden/concat-stream)\n  \n  > 从名字可以猜这个模块应该是用来连接什么的,文档介绍说如果你有将stream中的所有buffer连接成一个buffer,然后再进行处理的需求的话,那么这个模块就是你想要的,由于stream的特性,导致每次得到的数据只是一个chunk buffer,所以有时你需要得到全部的数据你才能进行某些操作,那么就可以通过这个模块到达想要的结果。\n  \n  ```\n  //使用例子\n  var fs = require('fs')\n  var concat = require('concat-stream')\n  \n  function gotPicture(imageBuffer) {\n    // imageBuffer is all of `cat.png` as a node.js Buffer\n  }\n  \n  function handleError(err) {\n    // handle your error appropriately here, e.g.:\n    console.error(err) // print the error to STDERR\n    process.exit(1) // exit program with non-zero exit code\n  }\n  \n  var readStream = fs.createReadStream('cat.png')\n  var concatStream = concat(gotPicture)\n  \n  readStream.on('error', handleError)\n  readStream.pipe(concatStream)\n  ```\n\n在了解了上面gulp-prefix所依赖的插件后,我们就可以开始看这个插件到底做了什么事情了。首先看``module.exports``,导出一个函数这个函数可以接受三个参数:\n* prefix\n\n  > 字符串或者用于生成url前缀的函数。\n   \n* selectors\n\n  > 对象数组,需要被替换的html标签,以及标签属性。具体格式如下:\n  \n  ```javascript\n  [\n    { match: \"script[src]\", attr: \"src\" },\n    { match: \"link[href]\", attr: \"href\"},\n    { match: \"img[src]\", attr: \"src\"},\n    { match: \"input[src]\", attr: \"src\"},\n    { match: \"img[data-ng-src]\", attr: \"data-ng-src\"}\n  ]\n  ```\n  \n* ignore\n \n > 要被过滤的路径,new Regex(ignore).test(path) 为true的话,则不进行添加前缀操作。\n \n\n再来看这段代码:\n\n```javascript\nif(!prefix)\n  cb(null, file);\n\nelse {\n  var tr = trumpet();\n  \n  for (var a in selectors)\n    tr.selectAll(selectors[a].match, _prefixer(prefix, selectors[a].attr, ignore))\n\n  tr.pipe(concat(function (data) {\n    if (Array.isArray(data) && data.length === 0) data = null;\n    file.contents = data;\n    cb(null, file);\n  }));\n\n  file.pipe(tr);\n} \n```\n对prefix进行判断,如果为空,则将file交给下一个插件进行处理,如果不为空,则进行如下处理,创建tr,用于和file链接,遍历selectors,然后选择匹配选择器的元素交由_prefixer的方法进行处理,这个方法会返回一个回调函数,这个回调函数的参数node就是匹配选择器的元素。然后在将tr处理后的file流向concat创建的流,当整个文件处理完,调用传入concat的回调,然后设置file内容为处理后的内容,流向下个插件。\n\n其中_prefixer,是真正修改url的地方,我们看下代码内容:\n\n```javascript\nfunction(prefix, attr, invalid) {\n  return function(node) {\n    node.getAttribute(attr, function(uri) {\n\n      uri = url.parse(uri, false, true);\n\n      if(uri.host || !uri.path)\n        return;\n      \n      if (!/^[!#$&-;=?-\\[\\]_a-z~\\.\\/\\{\\}]+$/.test(uri.path)) {\n        return;\n      }\n\n      if (invalid && new RegExp(invalid).test(uri.path)){\n        return;\n      }\n\n      var file_prefix = (typeof prefix === 'function') ? prefix(uri) : prefix;\n\n      node.setAttribute(attr, urljoin(file_prefix, uri.path));\n    });\n  };\n};\n\n```\n\n从代码中看出返回的回调函数,从node中取出attr属性值(url路径),然后通过url模块进行解析,url.parse的参数含义参考文档[url.parse](https://nodejs.org/api/url.html#url_url_parse_urlstring_parsequerystring_slashesdenotehost),最后一个参数设置为true,考虑了路径为双斜杠开头的情况,那么后面// 到 /之间的值就是host了。如果存在host或者path不存在,则认为这种情况不需要添加前缀了。如果是合法path则接下去进行处理,如果path匹配ignore(invalid),则不处理,最后进行前缀添加,如果prefix是函数,执行函数并返回file_prefix文件前缀。然后通过url-join模块合并前缀和path,重新设置node(节点)的属性值。\n\n当读到这里的时候,发现img标签中的data-lazyload-src没有被加前缀的原因是默认的selectors中没有对应的selector,添加后修复了这个问题。但是双斜杠的问题还是存在,从整个代码来看,最可能出问题的地方就是urljoin这里了,后来看了url-join模块的源码,才发现gulp-prefix用的是很早的版本,从package.json中可以看出:\n\n```javascript\n \"dependencies\": {\n    \"through2\": \"~1.0.0\",\n    \"url\": \"~0.10.1\",\n    \"trumpet\": \"~1.7.0\",\n    \"concat-stream\": \"~1.4.5\",\n    \"url-join\": \"0.0.1\" //这里版本为0.0.1,现在已经是v1.1.0\n}\n```\n\n0.0.1版本的url-join源代码如下:\n\n```javascript\nfunction normalize (str) {\n  return str\n          .replace(/[\\/]+/g, '/')\n          .replace(/\\/\\?/g, '?')\n          .replace(/\\/\\#/g, '#')\n          .replace(/\\:\\//g, '://');\n}\n\nmodule.exports = function () {\n  var joined = [].slice.call(arguments, 0).join('/');\n  return normalize(joined);\n};\n```\n很明显这个地方将双斜杠给替换成了单斜杠,给作者提了pull request,作者并没有鸟,尝试自己升级了url-join最后解决了双斜杠被删成单斜杠的问题。\n\n### gulp-prefix 可以改进的地方\n* selectors 参数格式,数组的话作者并没有增量合并,而是需要自己枚举所有情况。\n* url-join 在package.json中写死了版本,导致双斜杠变单斜杠的问题。\n\n查了一波MIT证书的限制,对于MIT证书来说,只要用户在项目副本中包含了版权声明和许可声明,你可以拿这个代码做任何事情。所以决定对代码略作修改使其更好的用在自己的平常构建任务中。改造后重命名为``gulp-prefix-url``,并写了测试用例进行测试。插件的GitHub地址为:https://github.com/xdimh/gulp-prefix-url。 \n\n\n### 参考\n\n1. [各种 License](https://segmentfault.com/a/1190000002397061)\n2. [choosealicense](https://choosealicense.com/)","slug":"gulp-prefix","published":1,"updated":"2017-05-03T05:53:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhpv000ab37qc875w4xm","content":"<p>为什么会阅读这个插件的源码呢,因为在维护老项目的时候看到这个插件并没有给所有需要加前缀的url加上前缀,并因为ios需要支持https,而安卓客户端却不需要,为了能够自适应不同的客户端系统,则需要给url添加以双斜杠(<code>//</code>)开头的url,但是该插件却将双斜杠替换成了单斜杠,所以打算阅读下源代码看这个插件内部到底做了什么。</p>\n<p>先列出<a href=\"https://github.com/007design/gulp-prefix/blob/master/index.js\" target=\"_blank\" rel=\"external\">gulp-prefix的源码</a>如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> through = <span class=\"built_in\">require</span>(<span class=\"string\">'through2'</span>),</div><div class=\"line\">    url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>),</div><div class=\"line\">    urljoin = <span class=\"built_in\">require</span>(<span class=\"string\">\"url-join\"</span>),</div><div class=\"line\">    trumpet = <span class=\"built_in\">require</span>(<span class=\"string\">\"trumpet\"</span>),</div><div class=\"line\">    concat  = <span class=\"built_in\">require</span>(<span class=\"string\">\"concat-stream\"</span>),</div><div class=\"line\">    _prefixer;</div><div class=\"line\"></div><div class=\"line\">_prefixer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prefix, attr, invalid</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    node.getAttribute(attr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">uri</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">      uri = url.parse(uri, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(uri.host || !uri.path)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"regexp\">/^[!#$&amp;-;=?-\\[\\]_a-z~\\.\\/\\&#123;\\&#125;]+$/</span>.test(uri.path)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (invalid &amp;&amp; <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(invalid).test(uri.path))&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">var</span> file_prefix = (<span class=\"keyword\">typeof</span> prefix === <span class=\"string\">'function'</span>) ? prefix(uri) : prefix;</div><div class=\"line\"></div><div class=\"line\">      node.setAttribute(attr, urljoin(file_prefix, uri.path));</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prefix, selectors, ignore</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> through.obj(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file, enc, cb</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!selectors) &#123;</div><div class=\"line\">      selectors = [</div><div class=\"line\">      &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"script[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"link[href]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"href\"</span>&#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"img[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span>&#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"input[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span>&#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"img[data-ng-src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"data-ng-src\"</span>&#125;</div><div class=\"line\">      ];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span>(!prefix)</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, file);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> tr = trumpet();</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a <span class=\"keyword\">in</span> selectors)</div><div class=\"line\">        tr.selectAll(selectors[a].match, _prefixer(prefix, selectors[a].attr, ignore))</div><div class=\"line\"></div><div class=\"line\">      tr.pipe(concat(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(data) &amp;&amp; data.length === <span class=\"number\">0</span>) data = <span class=\"literal\">null</span>;</div><div class=\"line\">        file.contents = data;</div><div class=\"line\">        cb(<span class=\"literal\">null</span>, file);</div><div class=\"line\">      &#125;));</div><div class=\"line\"></div><div class=\"line\">      file.pipe(tr);</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>代码的开头是依赖模块的引入和一些变量的定义,这个插件主要依赖了<code>url</code>,<code>though2</code>,<code>url-join</code>,<code>trumpet</code>,<code>concat-stream</code>等模块。</p>\n<ul>\n<li><p><a href=\"https://nodejs.org/api/url.html\" target=\"_blank\" rel=\"external\">url</a> 模块</p>\n<blockquote>\n<p>url模块是node内置模块,用来对url进行解析处理并生成由url各个部分组成的解析结果对象。</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://github.com/rvagg/through2\" target=\"_blank\" rel=\"external\">though2</a></p>\n<blockquote>\n<p>用来生成transform stream。 具体stream的一些概念参看<a href=\"/node/node-stream.md\">Node Stream初窥</a>,though2的具体使用参看文档。</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://github.com/jfromaniello/url-join/blob/master/lib/url-join.js\" target=\"_blank\" rel=\"external\">url-join</a></p>\n<blockquote>\n<p>作用将url的各个部分链接起来,形成合法的url。</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://github.com/substack/node-trumpet\" target=\"_blank\" rel=\"external\">trumpet</a></p>\n<blockquote>\n<p>使用css 选择器解析处理stream 形式的html。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> trumpet = <span class=\"built_in\">require</span>(<span class=\"string\">'trumpet'</span>);</div><div class=\"line\"><span class=\"comment\">//Create a new trumpet stream. This stream is readable and writable. Pipe an html stream into tr and get back a transformed html stream.</span></div><div class=\"line\"><span class=\"keyword\">var</span> tr = trumpet(); </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//将html 可读流和tr链接</span></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.createReadStream(__dirname + <span class=\"string\">'/html/read_all.html'</span>).pipe(tr);</div><div class=\"line\"><span class=\"comment\">//将产生的transformed html stream,选择其中满足css selector,创建一个可读流链接到输出流</span></div><div class=\"line\"><span class=\"comment\">//这里如果span.createReadStream() 不加任何参数的话,默认取得是标签内的内容,不带标签,如果要获取到完整的html片段,则需要调用时增加选项参数&#123;outer:true&#125;</span></div><div class=\"line\">tr.selectAll(<span class=\"string\">'.b span'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">span</span>) </span>&#123;</div><div class=\"line\">      span.createReadStream().pipe(process.stdout);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://github.com/maxogden/concat-stream\" target=\"_blank\" rel=\"external\">concat-stream</a></p>\n<blockquote>\n<p>从名字可以猜这个模块应该是用来连接什么的,文档介绍说如果你有将stream中的所有buffer连接成一个buffer,然后再进行处理的需求的话,那么这个模块就是你想要的,由于stream的特性,导致每次得到的数据只是一个chunk buffer,所以有时你需要得到全部的数据你才能进行某些操作,那么就可以通过这个模块到达想要的结果。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//使用例子</div><div class=\"line\">var fs = require(&apos;fs&apos;)</div><div class=\"line\">var concat = require(&apos;concat-stream&apos;)</div><div class=\"line\"></div><div class=\"line\">function gotPicture(imageBuffer) &#123;</div><div class=\"line\">  // imageBuffer is all of `cat.png` as a node.js Buffer</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function handleError(err) &#123;</div><div class=\"line\">  // handle your error appropriately here, e.g.:</div><div class=\"line\">  console.error(err) // print the error to STDERR</div><div class=\"line\">  process.exit(1) // exit program with non-zero exit code</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var readStream = fs.createReadStream(&apos;cat.png&apos;)</div><div class=\"line\">var concatStream = concat(gotPicture)</div><div class=\"line\"></div><div class=\"line\">readStream.on(&apos;error&apos;, handleError)</div><div class=\"line\">readStream.pipe(concatStream)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在了解了上面gulp-prefix所依赖的插件后,我们就可以开始看这个插件到底做了什么事情了。首先看<code>module.exports</code>,导出一个函数这个函数可以接受三个参数:</p>\n<ul>\n<li><p>prefix</p>\n<blockquote>\n<p>字符串或者用于生成url前缀的函数。</p>\n</blockquote>\n</li>\n<li><p>selectors</p>\n<blockquote>\n<p>对象数组,需要被替换的html标签,以及标签属性。具体格式如下:</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"script[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"link[href]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"href\"</span>&#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"img[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span>&#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"input[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span>&#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"img[data-ng-src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"data-ng-src\"</span>&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>ignore</p>\n<blockquote>\n<p>要被过滤的路径,new Regex(ignore).test(path) 为true的话,则不进行添加前缀操作。</p>\n</blockquote>\n</li>\n</ul>\n<p>再来看这段代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(!prefix)</div><div class=\"line\">  cb(<span class=\"literal\">null</span>, file);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> tr = trumpet();</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a <span class=\"keyword\">in</span> selectors)</div><div class=\"line\">    tr.selectAll(selectors[a].match, _prefixer(prefix, selectors[a].attr, ignore))</div><div class=\"line\"></div><div class=\"line\">  tr.pipe(concat(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(data) &amp;&amp; data.length === <span class=\"number\">0</span>) data = <span class=\"literal\">null</span>;</div><div class=\"line\">    file.contents = data;</div><div class=\"line\">    cb(<span class=\"literal\">null</span>, file);</div><div class=\"line\">  &#125;));</div><div class=\"line\"></div><div class=\"line\">  file.pipe(tr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对prefix进行判断,如果为空,则将file交给下一个插件进行处理,如果不为空,则进行如下处理,创建tr,用于和file链接,遍历selectors,然后选择匹配选择器的元素交由_prefixer的方法进行处理,这个方法会返回一个回调函数,这个回调函数的参数node就是匹配选择器的元素。然后在将tr处理后的file流向concat创建的流,当整个文件处理完,调用传入concat的回调,然后设置file内容为处理后的内容,流向下个插件。</p>\n<p>其中_prefixer,是真正修改url的地方,我们看下代码内容:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prefix, attr, invalid</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    node.getAttribute(attr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">uri</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">      uri = url.parse(uri, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(uri.host || !uri.path)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"regexp\">/^[!#$&amp;-;=?-\\[\\]_a-z~\\.\\/\\&#123;\\&#125;]+$/</span>.test(uri.path)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (invalid &amp;&amp; <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(invalid).test(uri.path))&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">var</span> file_prefix = (<span class=\"keyword\">typeof</span> prefix === <span class=\"string\">'function'</span>) ? prefix(uri) : prefix;</div><div class=\"line\"></div><div class=\"line\">      node.setAttribute(attr, urljoin(file_prefix, uri.path));</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>从代码中看出返回的回调函数,从node中取出attr属性值(url路径),然后通过url模块进行解析,url.parse的参数含义参考文档<a href=\"https://nodejs.org/api/url.html#url_url_parse_urlstring_parsequerystring_slashesdenotehost\" target=\"_blank\" rel=\"external\">url.parse</a>,最后一个参数设置为true,考虑了路径为双斜杠开头的情况,那么后面// 到 /之间的值就是host了。如果存在host或者path不存在,则认为这种情况不需要添加前缀了。如果是合法path则接下去进行处理,如果path匹配ignore(invalid),则不处理,最后进行前缀添加,如果prefix是函数,执行函数并返回file_prefix文件前缀。然后通过url-join模块合并前缀和path,重新设置node(节点)的属性值。</p>\n<p>当读到这里的时候,发现img标签中的data-lazyload-src没有被加前缀的原因是默认的selectors中没有对应的selector,添加后修复了这个问题。但是双斜杠的问题还是存在,从整个代码来看,最可能出问题的地方就是urljoin这里了,后来看了url-join模块的源码,才发现gulp-prefix用的是很早的版本,从package.json中可以看出:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"string\">\"dependencies\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"through2\"</span>: <span class=\"string\">\"~1.0.0\"</span>,</div><div class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"~0.10.1\"</span>,</div><div class=\"line\">    <span class=\"string\">\"trumpet\"</span>: <span class=\"string\">\"~1.7.0\"</span>,</div><div class=\"line\">    <span class=\"string\">\"concat-stream\"</span>: <span class=\"string\">\"~1.4.5\"</span>,</div><div class=\"line\">    <span class=\"string\">\"url-join\"</span>: <span class=\"string\">\"0.0.1\"</span> <span class=\"comment\">//这里版本为0.0.1,现在已经是v1.1.0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>0.0.1版本的url-join源代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalize</span> (<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> str</div><div class=\"line\">          .replace(<span class=\"regexp\">/[\\/]+/g</span>, <span class=\"string\">'/'</span>)</div><div class=\"line\">          .replace(<span class=\"regexp\">/\\/\\?/g</span>, <span class=\"string\">'?'</span>)</div><div class=\"line\">          .replace(<span class=\"regexp\">/\\/\\#/g</span>, <span class=\"string\">'#'</span>)</div><div class=\"line\">          .replace(<span class=\"regexp\">/\\:\\//g</span>, <span class=\"string\">'://'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> joined = [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>).join(<span class=\"string\">'/'</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> normalize(joined);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>很明显这个地方将双斜杠给替换成了单斜杠,给作者提了pull request,作者并没有鸟,尝试自己升级了url-join最后解决了双斜杠被删成单斜杠的问题。</p>\n<h3 id=\"gulp-prefix-可以改进的地方\"><a href=\"#gulp-prefix-可以改进的地方\" class=\"headerlink\" title=\"gulp-prefix 可以改进的地方\"></a>gulp-prefix 可以改进的地方</h3><ul>\n<li>selectors 参数格式,数组的话作者并没有增量合并,而是需要自己枚举所有情况。</li>\n<li>url-join 在package.json中写死了版本,导致双斜杠变单斜杠的问题。</li>\n</ul>\n<p>查了一波MIT证书的限制,对于MIT证书来说,只要用户在项目副本中包含了版权声明和许可声明,你可以拿这个代码做任何事情。所以决定对代码略作修改使其更好的用在自己的平常构建任务中。改造后重命名为<code>gulp-prefix-url</code>,并写了测试用例进行测试。插件的GitHub地址为:<a href=\"https://github.com/xdimh/gulp-prefix-url。\" target=\"_blank\" rel=\"external\">https://github.com/xdimh/gulp-prefix-url。</a> </p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000002397061\" target=\"_blank\" rel=\"external\">各种 License</a></li>\n<li><a href=\"https://choosealicense.com/\" target=\"_blank\" rel=\"external\">choosealicense</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>为什么会阅读这个插件的源码呢,因为在维护老项目的时候看到这个插件并没有给所有需要加前缀的url加上前缀,并因为ios需要支持https,而安卓客户端却不需要,为了能够自适应不同的客户端系统,则需要给url添加以双斜杠(<code>//</code>)开头的url,但是该插件却将双斜杠替换成了单斜杠,所以打算阅读下源代码看这个插件内部到底做了什么。</p>\n<p>先列出<a href=\"https://github.com/007design/gulp-prefix/blob/master/index.js\" target=\"_blank\" rel=\"external\">gulp-prefix的源码</a>如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> through = <span class=\"built_in\">require</span>(<span class=\"string\">'through2'</span>),</div><div class=\"line\">    url = <span class=\"built_in\">require</span>(<span class=\"string\">\"url\"</span>),</div><div class=\"line\">    urljoin = <span class=\"built_in\">require</span>(<span class=\"string\">\"url-join\"</span>),</div><div class=\"line\">    trumpet = <span class=\"built_in\">require</span>(<span class=\"string\">\"trumpet\"</span>),</div><div class=\"line\">    concat  = <span class=\"built_in\">require</span>(<span class=\"string\">\"concat-stream\"</span>),</div><div class=\"line\">    _prefixer;</div><div class=\"line\"></div><div class=\"line\">_prefixer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prefix, attr, invalid</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    node.getAttribute(attr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">uri</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">      uri = url.parse(uri, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(uri.host || !uri.path)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"regexp\">/^[!#$&amp;-;=?-\\[\\]_a-z~\\.\\/\\&#123;\\&#125;]+$/</span>.test(uri.path)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (invalid &amp;&amp; <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(invalid).test(uri.path))&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">var</span> file_prefix = (<span class=\"keyword\">typeof</span> prefix === <span class=\"string\">'function'</span>) ? prefix(uri) : prefix;</div><div class=\"line\"></div><div class=\"line\">      node.setAttribute(attr, urljoin(file_prefix, uri.path));</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prefix, selectors, ignore</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> through.obj(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file, enc, cb</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!selectors) &#123;</div><div class=\"line\">      selectors = [</div><div class=\"line\">      &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"script[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span> &#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"link[href]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"href\"</span>&#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"img[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span>&#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"input[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span>&#125;,</div><div class=\"line\">      &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"img[data-ng-src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"data-ng-src\"</span>&#125;</div><div class=\"line\">      ];</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span>(!prefix)</div><div class=\"line\">      cb(<span class=\"literal\">null</span>, file);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> tr = trumpet();</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a <span class=\"keyword\">in</span> selectors)</div><div class=\"line\">        tr.selectAll(selectors[a].match, _prefixer(prefix, selectors[a].attr, ignore))</div><div class=\"line\"></div><div class=\"line\">      tr.pipe(concat(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(data) &amp;&amp; data.length === <span class=\"number\">0</span>) data = <span class=\"literal\">null</span>;</div><div class=\"line\">        file.contents = data;</div><div class=\"line\">        cb(<span class=\"literal\">null</span>, file);</div><div class=\"line\">      &#125;));</div><div class=\"line\"></div><div class=\"line\">      file.pipe(tr);</div><div class=\"line\">    &#125; </div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>代码的开头是依赖模块的引入和一些变量的定义,这个插件主要依赖了<code>url</code>,<code>though2</code>,<code>url-join</code>,<code>trumpet</code>,<code>concat-stream</code>等模块。</p>\n<ul>\n<li><p><a href=\"https://nodejs.org/api/url.html\" target=\"_blank\" rel=\"external\">url</a> 模块</p>\n<blockquote>\n<p>url模块是node内置模块,用来对url进行解析处理并生成由url各个部分组成的解析结果对象。</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://github.com/rvagg/through2\" target=\"_blank\" rel=\"external\">though2</a></p>\n<blockquote>\n<p>用来生成transform stream。 具体stream的一些概念参看<a href=\"/node/node-stream.md\">Node Stream初窥</a>,though2的具体使用参看文档。</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://github.com/jfromaniello/url-join/blob/master/lib/url-join.js\" target=\"_blank\" rel=\"external\">url-join</a></p>\n<blockquote>\n<p>作用将url的各个部分链接起来,形成合法的url。</p>\n</blockquote>\n</li>\n<li><p><a href=\"https://github.com/substack/node-trumpet\" target=\"_blank\" rel=\"external\">trumpet</a></p>\n<blockquote>\n<p>使用css 选择器解析处理stream 形式的html。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> trumpet = <span class=\"built_in\">require</span>(<span class=\"string\">'trumpet'</span>);</div><div class=\"line\"><span class=\"comment\">//Create a new trumpet stream. This stream is readable and writable. Pipe an html stream into tr and get back a transformed html stream.</span></div><div class=\"line\"><span class=\"keyword\">var</span> tr = trumpet(); </div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//将html 可读流和tr链接</span></div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\">fs.createReadStream(__dirname + <span class=\"string\">'/html/read_all.html'</span>).pipe(tr);</div><div class=\"line\"><span class=\"comment\">//将产生的transformed html stream,选择其中满足css selector,创建一个可读流链接到输出流</span></div><div class=\"line\"><span class=\"comment\">//这里如果span.createReadStream() 不加任何参数的话,默认取得是标签内的内容,不带标签,如果要获取到完整的html片段,则需要调用时增加选项参数&#123;outer:true&#125;</span></div><div class=\"line\">tr.selectAll(<span class=\"string\">'.b span'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">span</span>) </span>&#123;</div><div class=\"line\">      span.createReadStream().pipe(process.stdout);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://github.com/maxogden/concat-stream\" target=\"_blank\" rel=\"external\">concat-stream</a></p>\n<blockquote>\n<p>从名字可以猜这个模块应该是用来连接什么的,文档介绍说如果你有将stream中的所有buffer连接成一个buffer,然后再进行处理的需求的话,那么这个模块就是你想要的,由于stream的特性,导致每次得到的数据只是一个chunk buffer,所以有时你需要得到全部的数据你才能进行某些操作,那么就可以通过这个模块到达想要的结果。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//使用例子</div><div class=\"line\">var fs = require(&apos;fs&apos;)</div><div class=\"line\">var concat = require(&apos;concat-stream&apos;)</div><div class=\"line\"></div><div class=\"line\">function gotPicture(imageBuffer) &#123;</div><div class=\"line\">  // imageBuffer is all of `cat.png` as a node.js Buffer</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function handleError(err) &#123;</div><div class=\"line\">  // handle your error appropriately here, e.g.:</div><div class=\"line\">  console.error(err) // print the error to STDERR</div><div class=\"line\">  process.exit(1) // exit program with non-zero exit code</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var readStream = fs.createReadStream(&apos;cat.png&apos;)</div><div class=\"line\">var concatStream = concat(gotPicture)</div><div class=\"line\"></div><div class=\"line\">readStream.on(&apos;error&apos;, handleError)</div><div class=\"line\">readStream.pipe(concatStream)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在了解了上面gulp-prefix所依赖的插件后,我们就可以开始看这个插件到底做了什么事情了。首先看<code>module.exports</code>,导出一个函数这个函数可以接受三个参数:</p>\n<ul>\n<li><p>prefix</p>\n<blockquote>\n<p>字符串或者用于生成url前缀的函数。</p>\n</blockquote>\n</li>\n<li><p>selectors</p>\n<blockquote>\n<p>对象数组,需要被替换的html标签,以及标签属性。具体格式如下:</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">  &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"script[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span> &#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"link[href]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"href\"</span>&#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"img[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span>&#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"input[src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"src\"</span>&#125;,</div><div class=\"line\">  &#123; <span class=\"attr\">match</span>: <span class=\"string\">\"img[data-ng-src]\"</span>, <span class=\"attr\">attr</span>: <span class=\"string\">\"data-ng-src\"</span>&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>ignore</p>\n<blockquote>\n<p>要被过滤的路径,new Regex(ignore).test(path) 为true的话,则不进行添加前缀操作。</p>\n</blockquote>\n</li>\n</ul>\n<p>再来看这段代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(!prefix)</div><div class=\"line\">  cb(<span class=\"literal\">null</span>, file);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> tr = trumpet();</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a <span class=\"keyword\">in</span> selectors)</div><div class=\"line\">    tr.selectAll(selectors[a].match, _prefixer(prefix, selectors[a].attr, ignore))</div><div class=\"line\"></div><div class=\"line\">  tr.pipe(concat(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(data) &amp;&amp; data.length === <span class=\"number\">0</span>) data = <span class=\"literal\">null</span>;</div><div class=\"line\">    file.contents = data;</div><div class=\"line\">    cb(<span class=\"literal\">null</span>, file);</div><div class=\"line\">  &#125;));</div><div class=\"line\"></div><div class=\"line\">  file.pipe(tr);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对prefix进行判断,如果为空,则将file交给下一个插件进行处理,如果不为空,则进行如下处理,创建tr,用于和file链接,遍历selectors,然后选择匹配选择器的元素交由_prefixer的方法进行处理,这个方法会返回一个回调函数,这个回调函数的参数node就是匹配选择器的元素。然后在将tr处理后的file流向concat创建的流,当整个文件处理完,调用传入concat的回调,然后设置file内容为处理后的内容,流向下个插件。</p>\n<p>其中_prefixer,是真正修改url的地方,我们看下代码内容:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prefix, attr, invalid</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</div><div class=\"line\">    node.getAttribute(attr, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">uri</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">      uri = url.parse(uri, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span>(uri.host || !uri.path)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      </div><div class=\"line\">      <span class=\"keyword\">if</span> (!<span class=\"regexp\">/^[!#$&amp;-;=?-\\[\\]_a-z~\\.\\/\\&#123;\\&#125;]+$/</span>.test(uri.path)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (invalid &amp;&amp; <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(invalid).test(uri.path))&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">var</span> file_prefix = (<span class=\"keyword\">typeof</span> prefix === <span class=\"string\">'function'</span>) ? prefix(uri) : prefix;</div><div class=\"line\"></div><div class=\"line\">      node.setAttribute(attr, urljoin(file_prefix, uri.path));</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>从代码中看出返回的回调函数,从node中取出attr属性值(url路径),然后通过url模块进行解析,url.parse的参数含义参考文档<a href=\"https://nodejs.org/api/url.html#url_url_parse_urlstring_parsequerystring_slashesdenotehost\" target=\"_blank\" rel=\"external\">url.parse</a>,最后一个参数设置为true,考虑了路径为双斜杠开头的情况,那么后面// 到 /之间的值就是host了。如果存在host或者path不存在,则认为这种情况不需要添加前缀了。如果是合法path则接下去进行处理,如果path匹配ignore(invalid),则不处理,最后进行前缀添加,如果prefix是函数,执行函数并返回file_prefix文件前缀。然后通过url-join模块合并前缀和path,重新设置node(节点)的属性值。</p>\n<p>当读到这里的时候,发现img标签中的data-lazyload-src没有被加前缀的原因是默认的selectors中没有对应的selector,添加后修复了这个问题。但是双斜杠的问题还是存在,从整个代码来看,最可能出问题的地方就是urljoin这里了,后来看了url-join模块的源码,才发现gulp-prefix用的是很早的版本,从package.json中可以看出:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"string\">\"dependencies\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"through2\"</span>: <span class=\"string\">\"~1.0.0\"</span>,</div><div class=\"line\">    <span class=\"string\">\"url\"</span>: <span class=\"string\">\"~0.10.1\"</span>,</div><div class=\"line\">    <span class=\"string\">\"trumpet\"</span>: <span class=\"string\">\"~1.7.0\"</span>,</div><div class=\"line\">    <span class=\"string\">\"concat-stream\"</span>: <span class=\"string\">\"~1.4.5\"</span>,</div><div class=\"line\">    <span class=\"string\">\"url-join\"</span>: <span class=\"string\">\"0.0.1\"</span> <span class=\"comment\">//这里版本为0.0.1,现在已经是v1.1.0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>0.0.1版本的url-join源代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalize</span> (<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> str</div><div class=\"line\">          .replace(<span class=\"regexp\">/[\\/]+/g</span>, <span class=\"string\">'/'</span>)</div><div class=\"line\">          .replace(<span class=\"regexp\">/\\/\\?/g</span>, <span class=\"string\">'?'</span>)</div><div class=\"line\">          .replace(<span class=\"regexp\">/\\/\\#/g</span>, <span class=\"string\">'#'</span>)</div><div class=\"line\">          .replace(<span class=\"regexp\">/\\:\\//g</span>, <span class=\"string\">'://'</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> joined = [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>).join(<span class=\"string\">'/'</span>);</div><div class=\"line\">  <span class=\"keyword\">return</span> normalize(joined);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>很明显这个地方将双斜杠给替换成了单斜杠,给作者提了pull request,作者并没有鸟,尝试自己升级了url-join最后解决了双斜杠被删成单斜杠的问题。</p>\n<h3 id=\"gulp-prefix-可以改进的地方\"><a href=\"#gulp-prefix-可以改进的地方\" class=\"headerlink\" title=\"gulp-prefix 可以改进的地方\"></a>gulp-prefix 可以改进的地方</h3><ul>\n<li>selectors 参数格式,数组的话作者并没有增量合并,而是需要自己枚举所有情况。</li>\n<li>url-join 在package.json中写死了版本,导致双斜杠变单斜杠的问题。</li>\n</ul>\n<p>查了一波MIT证书的限制,对于MIT证书来说,只要用户在项目副本中包含了版权声明和许可声明,你可以拿这个代码做任何事情。所以决定对代码略作修改使其更好的用在自己的平常构建任务中。改造后重命名为<code>gulp-prefix-url</code>,并写了测试用例进行测试。插件的GitHub地址为:<a href=\"https://github.com/xdimh/gulp-prefix-url。\" target=\"_blank\" rel=\"external\">https://github.com/xdimh/gulp-prefix-url。</a> </p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000002397061\" target=\"_blank\" rel=\"external\">各种 License</a></li>\n<li><a href=\"https://choosealicense.com/\" target=\"_blank\" rel=\"external\">choosealicense</a></li>\n</ol>\n"},{"title":"gulp 插件开发","type":"original","date":"2017-04-26T08:15:31.000Z","description":null,"_content":"\n最近在做老代码的迁移,说实话真是蛋都要碎了。老代码用过的技术栈简直快包含整个前端的技术了,有dom操作库,``kissy``,``zepto``,现在盛行的MVVM框架``vue``,``react``,较早的模块管理``requirejs``,还有现在常用的打包工具``gulp``,``webpack``,这个项目简直就是一个前端技术的练兵场。不仅如此,源代码和线上代码不一致,代码仓库中并没有一份最新的代码。除此之外,打包配置文件写法真的是有点非主流,很多地方需要手动配置。其中用到的gulp插件数量也是没得说的,在梳理老代码构建打包任务时,有些地方并不是特别明白到底做了些什么,比如:\n\n```javascript\n return gulp.src(config[dist].views + '/*.*')\n      .pipe(LinkRemove())\n      .pipe(gulp.dest(config[dist].views));\n```\n 其中``LinkRemove``,这个东西到底对源代码干了什么,作者并没有很清晰的给出,所以只能去看看这个gulp插件到底做了什么,却发现这个插件是作者自己写的,并没有上传到npm上,局面一度很尴尬,找到源代码,并没有很好的注释说明这是干什么的,可能作者觉得自己的代码即注释吧,虽然代码的确挺短的,但是我看到了这些:\n \n ```javascript\n'use strict';\nvar through = require('through2'),\n    fs = require('fs'),\n    trumpet = require(\"trumpet\"),\n    concat = require(\"concat-stream\"); \n    \nmodule.exports = function() {\n    return through.obj(function(file, enc, cb) {\n        //todo something\n    });\n}\n```\n局面再度尴尬起来,``through2``是什么,``trumpet``,``concat-stream``又是干嘛'屎'的。然后就涉及到了gulp插件的开发,如果不了解gulp插件的原理,是不可能搞懂那些没有注释文档的自己开发的插件功能的。``gulp``又是一个基于流的构建工具,打开[插件编写文档](http://www.gulpjs.com.cn/docs/writing-a-plugin/),看到了这些关键词``Buffer``,``Stream``,``vinyl File object``,``though``,``transform stream``。如果你不了解这些那么也就不能很好的理解读懂别人写的插件源码或者编写自己的gulp插件。所以我们从Node Stream开始看起,毕竟gulp是基于流的一个工具。\n\n### Node Stream \n\n``gulp``是一个基于流的构建工具,将各个处理流链接起来达到前端构建的目的,使得前端构建能够实现自动化,自动的完成那些耗时费力又非常重要的构建任务,从而提高了整个开发的效率。那么什么是流呢,流又给gulp带来和别的构建工具哪些不一样呢? 对于什么是流参看[Node Stream 初窥](https://weekly.js.org/node/node-stream.html),相比之前流行的前端构建工具grunt来说:\n  1. gulp可以使你将不同的任务通过流的方式链接起来,比如css预处理,css url中的链接修改, css合并压缩等任务,你只需在最开始输入要处理的文件,在最后输出的就是你需要的处理完成的文件。\n  2. 每个任务,每个插件都是处理其中一部分处理,非常符合单一职责的原则。\n  3. 其次gulp任务编写更加符合大家的习惯,和写正常的逻辑代码别无一二。\n\n看完Stream,来来看看Buffer,毕竟很多插件是只处理Buffer数据的。\n\n### Node Buffer \n\n在Node.js中Buffer是一个可以在任何模块中被利用的全局类,可以通过以下方式创建buffer对象。\n\n1. 通过构造函数指定buffer大小创建buffer对象\n   \n   ```javascript\n   var buffer =  new Buffer(size);\n   ```\n2. 通过传入数组创建buffer对象\n    \n   ```javascript\n   var buffer = new Buffer(array);\n   // eg: var buffer = new Buffer([1,2,3]);\n   ```\n3. 通过传入字符串创建Buffer对象\n    \n   ```javascript\n   var buffer = new Buffer(string,[encoding]);\n   //encoding 参数可选,默认编码方式为'utf8'\n   ```\n\nBuffer对象可以通过toString方法转成字符串,toString方法有三个参数分别是encoding,start,end。``buffer.toString([encoding],[start],[end])``。\n\n更多关于Buffer的内容可以参看node的文档,下面来看下在gulp中非常重要的一直virtual file format。\n\n### [vinyl](https://github.com/gulpjs/vinyl)\nvinyl是一种虚拟文件的格式,用来描述一个文件的简单元数据对象, 对一个文件我们能想到的就是文件的路径和文件内容,这些都是vinyl 对象的主要的属性。那么这个和gulp有什么联系,其实gulp就是一个Vinyl Adapter,一个Vinyl Adapter需要提供src(globs) 和 dest(folder)方法,每个方法都返回对应的stream,src 返回的Stream 会产生Vinyl对象,用于后续使用,如gulp的插件。而dest会使用这些对象,并生成文件到指定的目录。\n\n#### vinyl 对像方法\n\n1. ``file.isBuffer()``\n\n    > 判断文件内容是否是Buffer格式的,如果是返回true,反之返回false。\n\n2. ``file.isStream()``\n    \n    > 判断文件内容是否是stream形式的,如果是返回true,反之返回false.\n\n3. ``file.isNull()``\n\n    > 判断文件内容是否为空。如果是返回true,反之返回false.\n     \n更多的对象方法[参看github上的文档](https://github.com/gulpjs/vinyl)。\n \n #### vinyl 对象的属性\n \n 1. ``file.cwd``\n \n    > 当前工作目录,最后的斜杠会被删除,通过``file.cwd = newCwd`` 可以设置新的值。\n    \n 2. ``file.base``\n    \n    > 文件基础目录。值应该等于``path.dirname(file.path)``\n\n 3. ``file.path``\n    \n    > 文件的绝对路径。\n    \n 4. ``file.relative``\n    \n    > 文件的相对路径,值等于``path.resolve(file.base,file.path)``\n    \n 更多属性[参看github上的文档](https://github.com/gulpjs/vinyl)。\n \n### [vinyl-fs](https://github.com/gulpjs/vinyl-fs)\n\nvinyl-fs 是 vinyl adapter, 具体使用可以参考[github上的文档](https://github.com/gulpjs/vinyl-fs)。一些gulp插件中会使用到这个vinyl adapter。\n\n\n### [though2](https://github.com/rvagg/through2)\n\nthough2 是Node ``streams.Transform `` 的一个简单的包装,更方便大家去创建transform流。 对于gulp插件总是会返回一个 object mode 形式的 tranform stream 来做这些事情。所以though2在插件中用的很频繁,简直就是标配。通过though2创建对象模式的transform方式如下:\n\n```javascript\n//method-1 :\nconst though2 = require('though2');\nthough2({objectMode: true},function(chunk,enc,cb) {\n    //todo something \n},[flushFunction]);\n//method-2 :\nthough2.obj(function(chunk,enc,cb) {\n   //todo something\n},[flushFunction]);\n```\n\n基于though2,有人写了[though-gulp](https://github.com/bornkiller/through-gulp),使得编写gulp插件变得更加简单。\n\n\n### gulp 插件编写\ngulp插件的基本代码架子如下:\n\n```javascript\n// PLUGIN_NAME: sample\nvar through = require('through-gulp');\n\n// exporting the plugin \nmodule.exports = sample;\n\nfunction sample() {\n  // creating a stream through which each file will pass\n  var stream = through(function(file, encoding,callback) {\n  \t// do whatever necessary to process the file\n  \t// 这里file为vinyl对象。\n    if (file.isNull()) {\n        // 如果file的内容为空 \n    }\n    if (file.isBuffer()) {\n        // 如果file的内容为Buffer\n    }\n    if (file.isStream()) {\n        // 如果file的内容为stream\n    }\n    // just pipe data next, or just do nothing to process file later in flushFunction\n    // never forget callback to indicate that the file has been processed.\n      //确保文件进入下一个 gulp 插件\n      this.push(file);\n      //告诉 stream 引擎，我们已经处理完了这个文件\n      callback();\n      //上面两行等价于 callback(null,file);\n    }, function(callback) {\n      // just pipe data next, just callback to indicate that the stream's over\n      //由下一个gulp执行\n      this.push(something);\n      callback(); //告诉 stream 引擎，我们已经处理完了\n    });\n\n  // returning the file stream\n  return stream;\n};\n```\n你需要做的是根据的自己的需求,编写相应的逻辑代码。我们可以看下一些插件的源码,这里以gulp-prefix举个例子,具体源码解读可以参看[gulp-prefix插件源码阅读](/2017/04/26/gulp-prefix)\n\n\n### gulp 插件测试\n\n可以参看[gulp 测试](http://www.gulpjs.com.cn/docs/writing-a-plugin/testing/) 在写测试之前,需要了解mocha 测试框架和chai 或者 shoud.js断言库。\n\n\n","source":"_posts/gulp-plugin-develop.md","raw":"---\ntitle: gulp 插件开发\ntype: original\ntags: [前端大杂烩]\ncategories: [前端大杂烩]\ndate: 2017-04-26 16:15:31\ndescription:\n---\n\n最近在做老代码的迁移,说实话真是蛋都要碎了。老代码用过的技术栈简直快包含整个前端的技术了,有dom操作库,``kissy``,``zepto``,现在盛行的MVVM框架``vue``,``react``,较早的模块管理``requirejs``,还有现在常用的打包工具``gulp``,``webpack``,这个项目简直就是一个前端技术的练兵场。不仅如此,源代码和线上代码不一致,代码仓库中并没有一份最新的代码。除此之外,打包配置文件写法真的是有点非主流,很多地方需要手动配置。其中用到的gulp插件数量也是没得说的,在梳理老代码构建打包任务时,有些地方并不是特别明白到底做了些什么,比如:\n\n```javascript\n return gulp.src(config[dist].views + '/*.*')\n      .pipe(LinkRemove())\n      .pipe(gulp.dest(config[dist].views));\n```\n 其中``LinkRemove``,这个东西到底对源代码干了什么,作者并没有很清晰的给出,所以只能去看看这个gulp插件到底做了什么,却发现这个插件是作者自己写的,并没有上传到npm上,局面一度很尴尬,找到源代码,并没有很好的注释说明这是干什么的,可能作者觉得自己的代码即注释吧,虽然代码的确挺短的,但是我看到了这些:\n \n ```javascript\n'use strict';\nvar through = require('through2'),\n    fs = require('fs'),\n    trumpet = require(\"trumpet\"),\n    concat = require(\"concat-stream\"); \n    \nmodule.exports = function() {\n    return through.obj(function(file, enc, cb) {\n        //todo something\n    });\n}\n```\n局面再度尴尬起来,``through2``是什么,``trumpet``,``concat-stream``又是干嘛'屎'的。然后就涉及到了gulp插件的开发,如果不了解gulp插件的原理,是不可能搞懂那些没有注释文档的自己开发的插件功能的。``gulp``又是一个基于流的构建工具,打开[插件编写文档](http://www.gulpjs.com.cn/docs/writing-a-plugin/),看到了这些关键词``Buffer``,``Stream``,``vinyl File object``,``though``,``transform stream``。如果你不了解这些那么也就不能很好的理解读懂别人写的插件源码或者编写自己的gulp插件。所以我们从Node Stream开始看起,毕竟gulp是基于流的一个工具。\n\n### Node Stream \n\n``gulp``是一个基于流的构建工具,将各个处理流链接起来达到前端构建的目的,使得前端构建能够实现自动化,自动的完成那些耗时费力又非常重要的构建任务,从而提高了整个开发的效率。那么什么是流呢,流又给gulp带来和别的构建工具哪些不一样呢? 对于什么是流参看[Node Stream 初窥](https://weekly.js.org/node/node-stream.html),相比之前流行的前端构建工具grunt来说:\n  1. gulp可以使你将不同的任务通过流的方式链接起来,比如css预处理,css url中的链接修改, css合并压缩等任务,你只需在最开始输入要处理的文件,在最后输出的就是你需要的处理完成的文件。\n  2. 每个任务,每个插件都是处理其中一部分处理,非常符合单一职责的原则。\n  3. 其次gulp任务编写更加符合大家的习惯,和写正常的逻辑代码别无一二。\n\n看完Stream,来来看看Buffer,毕竟很多插件是只处理Buffer数据的。\n\n### Node Buffer \n\n在Node.js中Buffer是一个可以在任何模块中被利用的全局类,可以通过以下方式创建buffer对象。\n\n1. 通过构造函数指定buffer大小创建buffer对象\n   \n   ```javascript\n   var buffer =  new Buffer(size);\n   ```\n2. 通过传入数组创建buffer对象\n    \n   ```javascript\n   var buffer = new Buffer(array);\n   // eg: var buffer = new Buffer([1,2,3]);\n   ```\n3. 通过传入字符串创建Buffer对象\n    \n   ```javascript\n   var buffer = new Buffer(string,[encoding]);\n   //encoding 参数可选,默认编码方式为'utf8'\n   ```\n\nBuffer对象可以通过toString方法转成字符串,toString方法有三个参数分别是encoding,start,end。``buffer.toString([encoding],[start],[end])``。\n\n更多关于Buffer的内容可以参看node的文档,下面来看下在gulp中非常重要的一直virtual file format。\n\n### [vinyl](https://github.com/gulpjs/vinyl)\nvinyl是一种虚拟文件的格式,用来描述一个文件的简单元数据对象, 对一个文件我们能想到的就是文件的路径和文件内容,这些都是vinyl 对象的主要的属性。那么这个和gulp有什么联系,其实gulp就是一个Vinyl Adapter,一个Vinyl Adapter需要提供src(globs) 和 dest(folder)方法,每个方法都返回对应的stream,src 返回的Stream 会产生Vinyl对象,用于后续使用,如gulp的插件。而dest会使用这些对象,并生成文件到指定的目录。\n\n#### vinyl 对像方法\n\n1. ``file.isBuffer()``\n\n    > 判断文件内容是否是Buffer格式的,如果是返回true,反之返回false。\n\n2. ``file.isStream()``\n    \n    > 判断文件内容是否是stream形式的,如果是返回true,反之返回false.\n\n3. ``file.isNull()``\n\n    > 判断文件内容是否为空。如果是返回true,反之返回false.\n     \n更多的对象方法[参看github上的文档](https://github.com/gulpjs/vinyl)。\n \n #### vinyl 对象的属性\n \n 1. ``file.cwd``\n \n    > 当前工作目录,最后的斜杠会被删除,通过``file.cwd = newCwd`` 可以设置新的值。\n    \n 2. ``file.base``\n    \n    > 文件基础目录。值应该等于``path.dirname(file.path)``\n\n 3. ``file.path``\n    \n    > 文件的绝对路径。\n    \n 4. ``file.relative``\n    \n    > 文件的相对路径,值等于``path.resolve(file.base,file.path)``\n    \n 更多属性[参看github上的文档](https://github.com/gulpjs/vinyl)。\n \n### [vinyl-fs](https://github.com/gulpjs/vinyl-fs)\n\nvinyl-fs 是 vinyl adapter, 具体使用可以参考[github上的文档](https://github.com/gulpjs/vinyl-fs)。一些gulp插件中会使用到这个vinyl adapter。\n\n\n### [though2](https://github.com/rvagg/through2)\n\nthough2 是Node ``streams.Transform `` 的一个简单的包装,更方便大家去创建transform流。 对于gulp插件总是会返回一个 object mode 形式的 tranform stream 来做这些事情。所以though2在插件中用的很频繁,简直就是标配。通过though2创建对象模式的transform方式如下:\n\n```javascript\n//method-1 :\nconst though2 = require('though2');\nthough2({objectMode: true},function(chunk,enc,cb) {\n    //todo something \n},[flushFunction]);\n//method-2 :\nthough2.obj(function(chunk,enc,cb) {\n   //todo something\n},[flushFunction]);\n```\n\n基于though2,有人写了[though-gulp](https://github.com/bornkiller/through-gulp),使得编写gulp插件变得更加简单。\n\n\n### gulp 插件编写\ngulp插件的基本代码架子如下:\n\n```javascript\n// PLUGIN_NAME: sample\nvar through = require('through-gulp');\n\n// exporting the plugin \nmodule.exports = sample;\n\nfunction sample() {\n  // creating a stream through which each file will pass\n  var stream = through(function(file, encoding,callback) {\n  \t// do whatever necessary to process the file\n  \t// 这里file为vinyl对象。\n    if (file.isNull()) {\n        // 如果file的内容为空 \n    }\n    if (file.isBuffer()) {\n        // 如果file的内容为Buffer\n    }\n    if (file.isStream()) {\n        // 如果file的内容为stream\n    }\n    // just pipe data next, or just do nothing to process file later in flushFunction\n    // never forget callback to indicate that the file has been processed.\n      //确保文件进入下一个 gulp 插件\n      this.push(file);\n      //告诉 stream 引擎，我们已经处理完了这个文件\n      callback();\n      //上面两行等价于 callback(null,file);\n    }, function(callback) {\n      // just pipe data next, just callback to indicate that the stream's over\n      //由下一个gulp执行\n      this.push(something);\n      callback(); //告诉 stream 引擎，我们已经处理完了\n    });\n\n  // returning the file stream\n  return stream;\n};\n```\n你需要做的是根据的自己的需求,编写相应的逻辑代码。我们可以看下一些插件的源码,这里以gulp-prefix举个例子,具体源码解读可以参看[gulp-prefix插件源码阅读](/2017/04/26/gulp-prefix)\n\n\n### gulp 插件测试\n\n可以参看[gulp 测试](http://www.gulpjs.com.cn/docs/writing-a-plugin/testing/) 在写测试之前,需要了解mocha 测试框架和chai 或者 shoud.js断言库。\n\n\n","slug":"gulp-plugin-develop","published":1,"updated":"2017-05-03T05:53:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhq2000bb37q7avld1ce","content":"<p>最近在做老代码的迁移,说实话真是蛋都要碎了。老代码用过的技术栈简直快包含整个前端的技术了,有dom操作库,<code>kissy</code>,<code>zepto</code>,现在盛行的MVVM框架<code>vue</code>,<code>react</code>,较早的模块管理<code>requirejs</code>,还有现在常用的打包工具<code>gulp</code>,<code>webpack</code>,这个项目简直就是一个前端技术的练兵场。不仅如此,源代码和线上代码不一致,代码仓库中并没有一份最新的代码。除此之外,打包配置文件写法真的是有点非主流,很多地方需要手动配置。其中用到的gulp插件数量也是没得说的,在梳理老代码构建打包任务时,有些地方并不是特别明白到底做了些什么,比如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> gulp.src(config[dist].views + <span class=\"string\">'/*.*'</span>)</div><div class=\"line\">     .pipe(LinkRemove())</div><div class=\"line\">     .pipe(gulp.dest(config[dist].views));</div></pre></td></tr></table></figure>\n<p> 其中<code>LinkRemove</code>,这个东西到底对源代码干了什么,作者并没有很清晰的给出,所以只能去看看这个gulp插件到底做了什么,却发现这个插件是作者自己写的,并没有上传到npm上,局面一度很尴尬,找到源代码,并没有很好的注释说明这是干什么的,可能作者觉得自己的代码即注释吧,虽然代码的确挺短的,但是我看到了这些:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> through = <span class=\"built_in\">require</span>(<span class=\"string\">'through2'</span>),</div><div class=\"line\">    fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>),</div><div class=\"line\">    trumpet = <span class=\"built_in\">require</span>(<span class=\"string\">\"trumpet\"</span>),</div><div class=\"line\">    concat = <span class=\"built_in\">require</span>(<span class=\"string\">\"concat-stream\"</span>); </div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> through.obj(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file, enc, cb</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//todo something</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>局面再度尴尬起来,<code>through2</code>是什么,<code>trumpet</code>,<code>concat-stream</code>又是干嘛’屎’的。然后就涉及到了gulp插件的开发,如果不了解gulp插件的原理,是不可能搞懂那些没有注释文档的自己开发的插件功能的。<code>gulp</code>又是一个基于流的构建工具,打开<a href=\"http://www.gulpjs.com.cn/docs/writing-a-plugin/\" target=\"_blank\" rel=\"external\">插件编写文档</a>,看到了这些关键词<code>Buffer</code>,<code>Stream</code>,<code>vinyl File object</code>,<code>though</code>,<code>transform stream</code>。如果你不了解这些那么也就不能很好的理解读懂别人写的插件源码或者编写自己的gulp插件。所以我们从Node Stream开始看起,毕竟gulp是基于流的一个工具。</p>\n<h3 id=\"Node-Stream\"><a href=\"#Node-Stream\" class=\"headerlink\" title=\"Node Stream\"></a>Node Stream</h3><p><code>gulp</code>是一个基于流的构建工具,将各个处理流链接起来达到前端构建的目的,使得前端构建能够实现自动化,自动的完成那些耗时费力又非常重要的构建任务,从而提高了整个开发的效率。那么什么是流呢,流又给gulp带来和别的构建工具哪些不一样呢? 对于什么是流参看<a href=\"https://weekly.js.org/node/node-stream.html\" target=\"_blank\" rel=\"external\">Node Stream 初窥</a>,相比之前流行的前端构建工具grunt来说:</p>\n<ol>\n<li>gulp可以使你将不同的任务通过流的方式链接起来,比如css预处理,css url中的链接修改, css合并压缩等任务,你只需在最开始输入要处理的文件,在最后输出的就是你需要的处理完成的文件。</li>\n<li>每个任务,每个插件都是处理其中一部分处理,非常符合单一职责的原则。</li>\n<li>其次gulp任务编写更加符合大家的习惯,和写正常的逻辑代码别无一二。</li>\n</ol>\n<p>看完Stream,来来看看Buffer,毕竟很多插件是只处理Buffer数据的。</p>\n<h3 id=\"Node-Buffer\"><a href=\"#Node-Buffer\" class=\"headerlink\" title=\"Node Buffer\"></a>Node Buffer</h3><p>在Node.js中Buffer是一个可以在任何模块中被利用的全局类,可以通过以下方式创建buffer对象。</p>\n<ol>\n<li><p>通过构造函数指定buffer大小创建buffer对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> buffer =  <span class=\"keyword\">new</span> Buffer(size);</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过传入数组创建buffer对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(array);</div><div class=\"line\"><span class=\"comment\">// eg: var buffer = new Buffer([1,2,3]);</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>通过传入字符串创建Buffer对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(string,[encoding]);</div><div class=\"line\"><span class=\"comment\">//encoding 参数可选,默认编码方式为'utf8'</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Buffer对象可以通过toString方法转成字符串,toString方法有三个参数分别是encoding,start,end。<code>buffer.toString([encoding],[start],[end])</code>。</p>\n<p>更多关于Buffer的内容可以参看node的文档,下面来看下在gulp中非常重要的一直virtual file format。</p>\n<h3 id=\"vinyl\"><a href=\"#vinyl\" class=\"headerlink\" title=\"vinyl\"></a><a href=\"https://github.com/gulpjs/vinyl\" target=\"_blank\" rel=\"external\">vinyl</a></h3><p>vinyl是一种虚拟文件的格式,用来描述一个文件的简单元数据对象, 对一个文件我们能想到的就是文件的路径和文件内容,这些都是vinyl 对象的主要的属性。那么这个和gulp有什么联系,其实gulp就是一个Vinyl Adapter,一个Vinyl Adapter需要提供src(globs) 和 dest(folder)方法,每个方法都返回对应的stream,src 返回的Stream 会产生Vinyl对象,用于后续使用,如gulp的插件。而dest会使用这些对象,并生成文件到指定的目录。</p>\n<h4 id=\"vinyl-对像方法\"><a href=\"#vinyl-对像方法\" class=\"headerlink\" title=\"vinyl 对像方法\"></a>vinyl 对像方法</h4><ol>\n<li><p><code>file.isBuffer()</code></p>\n<blockquote>\n<p>判断文件内容是否是Buffer格式的,如果是返回true,反之返回false。</p>\n</blockquote>\n</li>\n<li><p><code>file.isStream()</code></p>\n<blockquote>\n<p>判断文件内容是否是stream形式的,如果是返回true,反之返回false.</p>\n</blockquote>\n</li>\n<li><p><code>file.isNull()</code></p>\n<blockquote>\n<p>判断文件内容是否为空。如果是返回true,反之返回false.</p>\n</blockquote>\n</li>\n</ol>\n<p>更多的对象方法<a href=\"https://github.com/gulpjs/vinyl\" target=\"_blank\" rel=\"external\">参看github上的文档</a>。</p>\n<h4 id=\"vinyl-对象的属性\"><a href=\"#vinyl-对象的属性\" class=\"headerlink\" title=\"vinyl 对象的属性\"></a>vinyl 对象的属性</h4><ol>\n<li><p><code>file.cwd</code></p>\n<blockquote>\n<p>当前工作目录,最后的斜杠会被删除,通过<code>file.cwd = newCwd</code> 可以设置新的值。</p>\n</blockquote>\n</li>\n<li><p><code>file.base</code></p>\n<blockquote>\n<p>文件基础目录。值应该等于<code>path.dirname(file.path)</code></p>\n</blockquote>\n</li>\n<li><p><code>file.path</code></p>\n<blockquote>\n<p>文件的绝对路径。</p>\n</blockquote>\n</li>\n<li><p><code>file.relative</code></p>\n<blockquote>\n<p>文件的相对路径,值等于<code>path.resolve(file.base,file.path)</code></p>\n</blockquote>\n<p>更多属性<a href=\"https://github.com/gulpjs/vinyl\" target=\"_blank\" rel=\"external\">参看github上的文档</a>。</p>\n</li>\n</ol>\n<h3 id=\"vinyl-fs\"><a href=\"#vinyl-fs\" class=\"headerlink\" title=\"vinyl-fs\"></a><a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"external\">vinyl-fs</a></h3><p>vinyl-fs 是 vinyl adapter, 具体使用可以参考<a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"external\">github上的文档</a>。一些gulp插件中会使用到这个vinyl adapter。</p>\n<h3 id=\"though2\"><a href=\"#though2\" class=\"headerlink\" title=\"though2\"></a><a href=\"https://github.com/rvagg/through2\" target=\"_blank\" rel=\"external\">though2</a></h3><p>though2 是Node <code>streams.Transform</code> 的一个简单的包装,更方便大家去创建transform流。 对于gulp插件总是会返回一个 object mode 形式的 tranform stream 来做这些事情。所以though2在插件中用的很频繁,简直就是标配。通过though2创建对象模式的transform方式如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//method-1 :</span></div><div class=\"line\"><span class=\"keyword\">const</span> though2 = <span class=\"built_in\">require</span>(<span class=\"string\">'though2'</span>);</div><div class=\"line\">though2(&#123;<span class=\"attr\">objectMode</span>: <span class=\"literal\">true</span>&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk,enc,cb</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//todo something </span></div><div class=\"line\">&#125;,[flushFunction]);</div><div class=\"line\"><span class=\"comment\">//method-2 :</span></div><div class=\"line\">though2.obj(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk,enc,cb</span>) </span>&#123;</div><div class=\"line\">   <span class=\"comment\">//todo something</span></div><div class=\"line\">&#125;,[flushFunction]);</div></pre></td></tr></table></figure>\n<p>基于though2,有人写了<a href=\"https://github.com/bornkiller/through-gulp\" target=\"_blank\" rel=\"external\">though-gulp</a>,使得编写gulp插件变得更加简单。</p>\n<h3 id=\"gulp-插件编写\"><a href=\"#gulp-插件编写\" class=\"headerlink\" title=\"gulp 插件编写\"></a>gulp 插件编写</h3><p>gulp插件的基本代码架子如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// PLUGIN_NAME: sample</span></div><div class=\"line\"><span class=\"keyword\">var</span> through = <span class=\"built_in\">require</span>(<span class=\"string\">'through-gulp'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// exporting the plugin </span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = sample;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sample</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// creating a stream through which each file will pass</span></div><div class=\"line\">  <span class=\"keyword\">var</span> stream = through(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file, encoding,callback</span>) </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">// do whatever necessary to process the file</span></div><div class=\"line\">  \t<span class=\"comment\">// 这里file为vinyl对象。</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (file.isNull()) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果file的内容为空 </span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (file.isBuffer()) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果file的内容为Buffer</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (file.isStream()) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果file的内容为stream</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// just pipe data next, or just do nothing to process file later in flushFunction</span></div><div class=\"line\">    <span class=\"comment\">// never forget callback to indicate that the file has been processed.</span></div><div class=\"line\">      <span class=\"comment\">//确保文件进入下一个 gulp 插件</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.push(file);</div><div class=\"line\">      <span class=\"comment\">//告诉 stream 引擎，我们已经处理完了这个文件</span></div><div class=\"line\">      callback();</div><div class=\"line\">      <span class=\"comment\">//上面两行等价于 callback(null,file);</span></div><div class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// just pipe data next, just callback to indicate that the stream's over</span></div><div class=\"line\">      <span class=\"comment\">//由下一个gulp执行</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.push(something);</div><div class=\"line\">      callback(); <span class=\"comment\">//告诉 stream 引擎，我们已经处理完了</span></div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// returning the file stream</span></div><div class=\"line\">  <span class=\"keyword\">return</span> stream;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>你需要做的是根据的自己的需求,编写相应的逻辑代码。我们可以看下一些插件的源码,这里以gulp-prefix举个例子,具体源码解读可以参看<a href=\"/2017/04/26/gulp-prefix\">gulp-prefix插件源码阅读</a></p>\n<h3 id=\"gulp-插件测试\"><a href=\"#gulp-插件测试\" class=\"headerlink\" title=\"gulp 插件测试\"></a>gulp 插件测试</h3><p>可以参看<a href=\"http://www.gulpjs.com.cn/docs/writing-a-plugin/testing/\" target=\"_blank\" rel=\"external\">gulp 测试</a> 在写测试之前,需要了解mocha 测试框架和chai 或者 shoud.js断言库。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在做老代码的迁移,说实话真是蛋都要碎了。老代码用过的技术栈简直快包含整个前端的技术了,有dom操作库,<code>kissy</code>,<code>zepto</code>,现在盛行的MVVM框架<code>vue</code>,<code>react</code>,较早的模块管理<code>requirejs</code>,还有现在常用的打包工具<code>gulp</code>,<code>webpack</code>,这个项目简直就是一个前端技术的练兵场。不仅如此,源代码和线上代码不一致,代码仓库中并没有一份最新的代码。除此之外,打包配置文件写法真的是有点非主流,很多地方需要手动配置。其中用到的gulp插件数量也是没得说的,在梳理老代码构建打包任务时,有些地方并不是特别明白到底做了些什么,比如:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> gulp.src(config[dist].views + <span class=\"string\">'/*.*'</span>)</div><div class=\"line\">     .pipe(LinkRemove())</div><div class=\"line\">     .pipe(gulp.dest(config[dist].views));</div></pre></td></tr></table></figure>\n<p> 其中<code>LinkRemove</code>,这个东西到底对源代码干了什么,作者并没有很清晰的给出,所以只能去看看这个gulp插件到底做了什么,却发现这个插件是作者自己写的,并没有上传到npm上,局面一度很尴尬,找到源代码,并没有很好的注释说明这是干什么的,可能作者觉得自己的代码即注释吧,虽然代码的确挺短的,但是我看到了这些:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">'use strict'</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> through = <span class=\"built_in\">require</span>(<span class=\"string\">'through2'</span>),</div><div class=\"line\">    fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>),</div><div class=\"line\">    trumpet = <span class=\"built_in\">require</span>(<span class=\"string\">\"trumpet\"</span>),</div><div class=\"line\">    concat = <span class=\"built_in\">require</span>(<span class=\"string\">\"concat-stream\"</span>); </div><div class=\"line\">    </div><div class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> through.obj(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file, enc, cb</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//todo something</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>局面再度尴尬起来,<code>through2</code>是什么,<code>trumpet</code>,<code>concat-stream</code>又是干嘛’屎’的。然后就涉及到了gulp插件的开发,如果不了解gulp插件的原理,是不可能搞懂那些没有注释文档的自己开发的插件功能的。<code>gulp</code>又是一个基于流的构建工具,打开<a href=\"http://www.gulpjs.com.cn/docs/writing-a-plugin/\" target=\"_blank\" rel=\"external\">插件编写文档</a>,看到了这些关键词<code>Buffer</code>,<code>Stream</code>,<code>vinyl File object</code>,<code>though</code>,<code>transform stream</code>。如果你不了解这些那么也就不能很好的理解读懂别人写的插件源码或者编写自己的gulp插件。所以我们从Node Stream开始看起,毕竟gulp是基于流的一个工具。</p>\n<h3 id=\"Node-Stream\"><a href=\"#Node-Stream\" class=\"headerlink\" title=\"Node Stream\"></a>Node Stream</h3><p><code>gulp</code>是一个基于流的构建工具,将各个处理流链接起来达到前端构建的目的,使得前端构建能够实现自动化,自动的完成那些耗时费力又非常重要的构建任务,从而提高了整个开发的效率。那么什么是流呢,流又给gulp带来和别的构建工具哪些不一样呢? 对于什么是流参看<a href=\"https://weekly.js.org/node/node-stream.html\" target=\"_blank\" rel=\"external\">Node Stream 初窥</a>,相比之前流行的前端构建工具grunt来说:</p>\n<ol>\n<li>gulp可以使你将不同的任务通过流的方式链接起来,比如css预处理,css url中的链接修改, css合并压缩等任务,你只需在最开始输入要处理的文件,在最后输出的就是你需要的处理完成的文件。</li>\n<li>每个任务,每个插件都是处理其中一部分处理,非常符合单一职责的原则。</li>\n<li>其次gulp任务编写更加符合大家的习惯,和写正常的逻辑代码别无一二。</li>\n</ol>\n<p>看完Stream,来来看看Buffer,毕竟很多插件是只处理Buffer数据的。</p>\n<h3 id=\"Node-Buffer\"><a href=\"#Node-Buffer\" class=\"headerlink\" title=\"Node Buffer\"></a>Node Buffer</h3><p>在Node.js中Buffer是一个可以在任何模块中被利用的全局类,可以通过以下方式创建buffer对象。</p>\n<ol>\n<li><p>通过构造函数指定buffer大小创建buffer对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> buffer =  <span class=\"keyword\">new</span> Buffer(size);</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过传入数组创建buffer对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(array);</div><div class=\"line\"><span class=\"comment\">// eg: var buffer = new Buffer([1,2,3]);</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>通过传入字符串创建Buffer对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"keyword\">new</span> Buffer(string,[encoding]);</div><div class=\"line\"><span class=\"comment\">//encoding 参数可选,默认编码方式为'utf8'</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>Buffer对象可以通过toString方法转成字符串,toString方法有三个参数分别是encoding,start,end。<code>buffer.toString([encoding],[start],[end])</code>。</p>\n<p>更多关于Buffer的内容可以参看node的文档,下面来看下在gulp中非常重要的一直virtual file format。</p>\n<h3 id=\"vinyl\"><a href=\"#vinyl\" class=\"headerlink\" title=\"vinyl\"></a><a href=\"https://github.com/gulpjs/vinyl\" target=\"_blank\" rel=\"external\">vinyl</a></h3><p>vinyl是一种虚拟文件的格式,用来描述一个文件的简单元数据对象, 对一个文件我们能想到的就是文件的路径和文件内容,这些都是vinyl 对象的主要的属性。那么这个和gulp有什么联系,其实gulp就是一个Vinyl Adapter,一个Vinyl Adapter需要提供src(globs) 和 dest(folder)方法,每个方法都返回对应的stream,src 返回的Stream 会产生Vinyl对象,用于后续使用,如gulp的插件。而dest会使用这些对象,并生成文件到指定的目录。</p>\n<h4 id=\"vinyl-对像方法\"><a href=\"#vinyl-对像方法\" class=\"headerlink\" title=\"vinyl 对像方法\"></a>vinyl 对像方法</h4><ol>\n<li><p><code>file.isBuffer()</code></p>\n<blockquote>\n<p>判断文件内容是否是Buffer格式的,如果是返回true,反之返回false。</p>\n</blockquote>\n</li>\n<li><p><code>file.isStream()</code></p>\n<blockquote>\n<p>判断文件内容是否是stream形式的,如果是返回true,反之返回false.</p>\n</blockquote>\n</li>\n<li><p><code>file.isNull()</code></p>\n<blockquote>\n<p>判断文件内容是否为空。如果是返回true,反之返回false.</p>\n</blockquote>\n</li>\n</ol>\n<p>更多的对象方法<a href=\"https://github.com/gulpjs/vinyl\" target=\"_blank\" rel=\"external\">参看github上的文档</a>。</p>\n<h4 id=\"vinyl-对象的属性\"><a href=\"#vinyl-对象的属性\" class=\"headerlink\" title=\"vinyl 对象的属性\"></a>vinyl 对象的属性</h4><ol>\n<li><p><code>file.cwd</code></p>\n<blockquote>\n<p>当前工作目录,最后的斜杠会被删除,通过<code>file.cwd = newCwd</code> 可以设置新的值。</p>\n</blockquote>\n</li>\n<li><p><code>file.base</code></p>\n<blockquote>\n<p>文件基础目录。值应该等于<code>path.dirname(file.path)</code></p>\n</blockquote>\n</li>\n<li><p><code>file.path</code></p>\n<blockquote>\n<p>文件的绝对路径。</p>\n</blockquote>\n</li>\n<li><p><code>file.relative</code></p>\n<blockquote>\n<p>文件的相对路径,值等于<code>path.resolve(file.base,file.path)</code></p>\n</blockquote>\n<p>更多属性<a href=\"https://github.com/gulpjs/vinyl\" target=\"_blank\" rel=\"external\">参看github上的文档</a>。</p>\n</li>\n</ol>\n<h3 id=\"vinyl-fs\"><a href=\"#vinyl-fs\" class=\"headerlink\" title=\"vinyl-fs\"></a><a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"external\">vinyl-fs</a></h3><p>vinyl-fs 是 vinyl adapter, 具体使用可以参考<a href=\"https://github.com/gulpjs/vinyl-fs\" target=\"_blank\" rel=\"external\">github上的文档</a>。一些gulp插件中会使用到这个vinyl adapter。</p>\n<h3 id=\"though2\"><a href=\"#though2\" class=\"headerlink\" title=\"though2\"></a><a href=\"https://github.com/rvagg/through2\" target=\"_blank\" rel=\"external\">though2</a></h3><p>though2 是Node <code>streams.Transform</code> 的一个简单的包装,更方便大家去创建transform流。 对于gulp插件总是会返回一个 object mode 形式的 tranform stream 来做这些事情。所以though2在插件中用的很频繁,简直就是标配。通过though2创建对象模式的transform方式如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//method-1 :</span></div><div class=\"line\"><span class=\"keyword\">const</span> though2 = <span class=\"built_in\">require</span>(<span class=\"string\">'though2'</span>);</div><div class=\"line\">though2(&#123;<span class=\"attr\">objectMode</span>: <span class=\"literal\">true</span>&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk,enc,cb</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//todo something </span></div><div class=\"line\">&#125;,[flushFunction]);</div><div class=\"line\"><span class=\"comment\">//method-2 :</span></div><div class=\"line\">though2.obj(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chunk,enc,cb</span>) </span>&#123;</div><div class=\"line\">   <span class=\"comment\">//todo something</span></div><div class=\"line\">&#125;,[flushFunction]);</div></pre></td></tr></table></figure>\n<p>基于though2,有人写了<a href=\"https://github.com/bornkiller/through-gulp\" target=\"_blank\" rel=\"external\">though-gulp</a>,使得编写gulp插件变得更加简单。</p>\n<h3 id=\"gulp-插件编写\"><a href=\"#gulp-插件编写\" class=\"headerlink\" title=\"gulp 插件编写\"></a>gulp 插件编写</h3><p>gulp插件的基本代码架子如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// PLUGIN_NAME: sample</span></div><div class=\"line\"><span class=\"keyword\">var</span> through = <span class=\"built_in\">require</span>(<span class=\"string\">'through-gulp'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// exporting the plugin </span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = sample;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sample</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// creating a stream through which each file will pass</span></div><div class=\"line\">  <span class=\"keyword\">var</span> stream = through(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file, encoding,callback</span>) </span>&#123;</div><div class=\"line\">  \t<span class=\"comment\">// do whatever necessary to process the file</span></div><div class=\"line\">  \t<span class=\"comment\">// 这里file为vinyl对象。</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (file.isNull()) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果file的内容为空 </span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (file.isBuffer()) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果file的内容为Buffer</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (file.isStream()) &#123;</div><div class=\"line\">        <span class=\"comment\">// 如果file的内容为stream</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// just pipe data next, or just do nothing to process file later in flushFunction</span></div><div class=\"line\">    <span class=\"comment\">// never forget callback to indicate that the file has been processed.</span></div><div class=\"line\">      <span class=\"comment\">//确保文件进入下一个 gulp 插件</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.push(file);</div><div class=\"line\">      <span class=\"comment\">//告诉 stream 引擎，我们已经处理完了这个文件</span></div><div class=\"line\">      callback();</div><div class=\"line\">      <span class=\"comment\">//上面两行等价于 callback(null,file);</span></div><div class=\"line\">    &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// just pipe data next, just callback to indicate that the stream's over</span></div><div class=\"line\">      <span class=\"comment\">//由下一个gulp执行</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.push(something);</div><div class=\"line\">      callback(); <span class=\"comment\">//告诉 stream 引擎，我们已经处理完了</span></div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// returning the file stream</span></div><div class=\"line\">  <span class=\"keyword\">return</span> stream;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>你需要做的是根据的自己的需求,编写相应的逻辑代码。我们可以看下一些插件的源码,这里以gulp-prefix举个例子,具体源码解读可以参看<a href=\"/2017/04/26/gulp-prefix\">gulp-prefix插件源码阅读</a></p>\n<h3 id=\"gulp-插件测试\"><a href=\"#gulp-插件测试\" class=\"headerlink\" title=\"gulp 插件测试\"></a>gulp 插件测试</h3><p>可以参看<a href=\"http://www.gulpjs.com.cn/docs/writing-a-plugin/testing/\" target=\"_blank\" rel=\"external\">gulp 测试</a> 在写测试之前,需要了解mocha 测试框架和chai 或者 shoud.js断言库。</p>\n"},{"title":"Mongoose 学习笔记一 Model 和 Schema","type":"original","date":"2017-04-25T16:50:12.000Z","description":null,"_content":"\nMongoose是在node.js异步环境下对mongodb进行便捷操作的优雅的对象模型工具。提供了直接的基于Schema的将应用数据模型化的解决方案。\n\n<!-- more -->\n### 连接数据库\n\n* #### uri\n\n  要对mongodb数据库进行相关操作,比如查询,新增,删除,更新,首先你需要通过一定的方式连接上数据库。mongoose 提供 connect 方法用来连接数据库实例。\n\n  > 方式一: ``mongoose.connect('mongodb://username:password@host:port/database?options...');``\n    方式二: ``mongoose.connect(uri,options)``\n\n  如我们想通过这种方法来连接运行在本地端口为默认端口(27017)的数据库实例的话,代码如下:\n\n  ```javascript\n    var mongoose = require('mongoose');\n    mongoose.connect('mongodb://localhost/test');\n  ```\n  通过上面的代码,我们连接到了本地test数据库,然后可以通过如下方法来判断数据库连接是否成功。\n\n  ```javascript\n    var db = mongoose.connection;\n    db.on('error', console.error.bind(console, 'connection error:'));\n    db.once('open', function() {\n      // we're connected!\n    });\n  ```\n* #### options\n\n  在连接数据库的时候可以提供选项参数,这些选项参数最终都会被传给底层数据库驱动,通过参数形式传的选项,优先级高于uri中的参数。\n如设置连接池大小和重连次数可以按照如下方式:\n\n  ```javascript\n    var mongoose = require('mongoose');\n    mongoose.connect('mongodb://localhost/test',{\n        server : {\n            poolSize : 20, // 默认为5\n            reconnectTries: Number.MAX_VALUE // 无限重连的节奏\n        }\n    });\n    ```\n\n* #### callback\n\n  mongoose 提供的connect方法接受callback参数作为连接数据库的回调,整个方法返回promise。对于回调两种写法如下:\n\n    ```javascript\n    mongoose.connect(uri, options, function(error) {\n      // Check error in initial connection. There is no 2nd param to the callback.\n    });\n\n    // Or using promises\n    mongoose.connect(uri, options).then(\n      () => { /** ready to use. The `mongoose.connect()` promise resolves to undefined. */ },\n      err => { /** handle initial connection error }\n    );\n    ```\n\n* #### 更多内容参考\n1. [Connection String URI Format](https://docs.mongodb.com/manual/reference/connection-string/)\n2. [mongoose Connections](http://mongoosejs.com/docs/connections.html)\n\n\n## mongoose Schema & Model\n\n* #### Schema\n  在 mongoose 中,所有事都从 Schema 开始,Schema 是对 mongodb 数据库集合中的文档结构的一种映射,可以是文档的全部或者部分。Schema 不仅定义了文档结构和使用性能，还可以有扩展插件、实例方法、静态方法、复合索引、文档生命周期钩子,Schema可以定义插件，并且插件具有良好的可拔插性,Schema 不具备对数据库进行操作的能力,简单的说 Schema 就是描述集合中数据而存在的。mongoose 中通过如下方法创建Schema。\n\n    ```javascript\n    var mongoose = require('mongoose');\n    var Schema = mongoose.Schema;\n\n    var blogSchema = new Schema({\n      title:  String,\n      author: String,\n      body:   String,\n      comments: [{ body: String, date: Date }],\n      date: { type: Date, default: Date.now },\n      hidden: Boolean,\n      meta: {\n        votes: Number,\n        favs:  Number\n      }\n    });\n   ```\n\n  定义Schema相当于关系型数据库定义表结构一样。也有对应字段的类型,默认值,最大最小值等。更多类型内容参考[SchemaTypes](http://mongoosejs.com/docs/schematypes.html)\n\n* #### Model\n\n  Model 由Schema创建具有抽象属性和行为的数据库操作对象。模型的实例代表着文档,可以保存或者从数据库中取出。读到这大家可能会有一个疑惑,Model怎么和mongodb中的collection名称对应起来呢,例如你通过``mongoose.model('User',new Schema({ name: String }))``,创建一个model对象,那么这个对象对应的是数据库中哪个collection呢,很多人可能会猜是 user, 但是实际上却是 users,``mongoose.model``规定,当你在创建 Model 对象的时候没有提供collection 参数,那么他就会将 Model 的名称小写并复数化作为 mongodb 数据库中对应的 collection 的名称。参考[Mongoose#model](http://mongoosejs.com/docs/api.html#utils_exports.toCollectionName)\n\n  > When no collection argument is passed, Mongoose produces a collection name by passing the model name to the utils.toCollectionName method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option.\n\n  可以通过如下方式自定义 collection 名称\n\n  ```javascript\n    //方式一: 通过创建schema的时候定义\n    var schema = new Schema({ name: String }, { collection: 'actor' });\n\n    // or\n    //方式一: 通过创建schema的set方法进行定义\n    schema.set('collection', 'actor');\n\n    // or\n    //方式三: 通过在创建Model对象时指定第三个参数定义\n    var collectionName = 'actor'\n    var M = mongoose.model('Actor', schema, collectionName)\n   ```\n\n  创建完Model对象后,就可以通过他进行数据库操作了,如保存一个文档(为Model对象的实例),如下:\n\n    ```javascript\n    var schema = new mongoose.Schema({ name: 'string', size: 'string' });\n    var Tank = mongoose.model('Tank', schema);\n    var small = new Tank({ size: 'small' });\n    small.save(function (err) {\n      if (err) return handleError(err);\n      // saved!\n    })\n\n    // or\n\n    Tank.create({ size: 'small' }, function (err, small) {\n      if (err) return handleError(err);\n      // saved!\n    })\n    ```\n\n    更多关于Model的内容参考[Models](http://mongoosejs.com/docs/models.html)\n\n\n\n### 总结\n在NodeJS中和mongodb打交道时,需要一个好用的数据库驱动,那么Mongoose是不错的选择,通过上面的学习了解,我们现在可以通过Mongoose,将文档插入和保存到数据库中,那么具体如何查询获得我们想要的数据集合,则需要接下来学习 Mongoose 的 queries 部分。\n\n### 参考资料\n\n1. [Mongoose 官方文档](http://mongoosejs.com/docs/guide.html)\n2. [Mongoose学习参考文档——基础篇](https://cnodejs.org/topic/504b4924e2b84515770103dd)\n","source":"_posts/mongoose-tutorial-1.md","raw":"---\ntitle: Mongoose 学习笔记一 Model 和 Schema\ntype: original\ntags: [Mongoose,Mongodb]\ncategories: [nodeclub源码学习]\ndate: 2017-04-26 00:50:12\ndescription:\n---\n\nMongoose是在node.js异步环境下对mongodb进行便捷操作的优雅的对象模型工具。提供了直接的基于Schema的将应用数据模型化的解决方案。\n\n<!-- more -->\n### 连接数据库\n\n* #### uri\n\n  要对mongodb数据库进行相关操作,比如查询,新增,删除,更新,首先你需要通过一定的方式连接上数据库。mongoose 提供 connect 方法用来连接数据库实例。\n\n  > 方式一: ``mongoose.connect('mongodb://username:password@host:port/database?options...');``\n    方式二: ``mongoose.connect(uri,options)``\n\n  如我们想通过这种方法来连接运行在本地端口为默认端口(27017)的数据库实例的话,代码如下:\n\n  ```javascript\n    var mongoose = require('mongoose');\n    mongoose.connect('mongodb://localhost/test');\n  ```\n  通过上面的代码,我们连接到了本地test数据库,然后可以通过如下方法来判断数据库连接是否成功。\n\n  ```javascript\n    var db = mongoose.connection;\n    db.on('error', console.error.bind(console, 'connection error:'));\n    db.once('open', function() {\n      // we're connected!\n    });\n  ```\n* #### options\n\n  在连接数据库的时候可以提供选项参数,这些选项参数最终都会被传给底层数据库驱动,通过参数形式传的选项,优先级高于uri中的参数。\n如设置连接池大小和重连次数可以按照如下方式:\n\n  ```javascript\n    var mongoose = require('mongoose');\n    mongoose.connect('mongodb://localhost/test',{\n        server : {\n            poolSize : 20, // 默认为5\n            reconnectTries: Number.MAX_VALUE // 无限重连的节奏\n        }\n    });\n    ```\n\n* #### callback\n\n  mongoose 提供的connect方法接受callback参数作为连接数据库的回调,整个方法返回promise。对于回调两种写法如下:\n\n    ```javascript\n    mongoose.connect(uri, options, function(error) {\n      // Check error in initial connection. There is no 2nd param to the callback.\n    });\n\n    // Or using promises\n    mongoose.connect(uri, options).then(\n      () => { /** ready to use. The `mongoose.connect()` promise resolves to undefined. */ },\n      err => { /** handle initial connection error }\n    );\n    ```\n\n* #### 更多内容参考\n1. [Connection String URI Format](https://docs.mongodb.com/manual/reference/connection-string/)\n2. [mongoose Connections](http://mongoosejs.com/docs/connections.html)\n\n\n## mongoose Schema & Model\n\n* #### Schema\n  在 mongoose 中,所有事都从 Schema 开始,Schema 是对 mongodb 数据库集合中的文档结构的一种映射,可以是文档的全部或者部分。Schema 不仅定义了文档结构和使用性能，还可以有扩展插件、实例方法、静态方法、复合索引、文档生命周期钩子,Schema可以定义插件，并且插件具有良好的可拔插性,Schema 不具备对数据库进行操作的能力,简单的说 Schema 就是描述集合中数据而存在的。mongoose 中通过如下方法创建Schema。\n\n    ```javascript\n    var mongoose = require('mongoose');\n    var Schema = mongoose.Schema;\n\n    var blogSchema = new Schema({\n      title:  String,\n      author: String,\n      body:   String,\n      comments: [{ body: String, date: Date }],\n      date: { type: Date, default: Date.now },\n      hidden: Boolean,\n      meta: {\n        votes: Number,\n        favs:  Number\n      }\n    });\n   ```\n\n  定义Schema相当于关系型数据库定义表结构一样。也有对应字段的类型,默认值,最大最小值等。更多类型内容参考[SchemaTypes](http://mongoosejs.com/docs/schematypes.html)\n\n* #### Model\n\n  Model 由Schema创建具有抽象属性和行为的数据库操作对象。模型的实例代表着文档,可以保存或者从数据库中取出。读到这大家可能会有一个疑惑,Model怎么和mongodb中的collection名称对应起来呢,例如你通过``mongoose.model('User',new Schema({ name: String }))``,创建一个model对象,那么这个对象对应的是数据库中哪个collection呢,很多人可能会猜是 user, 但是实际上却是 users,``mongoose.model``规定,当你在创建 Model 对象的时候没有提供collection 参数,那么他就会将 Model 的名称小写并复数化作为 mongodb 数据库中对应的 collection 的名称。参考[Mongoose#model](http://mongoosejs.com/docs/api.html#utils_exports.toCollectionName)\n\n  > When no collection argument is passed, Mongoose produces a collection name by passing the model name to the utils.toCollectionName method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option.\n\n  可以通过如下方式自定义 collection 名称\n\n  ```javascript\n    //方式一: 通过创建schema的时候定义\n    var schema = new Schema({ name: String }, { collection: 'actor' });\n\n    // or\n    //方式一: 通过创建schema的set方法进行定义\n    schema.set('collection', 'actor');\n\n    // or\n    //方式三: 通过在创建Model对象时指定第三个参数定义\n    var collectionName = 'actor'\n    var M = mongoose.model('Actor', schema, collectionName)\n   ```\n\n  创建完Model对象后,就可以通过他进行数据库操作了,如保存一个文档(为Model对象的实例),如下:\n\n    ```javascript\n    var schema = new mongoose.Schema({ name: 'string', size: 'string' });\n    var Tank = mongoose.model('Tank', schema);\n    var small = new Tank({ size: 'small' });\n    small.save(function (err) {\n      if (err) return handleError(err);\n      // saved!\n    })\n\n    // or\n\n    Tank.create({ size: 'small' }, function (err, small) {\n      if (err) return handleError(err);\n      // saved!\n    })\n    ```\n\n    更多关于Model的内容参考[Models](http://mongoosejs.com/docs/models.html)\n\n\n\n### 总结\n在NodeJS中和mongodb打交道时,需要一个好用的数据库驱动,那么Mongoose是不错的选择,通过上面的学习了解,我们现在可以通过Mongoose,将文档插入和保存到数据库中,那么具体如何查询获得我们想要的数据集合,则需要接下来学习 Mongoose 的 queries 部分。\n\n### 参考资料\n\n1. [Mongoose 官方文档](http://mongoosejs.com/docs/guide.html)\n2. [Mongoose学习参考文档——基础篇](https://cnodejs.org/topic/504b4924e2b84515770103dd)\n","slug":"mongoose-tutorial-1","published":1,"updated":"2017-05-08T14:40:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhq7000eb37q63r57pag","content":"<p>Mongoose是在node.js异步环境下对mongodb进行便捷操作的优雅的对象模型工具。提供了直接的基于Schema的将应用数据模型化的解决方案。</p>\n<a id=\"more\"></a>\n<h3 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h3><ul>\n<li><h4 id=\"uri\"><a href=\"#uri\" class=\"headerlink\" title=\"uri\"></a>uri</h4><p>要对mongodb数据库进行相关操作,比如查询,新增,删除,更新,首先你需要通过一定的方式连接上数据库。mongoose 提供 connect 方法用来连接数据库实例。</p>\n<blockquote>\n<p>方式一: <code>mongoose.connect(&#39;mongodb://username:password@host:port/database?options...&#39;);</code><br>  方式二: <code>mongoose.connect(uri,options)</code></p>\n</blockquote>\n<p>如我们想通过这种方法来连接运行在本地端口为默认端口(27017)的数据库实例的话,代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</div><div class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://localhost/test'</span>);</div></pre></td></tr></table></figure>\n<p>通过上面的代码,我们连接到了本地test数据库,然后可以通过如下方法来判断数据库连接是否成功。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db = mongoose.connection;</div><div class=\"line\">db.on(<span class=\"string\">'error'</span>, <span class=\"built_in\">console</span>.error.bind(<span class=\"built_in\">console</span>, <span class=\"string\">'connection error:'</span>));</div><div class=\"line\">db.once(<span class=\"string\">'open'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// we're connected!</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"options\"><a href=\"#options\" class=\"headerlink\" title=\"options\"></a>options</h4><p>在连接数据库的时候可以提供选项参数,这些选项参数最终都会被传给底层数据库驱动,通过参数形式传的选项,优先级高于uri中的参数。<br>如设置连接池大小和重连次数可以按照如下方式:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</div><div class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://localhost/test'</span>,&#123;</div><div class=\"line\">    <span class=\"attr\">server</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">poolSize</span> : <span class=\"number\">20</span>, <span class=\"comment\">// 默认为5</span></div><div class=\"line\">        reconnectTries: <span class=\"built_in\">Number</span>.MAX_VALUE <span class=\"comment\">// 无限重连的节奏</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"callback\"><a href=\"#callback\" class=\"headerlink\" title=\"callback\"></a>callback</h4><p>mongoose 提供的connect方法接受callback参数作为连接数据库的回调,整个方法返回promise。对于回调两种写法如下:</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">mongoose.connect(uri, options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// Check error in initial connection. There is no 2nd param to the callback.</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Or using promises</span></div><div class=\"line\">mongoose.connect(uri, options).then(</div><div class=\"line\">  <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">/** ready to use. The `mongoose.connect()` promise resolves to undefined. */</span> &#125;,</div><div class=\"line\">  err =&gt; &#123; <span class=\"comment\">/** handle initial connection error &#125;</span></div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"更多内容参考\"><a href=\"#更多内容参考\" class=\"headerlink\" title=\"更多内容参考\"></a>更多内容参考</h4></li>\n</ul>\n<ol>\n<li><a href=\"https://docs.mongodb.com/manual/reference/connection-string/\" target=\"_blank\" rel=\"external\">Connection String URI Format</a></li>\n<li><a href=\"http://mongoosejs.com/docs/connections.html\" target=\"_blank\" rel=\"external\">mongoose Connections</a></li>\n</ol>\n<h2 id=\"mongoose-Schema-amp-Model\"><a href=\"#mongoose-Schema-amp-Model\" class=\"headerlink\" title=\"mongoose Schema &amp; Model\"></a>mongoose Schema &amp; Model</h2><ul>\n<li><h4 id=\"Schema\"><a href=\"#Schema\" class=\"headerlink\" title=\"Schema\"></a>Schema</h4><p>在 mongoose 中,所有事都从 Schema 开始,Schema 是对 mongodb 数据库集合中的文档结构的一种映射,可以是文档的全部或者部分。Schema 不仅定义了文档结构和使用性能，还可以有扩展插件、实例方法、静态方法、复合索引、文档生命周期钩子,Schema可以定义插件，并且插件具有良好的可拔插性,Schema 不具备对数据库进行操作的能力,简单的说 Schema 就是描述集合中数据而存在的。mongoose 中通过如下方法创建Schema。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> Schema = mongoose.Schema;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> blogSchema = <span class=\"keyword\">new</span> Schema(&#123;</div><div class=\"line\">  <span class=\"attr\">title</span>:  <span class=\"built_in\">String</span>,</div><div class=\"line\">  <span class=\"attr\">author</span>: <span class=\"built_in\">String</span>,</div><div class=\"line\">  <span class=\"attr\">body</span>:   <span class=\"built_in\">String</span>,</div><div class=\"line\">  <span class=\"attr\">comments</span>: [&#123; <span class=\"attr\">body</span>: <span class=\"built_in\">String</span>, <span class=\"attr\">date</span>: <span class=\"built_in\">Date</span> &#125;],</div><div class=\"line\">  <span class=\"attr\">date</span>: &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Date</span>, <span class=\"attr\">default</span>: <span class=\"built_in\">Date</span>.now &#125;,</div><div class=\"line\">  <span class=\"attr\">hidden</span>: <span class=\"built_in\">Boolean</span>,</div><div class=\"line\">  <span class=\"attr\">meta</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">votes</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">    <span class=\"attr\">favs</span>:  <span class=\"built_in\">Number</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>定义Schema相当于关系型数据库定义表结构一样。也有对应字段的类型,默认值,最大最小值等。更多类型内容参考<a href=\"http://mongoosejs.com/docs/schematypes.html\" target=\"_blank\" rel=\"external\">SchemaTypes</a></p>\n</li>\n<li><h4 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h4><p>Model 由Schema创建具有抽象属性和行为的数据库操作对象。模型的实例代表着文档,可以保存或者从数据库中取出。读到这大家可能会有一个疑惑,Model怎么和mongodb中的collection名称对应起来呢,例如你通过<code>mongoose.model(&#39;User&#39;,new Schema({ name: String }))</code>,创建一个model对象,那么这个对象对应的是数据库中哪个collection呢,很多人可能会猜是 user, 但是实际上却是 users,<code>mongoose.model</code>规定,当你在创建 Model 对象的时候没有提供collection 参数,那么他就会将 Model 的名称小写并复数化作为 mongodb 数据库中对应的 collection 的名称。参考<a href=\"http://mongoosejs.com/docs/api.html#utils_exports.toCollectionName\" target=\"_blank\" rel=\"external\">Mongoose#model</a></p>\n<blockquote>\n<p>When no collection argument is passed, Mongoose produces a collection name by passing the model name to the utils.toCollectionName method. This method pluralizes the name. If you don’t like this behavior, either pass a collection name or set your schemas collection name option.</p>\n</blockquote>\n<p>可以通过如下方式自定义 collection 名称</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//方式一: 通过创建schema的时候定义</span></div><div class=\"line\"><span class=\"keyword\">var</span> schema = <span class=\"keyword\">new</span> Schema(&#123; <span class=\"attr\">name</span>: <span class=\"built_in\">String</span> &#125;, &#123; <span class=\"attr\">collection</span>: <span class=\"string\">'actor'</span> &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// or</span></div><div class=\"line\"><span class=\"comment\">//方式一: 通过创建schema的set方法进行定义</span></div><div class=\"line\">schema.set(<span class=\"string\">'collection'</span>, <span class=\"string\">'actor'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// or</span></div><div class=\"line\"><span class=\"comment\">//方式三: 通过在创建Model对象时指定第三个参数定义</span></div><div class=\"line\"><span class=\"keyword\">var</span> collectionName = <span class=\"string\">'actor'</span></div><div class=\"line\"><span class=\"keyword\">var</span> M = mongoose.model(<span class=\"string\">'Actor'</span>, schema, collectionName)</div></pre></td></tr></table></figure>\n<p>创建完Model对象后,就可以通过他进行数据库操作了,如保存一个文档(为Model对象的实例),如下:</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> schema = <span class=\"keyword\">new</span> mongoose.Schema(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'string'</span>, <span class=\"attr\">size</span>: <span class=\"string\">'string'</span> &#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> Tank = mongoose.model(<span class=\"string\">'Tank'</span>, schema);</div><div class=\"line\"><span class=\"keyword\">var</span> small = <span class=\"keyword\">new</span> Tank(&#123; <span class=\"attr\">size</span>: <span class=\"string\">'small'</span> &#125;);</div><div class=\"line\">small.save(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  <span class=\"comment\">// saved!</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// or</span></div><div class=\"line\"></div><div class=\"line\">Tank.create(&#123; <span class=\"attr\">size</span>: <span class=\"string\">'small'</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, small</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  <span class=\"comment\">// saved!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>  更多关于Model的内容参考<a href=\"http://mongoosejs.com/docs/models.html\" target=\"_blank\" rel=\"external\">Models</a></p>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在NodeJS中和mongodb打交道时,需要一个好用的数据库驱动,那么Mongoose是不错的选择,通过上面的学习了解,我们现在可以通过Mongoose,将文档插入和保存到数据库中,那么具体如何查询获得我们想要的数据集合,则需要接下来学习 Mongoose 的 queries 部分。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"http://mongoosejs.com/docs/guide.html\" target=\"_blank\" rel=\"external\">Mongoose 官方文档</a></li>\n<li><a href=\"https://cnodejs.org/topic/504b4924e2b84515770103dd\" target=\"_blank\" rel=\"external\">Mongoose学习参考文档——基础篇</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Mongoose是在node.js异步环境下对mongodb进行便捷操作的优雅的对象模型工具。提供了直接的基于Schema的将应用数据模型化的解决方案。</p>","more":"<h3 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h3><ul>\n<li><h4 id=\"uri\"><a href=\"#uri\" class=\"headerlink\" title=\"uri\"></a>uri</h4><p>要对mongodb数据库进行相关操作,比如查询,新增,删除,更新,首先你需要通过一定的方式连接上数据库。mongoose 提供 connect 方法用来连接数据库实例。</p>\n<blockquote>\n<p>方式一: <code>mongoose.connect(&#39;mongodb://username:password@host:port/database?options...&#39;);</code><br>  方式二: <code>mongoose.connect(uri,options)</code></p>\n</blockquote>\n<p>如我们想通过这种方法来连接运行在本地端口为默认端口(27017)的数据库实例的话,代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</div><div class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://localhost/test'</span>);</div></pre></td></tr></table></figure>\n<p>通过上面的代码,我们连接到了本地test数据库,然后可以通过如下方法来判断数据库连接是否成功。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> db = mongoose.connection;</div><div class=\"line\">db.on(<span class=\"string\">'error'</span>, <span class=\"built_in\">console</span>.error.bind(<span class=\"built_in\">console</span>, <span class=\"string\">'connection error:'</span>));</div><div class=\"line\">db.once(<span class=\"string\">'open'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// we're connected!</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"options\"><a href=\"#options\" class=\"headerlink\" title=\"options\"></a>options</h4><p>在连接数据库的时候可以提供选项参数,这些选项参数最终都会被传给底层数据库驱动,通过参数形式传的选项,优先级高于uri中的参数。<br>如设置连接池大小和重连次数可以按照如下方式:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</div><div class=\"line\">mongoose.connect(<span class=\"string\">'mongodb://localhost/test'</span>,&#123;</div><div class=\"line\">    <span class=\"attr\">server</span> : &#123;</div><div class=\"line\">        <span class=\"attr\">poolSize</span> : <span class=\"number\">20</span>, <span class=\"comment\">// 默认为5</span></div><div class=\"line\">        reconnectTries: <span class=\"built_in\">Number</span>.MAX_VALUE <span class=\"comment\">// 无限重连的节奏</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"callback\"><a href=\"#callback\" class=\"headerlink\" title=\"callback\"></a>callback</h4><p>mongoose 提供的connect方法接受callback参数作为连接数据库的回调,整个方法返回promise。对于回调两种写法如下:</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">mongoose.connect(uri, options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// Check error in initial connection. There is no 2nd param to the callback.</span></div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Or using promises</span></div><div class=\"line\">mongoose.connect(uri, options).then(</div><div class=\"line\">  <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"comment\">/** ready to use. The `mongoose.connect()` promise resolves to undefined. */</span> &#125;,</div><div class=\"line\">  err =&gt; &#123; <span class=\"comment\">/** handle initial connection error &#125;</span></div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"更多内容参考\"><a href=\"#更多内容参考\" class=\"headerlink\" title=\"更多内容参考\"></a>更多内容参考</h4></li>\n</ul>\n<ol>\n<li><a href=\"https://docs.mongodb.com/manual/reference/connection-string/\" target=\"_blank\" rel=\"external\">Connection String URI Format</a></li>\n<li><a href=\"http://mongoosejs.com/docs/connections.html\" target=\"_blank\" rel=\"external\">mongoose Connections</a></li>\n</ol>\n<h2 id=\"mongoose-Schema-amp-Model\"><a href=\"#mongoose-Schema-amp-Model\" class=\"headerlink\" title=\"mongoose Schema &amp; Model\"></a>mongoose Schema &amp; Model</h2><ul>\n<li><h4 id=\"Schema\"><a href=\"#Schema\" class=\"headerlink\" title=\"Schema\"></a>Schema</h4><p>在 mongoose 中,所有事都从 Schema 开始,Schema 是对 mongodb 数据库集合中的文档结构的一种映射,可以是文档的全部或者部分。Schema 不仅定义了文档结构和使用性能，还可以有扩展插件、实例方法、静态方法、复合索引、文档生命周期钩子,Schema可以定义插件，并且插件具有良好的可拔插性,Schema 不具备对数据库进行操作的能力,简单的说 Schema 就是描述集合中数据而存在的。mongoose 中通过如下方法创建Schema。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> Schema = mongoose.Schema;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> blogSchema = <span class=\"keyword\">new</span> Schema(&#123;</div><div class=\"line\">  <span class=\"attr\">title</span>:  <span class=\"built_in\">String</span>,</div><div class=\"line\">  <span class=\"attr\">author</span>: <span class=\"built_in\">String</span>,</div><div class=\"line\">  <span class=\"attr\">body</span>:   <span class=\"built_in\">String</span>,</div><div class=\"line\">  <span class=\"attr\">comments</span>: [&#123; <span class=\"attr\">body</span>: <span class=\"built_in\">String</span>, <span class=\"attr\">date</span>: <span class=\"built_in\">Date</span> &#125;],</div><div class=\"line\">  <span class=\"attr\">date</span>: &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Date</span>, <span class=\"attr\">default</span>: <span class=\"built_in\">Date</span>.now &#125;,</div><div class=\"line\">  <span class=\"attr\">hidden</span>: <span class=\"built_in\">Boolean</span>,</div><div class=\"line\">  <span class=\"attr\">meta</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">votes</span>: <span class=\"built_in\">Number</span>,</div><div class=\"line\">    <span class=\"attr\">favs</span>:  <span class=\"built_in\">Number</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>定义Schema相当于关系型数据库定义表结构一样。也有对应字段的类型,默认值,最大最小值等。更多类型内容参考<a href=\"http://mongoosejs.com/docs/schematypes.html\" target=\"_blank\" rel=\"external\">SchemaTypes</a></p>\n</li>\n<li><h4 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h4><p>Model 由Schema创建具有抽象属性和行为的数据库操作对象。模型的实例代表着文档,可以保存或者从数据库中取出。读到这大家可能会有一个疑惑,Model怎么和mongodb中的collection名称对应起来呢,例如你通过<code>mongoose.model(&#39;User&#39;,new Schema({ name: String }))</code>,创建一个model对象,那么这个对象对应的是数据库中哪个collection呢,很多人可能会猜是 user, 但是实际上却是 users,<code>mongoose.model</code>规定,当你在创建 Model 对象的时候没有提供collection 参数,那么他就会将 Model 的名称小写并复数化作为 mongodb 数据库中对应的 collection 的名称。参考<a href=\"http://mongoosejs.com/docs/api.html#utils_exports.toCollectionName\" target=\"_blank\" rel=\"external\">Mongoose#model</a></p>\n<blockquote>\n<p>When no collection argument is passed, Mongoose produces a collection name by passing the model name to the utils.toCollectionName method. This method pluralizes the name. If you don’t like this behavior, either pass a collection name or set your schemas collection name option.</p>\n</blockquote>\n<p>可以通过如下方式自定义 collection 名称</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//方式一: 通过创建schema的时候定义</span></div><div class=\"line\"><span class=\"keyword\">var</span> schema = <span class=\"keyword\">new</span> Schema(&#123; <span class=\"attr\">name</span>: <span class=\"built_in\">String</span> &#125;, &#123; <span class=\"attr\">collection</span>: <span class=\"string\">'actor'</span> &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// or</span></div><div class=\"line\"><span class=\"comment\">//方式一: 通过创建schema的set方法进行定义</span></div><div class=\"line\">schema.set(<span class=\"string\">'collection'</span>, <span class=\"string\">'actor'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// or</span></div><div class=\"line\"><span class=\"comment\">//方式三: 通过在创建Model对象时指定第三个参数定义</span></div><div class=\"line\"><span class=\"keyword\">var</span> collectionName = <span class=\"string\">'actor'</span></div><div class=\"line\"><span class=\"keyword\">var</span> M = mongoose.model(<span class=\"string\">'Actor'</span>, schema, collectionName)</div></pre></td></tr></table></figure>\n<p>创建完Model对象后,就可以通过他进行数据库操作了,如保存一个文档(为Model对象的实例),如下:</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> schema = <span class=\"keyword\">new</span> mongoose.Schema(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'string'</span>, <span class=\"attr\">size</span>: <span class=\"string\">'string'</span> &#125;);</div><div class=\"line\"><span class=\"keyword\">var</span> Tank = mongoose.model(<span class=\"string\">'Tank'</span>, schema);</div><div class=\"line\"><span class=\"keyword\">var</span> small = <span class=\"keyword\">new</span> Tank(&#123; <span class=\"attr\">size</span>: <span class=\"string\">'small'</span> &#125;);</div><div class=\"line\">small.save(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  <span class=\"comment\">// saved!</span></div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// or</span></div><div class=\"line\"></div><div class=\"line\">Tank.create(&#123; <span class=\"attr\">size</span>: <span class=\"string\">'small'</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, small</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  <span class=\"comment\">// saved!</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>  更多关于Model的内容参考<a href=\"http://mongoosejs.com/docs/models.html\" target=\"_blank\" rel=\"external\">Models</a></p>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在NodeJS中和mongodb打交道时,需要一个好用的数据库驱动,那么Mongoose是不错的选择,通过上面的学习了解,我们现在可以通过Mongoose,将文档插入和保存到数据库中,那么具体如何查询获得我们想要的数据集合,则需要接下来学习 Mongoose 的 queries 部分。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"http://mongoosejs.com/docs/guide.html\" target=\"_blank\" rel=\"external\">Mongoose 官方文档</a></li>\n<li><a href=\"https://cnodejs.org/topic/504b4924e2b84515770103dd\" target=\"_blank\" rel=\"external\">Mongoose学习参考文档——基础篇</a></li>\n</ol>"},{"title":"什么是JavaScript 事件循环 ?","type":"translate","date":"2017-05-03T03:33:10.000Z","description":null,"_content":"\n\n　　这篇文章是对个人认为讲解　JavaScript　事件循环比较清楚的一篇英文文章的简单翻译,原文地址是http://altitudelabs.com/blog/what-is-the-javascript-event-loop/。\n\n<!--　more　-->\n\n## 介绍\n\n　　如果你像我一样,喜欢JavaScript,是的,你肯定也会认同,JavaScript这门语言并不完美,严肃的说,没有任何一门计算机语言是完美的。尽管JavaScript确实存在一些缺陷,但我喜欢编写web程序以及如何用JavaScript构建能够连接世界的应用。\n\n　　JavaScript这门语言水很深,他复杂的内部原理需要花费一段时间才能够真正的理解。其中的事件循环机制就不太好理解。很有可能一个多年使用JavaScript进行程序开发的人未必真正理解 JavaScript 的事件循环到底是怎么工作的。不管怎样,通过本篇博客,我希望能够揭示什么是事件循环以及能够让你觉得其实它真的没那么复杂。\n\n## 浏览器中的JavaScript\n\n　　当我们想到JavaScript时，我们通常会在Web浏览器的上下文中考虑它 - 这是有道理的，因为我们大多数情况下是在客户端中(浏览器)运行JavaScript。然后,我们需要清楚的知道(因为这很重要),运行一个web应用,涉及到一系列的技术术语,如 JavaScript 引擎(像chrome V8) , 一系列的Web API(像DOM,BOM),还有事件循环和事件队列。\n\n　　当看到这么多术语,你可能会想,\"我的天哪(食屎啦),看起来超级复杂。。。\",你的想法有一定道理,但是你很快会看到,应用运行的基本原理其实并没有那么复杂,虽然具体的底层实现超出了我们的范围。\n\n　　在我们深入到事件循环之前,我们需要理解下JavaScript引擎是干什么的?\n\n## JavaScript 引擎\n\n　　事实上,对于JavaScript引擎的实现有很多,但是目前为止最知名的就是谷歌的Chrome 的 V8 引擎(V8 引擎不仅仅只限存在于浏览器,它也存在于服务端,用于解析服务端的JavaScript 代码,如NodeJS)。那么,JavaScript 引擎到底做了些什么呢? 其实很简单,就是逐行逐句的处理JavaScript代码,没错,一次只能处理一句,所以JavaScript是单线程的。这样带来的主要问题是如果你运行的JavaScript语句需要很长时间才能返回,则这个语句后面的所有代码都会被阻塞。我们当然不希望我们写的代码会阻塞,特别是在浏览器端,可以想象一下,如果你在一个网站上点击一个按钮,然后代码就挂起了,你尝试去单击该网站页面上的其他按钮,但是并没有任何响应,会是怎么一种体验。这里最可能的原因是点击按钮触发的代码运行需要很长时间,使得后面的代码被阻塞,导致整个网站UI无法同时再响应用户的交互事件。\n\n　　那么 JavaScript 引擎是如何知道或者怎么做到一次只执行一句JavaScript语句的呢? 答案是通过调用栈,可以将调用栈想象成升降梯,第一个人进入升降梯将会在最后退出升降梯,然而最后一个进入的将会第一个出来。(作者在这里的比喻似乎不太好理解,但是大家肯定都学过数据结构中的栈,其特点就是先进后出)。我们看下下面的例子:\n\n```javascript\n/* Within main.js */\n\nvar firstFunction = function () {  \n  console.log(\"I'm first!\");\n};\n\nvar secondFunction = function () {  \n  firstFunction();\n  console.log(\"I'm second!\");\n};\n\nsecondFunction();\n\n/* Results:\n * => I'm first!\n * => I'm second!\n */\n```\n然后下面是调用栈中序列情况:\n\n* 首先是Main.js 匿名主函数被调用:\n\n  ![调用栈初始状态](http://altitudelabs.com/blog/content/images/2014/Jul/1-u51csgcFDi7SYoxnFljJ6w.png)\n\n* secondFunction 方法被调用:\n\n  ![secondFunction被调用](http://altitudelabs.com/blog/content/images/2014/Jul/1-QY4CM881bCmS908GSwlJiA.png)\n  \n* 调用 secondFunction 后导致 firstFunction 被调用:\n\n  ![firstFunction被调用](http://altitudelabs.com/blog/content/images/2014/Jul/1-pnI4YwJpXzt1mt1leOGl2Q.png)\n\n* 执行 firstFunction 在控制台中打印了 \"I'm first!\",执行完后 firstFunction 中没有更多的语句可以被执行了,所以 firstFunction 被移出了调用栈:\n\n  ![firstFunction返回](http://altitudelabs.com/blog/content/images/2014/Jul/1-AKybdhXXHbkvL6Eg4pNxDQ.png)\n  \n* 执行继续,到 secondFunction 中,\"I’m second!\" 输出到控制台,同样 secondFunction 中没有其他更多的代码要被执行了,所以也从调用栈中移出了。以此类推,最后调用栈会置空。\n\n  ![调用栈移出secondFunction](http://altitudelabs.com/blog/content/images/2014/Jul/1-Wx7x-aKIq2o7DmWlejRpeQ.png)\n  \n\n## 额,好的,但是我们能来讨论下事件循环吗?\n\n　　现在我们了解了JavaScript 引擎中的调用栈是怎么工作的,我们继续回到刚才说到代码阻塞那里,我们知道我们应该去避免它,但是应该怎么做呢?幸运的是 JavaScript 提供了一种机制,它通过异步函数,不要担心,异步函数其实和其他函数没什么区别,唯一区别是异步函数并不会立即马上执行,会在后面某个时间点被触发执行。如果你用过setTimeout函数,你已经对异步函数熟悉了。我们来看下下面的例子:\n\n```JavaScript\n/* Within main.js */\n\nvar firstFunction = function () {  \n console.log(\"I'm first!\");\n};\n\nvar secondFunction = function () {  \n setTimeout(firstFunction, 5000);\n console.log(\"I'm second!\");\n};\n\nsecondFunction();\n\n/* Results:\n * => I'm second!\n * (And 5 seconds later)\n * => I'm first!\n */\n```\n同样我们接下来看下调用栈中序列情况:\n\n* 在 secondFunction 执行到被放入调用栈之后,setTimeout 函数被调用,同样也放入了调用栈。\n\n  ![异步函数](http://altitudelabs.com/blog/content/images/2014/Jul/1-s7d9UjolRGGjqFtfK0wZ8w.png)\n  \n* 在 setTimeout 函数执行之后,有个特别的地方,浏览器将 setTimeout 的回调函数(在上面例子中,firstFunction) 放在了一个可以称为事件表(Event Table)的地方。 为了便于理解,我们可以将这个事件表想象成注册表:调用栈告诉事件表注册特定的函数,只有当特定的事件发生了,这个函数才能被执行(应该是放入事件队列)。然后当事件发生后,事件表就会简单的将函数移动到事件队列(Event Queue)中。此事件队列的美妙之处在于,它只是函数等待被调用和移动到调用栈的一个临时存放区域。\n\n* 你可能会问,\"既然这样,那么事件队列里的这些函数什么时候会被移动到调用栈中执行?\" 其实JavaScript引擎遵循着非常简单的规则:底层会有程序时不时的检查下调用栈是否为空,不管什么时候一旦为空,那么该程序会检查事件队列里是否会有正在等待被执行的函数。如果有,队列中的第一个函数会被移动到调用栈中然后被执行。如果事件队列为空,这个监视程序将会一直保持运行,瞧! 我刚刚描述的就是臭名昭着的事件循环(Event Loop)！\n\n* 现在回到刚才的例子,执行setTimeout 函数,将回调函数(例子中:firstFunction) 移动到事件记录表中,并且按照五秒的时间延时进行注册:\n  \n  ![在 setTimeout 执行之后](http://altitudelabs.com/blog/content/images/2014/Jul/1-XdKOatkDmsr-ft3nYs5wdQ.png)\n  \n* 这是另一个“啊哈！”的时刻 - 注意一旦回调函数被移动到事件表，没有任何东西(后面的代码)被阻塞！程序继续运行。\n  \n  ![在 secondFunction 执行之后](http://altitudelabs.com/blog/content/images/2014/Jul/1-f2g4OgjfB7WXfWuOJUTY5Q.png)\n  \n* 在幕后,事件表会时不时监视是否有事件发生从而触发将对应的函数移动到事件队列中等待被执行。在我们例子中,secondFunction 和 main.js 都完成了执行,调用栈为空。\n\n  ![在 main 执行结束后 ](http://altitudelabs.com/blog/content/images/2014/Jul/1-wLH1GZRlFvc0ZDawOB1XAQ.png)\n  \n* 在某一时刻,回调函数放在事件表中的时间将超过5秒。当发生这种情况时,事件表将firstFunction移动到事件队列中。\n  \n  ![过了5秒后](http://altitudelabs.com/blog/content/images/2014/Jul/1-0oy202Rt-94BDKOxKURVtw.png)\n\n* 在事件循环不断监视调用栈是否为空,现在确实是空的时候,调用fistFunction,创建一个新的调用栈来执行代码。\n\n  ![执行firstFunction](http://altitudelabs.com/blog/content/images/2014/Jul/1-9Vpvh23CJNmxHVbkwrNpyQ.png)\n  \n* 在执行完firstFunction之后,进入了一个新的状态,这个状态调用栈为空,事件记录表为空,事件队列也为空。监视程序一种保持运行,一旦事件队列中存在待执行的函数,就会重复前面的步骤,执行函数,这就是事件循环。\n\n  ![此时状态](http://altitudelabs.com/blog/content/images/2014/Jul/1-MmPtbaLvP54DuH-jHAjEXg.png)\n  \n  \n## 总结\n\n　　我第一个承认我的解释掩盖了JavaScript引擎，事件表，事件队列和事件循环底层的实际实现细节。 然而，对于我们绝大多数人来说，我们只需要对JavaScript执行异步功能时发生的情况有一个坚实的基础理解就可以了。 并且，我希望上面的解释能够对你理解事件循环有帮助，这将是我们作为Web开发人员所必需要了解的。","source":"_posts/javascript-event-loop.md","raw":"---\ntitle: 什么是JavaScript 事件循环 ?\ntype: translate\ntags: [JavaScript]\ncategories: [nodeclub源码学习]\ndate: 2017-05-03 11:33:10\ndescription:\n---\n\n\n　　这篇文章是对个人认为讲解　JavaScript　事件循环比较清楚的一篇英文文章的简单翻译,原文地址是http://altitudelabs.com/blog/what-is-the-javascript-event-loop/。\n\n<!--　more　-->\n\n## 介绍\n\n　　如果你像我一样,喜欢JavaScript,是的,你肯定也会认同,JavaScript这门语言并不完美,严肃的说,没有任何一门计算机语言是完美的。尽管JavaScript确实存在一些缺陷,但我喜欢编写web程序以及如何用JavaScript构建能够连接世界的应用。\n\n　　JavaScript这门语言水很深,他复杂的内部原理需要花费一段时间才能够真正的理解。其中的事件循环机制就不太好理解。很有可能一个多年使用JavaScript进行程序开发的人未必真正理解 JavaScript 的事件循环到底是怎么工作的。不管怎样,通过本篇博客,我希望能够揭示什么是事件循环以及能够让你觉得其实它真的没那么复杂。\n\n## 浏览器中的JavaScript\n\n　　当我们想到JavaScript时，我们通常会在Web浏览器的上下文中考虑它 - 这是有道理的，因为我们大多数情况下是在客户端中(浏览器)运行JavaScript。然后,我们需要清楚的知道(因为这很重要),运行一个web应用,涉及到一系列的技术术语,如 JavaScript 引擎(像chrome V8) , 一系列的Web API(像DOM,BOM),还有事件循环和事件队列。\n\n　　当看到这么多术语,你可能会想,\"我的天哪(食屎啦),看起来超级复杂。。。\",你的想法有一定道理,但是你很快会看到,应用运行的基本原理其实并没有那么复杂,虽然具体的底层实现超出了我们的范围。\n\n　　在我们深入到事件循环之前,我们需要理解下JavaScript引擎是干什么的?\n\n## JavaScript 引擎\n\n　　事实上,对于JavaScript引擎的实现有很多,但是目前为止最知名的就是谷歌的Chrome 的 V8 引擎(V8 引擎不仅仅只限存在于浏览器,它也存在于服务端,用于解析服务端的JavaScript 代码,如NodeJS)。那么,JavaScript 引擎到底做了些什么呢? 其实很简单,就是逐行逐句的处理JavaScript代码,没错,一次只能处理一句,所以JavaScript是单线程的。这样带来的主要问题是如果你运行的JavaScript语句需要很长时间才能返回,则这个语句后面的所有代码都会被阻塞。我们当然不希望我们写的代码会阻塞,特别是在浏览器端,可以想象一下,如果你在一个网站上点击一个按钮,然后代码就挂起了,你尝试去单击该网站页面上的其他按钮,但是并没有任何响应,会是怎么一种体验。这里最可能的原因是点击按钮触发的代码运行需要很长时间,使得后面的代码被阻塞,导致整个网站UI无法同时再响应用户的交互事件。\n\n　　那么 JavaScript 引擎是如何知道或者怎么做到一次只执行一句JavaScript语句的呢? 答案是通过调用栈,可以将调用栈想象成升降梯,第一个人进入升降梯将会在最后退出升降梯,然而最后一个进入的将会第一个出来。(作者在这里的比喻似乎不太好理解,但是大家肯定都学过数据结构中的栈,其特点就是先进后出)。我们看下下面的例子:\n\n```javascript\n/* Within main.js */\n\nvar firstFunction = function () {  \n  console.log(\"I'm first!\");\n};\n\nvar secondFunction = function () {  \n  firstFunction();\n  console.log(\"I'm second!\");\n};\n\nsecondFunction();\n\n/* Results:\n * => I'm first!\n * => I'm second!\n */\n```\n然后下面是调用栈中序列情况:\n\n* 首先是Main.js 匿名主函数被调用:\n\n  ![调用栈初始状态](http://altitudelabs.com/blog/content/images/2014/Jul/1-u51csgcFDi7SYoxnFljJ6w.png)\n\n* secondFunction 方法被调用:\n\n  ![secondFunction被调用](http://altitudelabs.com/blog/content/images/2014/Jul/1-QY4CM881bCmS908GSwlJiA.png)\n  \n* 调用 secondFunction 后导致 firstFunction 被调用:\n\n  ![firstFunction被调用](http://altitudelabs.com/blog/content/images/2014/Jul/1-pnI4YwJpXzt1mt1leOGl2Q.png)\n\n* 执行 firstFunction 在控制台中打印了 \"I'm first!\",执行完后 firstFunction 中没有更多的语句可以被执行了,所以 firstFunction 被移出了调用栈:\n\n  ![firstFunction返回](http://altitudelabs.com/blog/content/images/2014/Jul/1-AKybdhXXHbkvL6Eg4pNxDQ.png)\n  \n* 执行继续,到 secondFunction 中,\"I’m second!\" 输出到控制台,同样 secondFunction 中没有其他更多的代码要被执行了,所以也从调用栈中移出了。以此类推,最后调用栈会置空。\n\n  ![调用栈移出secondFunction](http://altitudelabs.com/blog/content/images/2014/Jul/1-Wx7x-aKIq2o7DmWlejRpeQ.png)\n  \n\n## 额,好的,但是我们能来讨论下事件循环吗?\n\n　　现在我们了解了JavaScript 引擎中的调用栈是怎么工作的,我们继续回到刚才说到代码阻塞那里,我们知道我们应该去避免它,但是应该怎么做呢?幸运的是 JavaScript 提供了一种机制,它通过异步函数,不要担心,异步函数其实和其他函数没什么区别,唯一区别是异步函数并不会立即马上执行,会在后面某个时间点被触发执行。如果你用过setTimeout函数,你已经对异步函数熟悉了。我们来看下下面的例子:\n\n```JavaScript\n/* Within main.js */\n\nvar firstFunction = function () {  \n console.log(\"I'm first!\");\n};\n\nvar secondFunction = function () {  \n setTimeout(firstFunction, 5000);\n console.log(\"I'm second!\");\n};\n\nsecondFunction();\n\n/* Results:\n * => I'm second!\n * (And 5 seconds later)\n * => I'm first!\n */\n```\n同样我们接下来看下调用栈中序列情况:\n\n* 在 secondFunction 执行到被放入调用栈之后,setTimeout 函数被调用,同样也放入了调用栈。\n\n  ![异步函数](http://altitudelabs.com/blog/content/images/2014/Jul/1-s7d9UjolRGGjqFtfK0wZ8w.png)\n  \n* 在 setTimeout 函数执行之后,有个特别的地方,浏览器将 setTimeout 的回调函数(在上面例子中,firstFunction) 放在了一个可以称为事件表(Event Table)的地方。 为了便于理解,我们可以将这个事件表想象成注册表:调用栈告诉事件表注册特定的函数,只有当特定的事件发生了,这个函数才能被执行(应该是放入事件队列)。然后当事件发生后,事件表就会简单的将函数移动到事件队列(Event Queue)中。此事件队列的美妙之处在于,它只是函数等待被调用和移动到调用栈的一个临时存放区域。\n\n* 你可能会问,\"既然这样,那么事件队列里的这些函数什么时候会被移动到调用栈中执行?\" 其实JavaScript引擎遵循着非常简单的规则:底层会有程序时不时的检查下调用栈是否为空,不管什么时候一旦为空,那么该程序会检查事件队列里是否会有正在等待被执行的函数。如果有,队列中的第一个函数会被移动到调用栈中然后被执行。如果事件队列为空,这个监视程序将会一直保持运行,瞧! 我刚刚描述的就是臭名昭着的事件循环(Event Loop)！\n\n* 现在回到刚才的例子,执行setTimeout 函数,将回调函数(例子中:firstFunction) 移动到事件记录表中,并且按照五秒的时间延时进行注册:\n  \n  ![在 setTimeout 执行之后](http://altitudelabs.com/blog/content/images/2014/Jul/1-XdKOatkDmsr-ft3nYs5wdQ.png)\n  \n* 这是另一个“啊哈！”的时刻 - 注意一旦回调函数被移动到事件表，没有任何东西(后面的代码)被阻塞！程序继续运行。\n  \n  ![在 secondFunction 执行之后](http://altitudelabs.com/blog/content/images/2014/Jul/1-f2g4OgjfB7WXfWuOJUTY5Q.png)\n  \n* 在幕后,事件表会时不时监视是否有事件发生从而触发将对应的函数移动到事件队列中等待被执行。在我们例子中,secondFunction 和 main.js 都完成了执行,调用栈为空。\n\n  ![在 main 执行结束后 ](http://altitudelabs.com/blog/content/images/2014/Jul/1-wLH1GZRlFvc0ZDawOB1XAQ.png)\n  \n* 在某一时刻,回调函数放在事件表中的时间将超过5秒。当发生这种情况时,事件表将firstFunction移动到事件队列中。\n  \n  ![过了5秒后](http://altitudelabs.com/blog/content/images/2014/Jul/1-0oy202Rt-94BDKOxKURVtw.png)\n\n* 在事件循环不断监视调用栈是否为空,现在确实是空的时候,调用fistFunction,创建一个新的调用栈来执行代码。\n\n  ![执行firstFunction](http://altitudelabs.com/blog/content/images/2014/Jul/1-9Vpvh23CJNmxHVbkwrNpyQ.png)\n  \n* 在执行完firstFunction之后,进入了一个新的状态,这个状态调用栈为空,事件记录表为空,事件队列也为空。监视程序一种保持运行,一旦事件队列中存在待执行的函数,就会重复前面的步骤,执行函数,这就是事件循环。\n\n  ![此时状态](http://altitudelabs.com/blog/content/images/2014/Jul/1-MmPtbaLvP54DuH-jHAjEXg.png)\n  \n  \n## 总结\n\n　　我第一个承认我的解释掩盖了JavaScript引擎，事件表，事件队列和事件循环底层的实际实现细节。 然而，对于我们绝大多数人来说，我们只需要对JavaScript执行异步功能时发生的情况有一个坚实的基础理解就可以了。 并且，我希望上面的解释能够对你理解事件循环有帮助，这将是我们作为Web开发人员所必需要了解的。","slug":"javascript-event-loop","published":1,"updated":"2017-05-05T14:55:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhqa000hb37q1n19fhcq","content":"<p>　　这篇文章是对个人认为讲解　JavaScript　事件循环比较清楚的一篇英文文章的简单翻译,原文地址是<a href=\"http://altitudelabs.com/blog/what-is-the-javascript-event-loop/。\" target=\"_blank\" rel=\"external\">http://altitudelabs.com/blog/what-is-the-javascript-event-loop/。</a></p>\n<a id=\"more\"></a>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>　　如果你像我一样,喜欢JavaScript,是的,你肯定也会认同,JavaScript这门语言并不完美,严肃的说,没有任何一门计算机语言是完美的。尽管JavaScript确实存在一些缺陷,但我喜欢编写web程序以及如何用JavaScript构建能够连接世界的应用。</p>\n<p>　　JavaScript这门语言水很深,他复杂的内部原理需要花费一段时间才能够真正的理解。其中的事件循环机制就不太好理解。很有可能一个多年使用JavaScript进行程序开发的人未必真正理解 JavaScript 的事件循环到底是怎么工作的。不管怎样,通过本篇博客,我希望能够揭示什么是事件循环以及能够让你觉得其实它真的没那么复杂。</p>\n<h2 id=\"浏览器中的JavaScript\"><a href=\"#浏览器中的JavaScript\" class=\"headerlink\" title=\"浏览器中的JavaScript\"></a>浏览器中的JavaScript</h2><p>　　当我们想到JavaScript时，我们通常会在Web浏览器的上下文中考虑它 - 这是有道理的，因为我们大多数情况下是在客户端中(浏览器)运行JavaScript。然后,我们需要清楚的知道(因为这很重要),运行一个web应用,涉及到一系列的技术术语,如 JavaScript 引擎(像chrome V8) , 一系列的Web API(像DOM,BOM),还有事件循环和事件队列。</p>\n<p>　　当看到这么多术语,你可能会想,”我的天哪(食屎啦),看起来超级复杂。。。”,你的想法有一定道理,但是你很快会看到,应用运行的基本原理其实并没有那么复杂,虽然具体的底层实现超出了我们的范围。</p>\n<p>　　在我们深入到事件循环之前,我们需要理解下JavaScript引擎是干什么的?</p>\n<h2 id=\"JavaScript-引擎\"><a href=\"#JavaScript-引擎\" class=\"headerlink\" title=\"JavaScript 引擎\"></a>JavaScript 引擎</h2><p>　　事实上,对于JavaScript引擎的实现有很多,但是目前为止最知名的就是谷歌的Chrome 的 V8 引擎(V8 引擎不仅仅只限存在于浏览器,它也存在于服务端,用于解析服务端的JavaScript 代码,如NodeJS)。那么,JavaScript 引擎到底做了些什么呢? 其实很简单,就是逐行逐句的处理JavaScript代码,没错,一次只能处理一句,所以JavaScript是单线程的。这样带来的主要问题是如果你运行的JavaScript语句需要很长时间才能返回,则这个语句后面的所有代码都会被阻塞。我们当然不希望我们写的代码会阻塞,特别是在浏览器端,可以想象一下,如果你在一个网站上点击一个按钮,然后代码就挂起了,你尝试去单击该网站页面上的其他按钮,但是并没有任何响应,会是怎么一种体验。这里最可能的原因是点击按钮触发的代码运行需要很长时间,使得后面的代码被阻塞,导致整个网站UI无法同时再响应用户的交互事件。</p>\n<p>　　那么 JavaScript 引擎是如何知道或者怎么做到一次只执行一句JavaScript语句的呢? 答案是通过调用栈,可以将调用栈想象成升降梯,第一个人进入升降梯将会在最后退出升降梯,然而最后一个进入的将会第一个出来。(作者在这里的比喻似乎不太好理解,但是大家肯定都学过数据结构中的栈,其特点就是先进后出)。我们看下下面的例子:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Within main.js */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> firstFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm first!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> secondFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </div><div class=\"line\">  firstFunction();</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm second!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">secondFunction();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Results:</span></div><div class=\"line\"> * =&gt; I'm first!</div><div class=\"line\"> * =&gt; I'm second!</div><div class=\"line\"> */</div></pre></td></tr></table></figure>\n<p>然后下面是调用栈中序列情况:</p>\n<ul>\n<li><p>首先是Main.js 匿名主函数被调用:</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-u51csgcFDi7SYoxnFljJ6w.png\" alt=\"调用栈初始状态\"></p>\n</li>\n<li><p>secondFunction 方法被调用:</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-QY4CM881bCmS908GSwlJiA.png\" alt=\"secondFunction被调用\"></p>\n</li>\n<li><p>调用 secondFunction 后导致 firstFunction 被调用:</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-pnI4YwJpXzt1mt1leOGl2Q.png\" alt=\"firstFunction被调用\"></p>\n</li>\n<li><p>执行 firstFunction 在控制台中打印了 “I’m first!”,执行完后 firstFunction 中没有更多的语句可以被执行了,所以 firstFunction 被移出了调用栈:</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-AKybdhXXHbkvL6Eg4pNxDQ.png\" alt=\"firstFunction返回\"></p>\n</li>\n<li><p>执行继续,到 secondFunction 中,”I’m second!” 输出到控制台,同样 secondFunction 中没有其他更多的代码要被执行了,所以也从调用栈中移出了。以此类推,最后调用栈会置空。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-Wx7x-aKIq2o7DmWlejRpeQ.png\" alt=\"调用栈移出secondFunction\"></p>\n</li>\n</ul>\n<h2 id=\"额-好的-但是我们能来讨论下事件循环吗\"><a href=\"#额-好的-但是我们能来讨论下事件循环吗\" class=\"headerlink\" title=\"额,好的,但是我们能来讨论下事件循环吗?\"></a>额,好的,但是我们能来讨论下事件循环吗?</h2><p>　　现在我们了解了JavaScript 引擎中的调用栈是怎么工作的,我们继续回到刚才说到代码阻塞那里,我们知道我们应该去避免它,但是应该怎么做呢?幸运的是 JavaScript 提供了一种机制,它通过异步函数,不要担心,异步函数其实和其他函数没什么区别,唯一区别是异步函数并不会立即马上执行,会在后面某个时间点被触发执行。如果你用过setTimeout函数,你已经对异步函数熟悉了。我们来看下下面的例子:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Within main.js */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> firstFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </div><div class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm first!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> secondFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </div><div class=\"line\"> setTimeout(firstFunction, <span class=\"number\">5000</span>);</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm second!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">secondFunction();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Results:</span></div><div class=\"line\"> * =&gt; I'm second!</div><div class=\"line\"> * (And 5 seconds later)</div><div class=\"line\"> * =&gt; I'm first!</div><div class=\"line\"> */</div></pre></td></tr></table></figure>\n<p>同样我们接下来看下调用栈中序列情况:</p>\n<ul>\n<li><p>在 secondFunction 执行到被放入调用栈之后,setTimeout 函数被调用,同样也放入了调用栈。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-s7d9UjolRGGjqFtfK0wZ8w.png\" alt=\"异步函数\"></p>\n</li>\n<li><p>在 setTimeout 函数执行之后,有个特别的地方,浏览器将 setTimeout 的回调函数(在上面例子中,firstFunction) 放在了一个可以称为事件表(Event Table)的地方。 为了便于理解,我们可以将这个事件表想象成注册表:调用栈告诉事件表注册特定的函数,只有当特定的事件发生了,这个函数才能被执行(应该是放入事件队列)。然后当事件发生后,事件表就会简单的将函数移动到事件队列(Event Queue)中。此事件队列的美妙之处在于,它只是函数等待被调用和移动到调用栈的一个临时存放区域。</p>\n</li>\n<li><p>你可能会问,”既然这样,那么事件队列里的这些函数什么时候会被移动到调用栈中执行?” 其实JavaScript引擎遵循着非常简单的规则:底层会有程序时不时的检查下调用栈是否为空,不管什么时候一旦为空,那么该程序会检查事件队列里是否会有正在等待被执行的函数。如果有,队列中的第一个函数会被移动到调用栈中然后被执行。如果事件队列为空,这个监视程序将会一直保持运行,瞧! 我刚刚描述的就是臭名昭着的事件循环(Event Loop)！</p>\n</li>\n<li><p>现在回到刚才的例子,执行setTimeout 函数,将回调函数(例子中:firstFunction) 移动到事件记录表中,并且按照五秒的时间延时进行注册:</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-XdKOatkDmsr-ft3nYs5wdQ.png\" alt=\"在 setTimeout 执行之后\"></p>\n</li>\n<li><p>这是另一个“啊哈！”的时刻 - 注意一旦回调函数被移动到事件表，没有任何东西(后面的代码)被阻塞！程序继续运行。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-f2g4OgjfB7WXfWuOJUTY5Q.png\" alt=\"在 secondFunction 执行之后\"></p>\n</li>\n<li><p>在幕后,事件表会时不时监视是否有事件发生从而触发将对应的函数移动到事件队列中等待被执行。在我们例子中,secondFunction 和 main.js 都完成了执行,调用栈为空。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-wLH1GZRlFvc0ZDawOB1XAQ.png\" alt=\"在 main 执行结束后 \"></p>\n</li>\n<li><p>在某一时刻,回调函数放在事件表中的时间将超过5秒。当发生这种情况时,事件表将firstFunction移动到事件队列中。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-0oy202Rt-94BDKOxKURVtw.png\" alt=\"过了5秒后\"></p>\n</li>\n<li><p>在事件循环不断监视调用栈是否为空,现在确实是空的时候,调用fistFunction,创建一个新的调用栈来执行代码。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-9Vpvh23CJNmxHVbkwrNpyQ.png\" alt=\"执行firstFunction\"></p>\n</li>\n<li><p>在执行完firstFunction之后,进入了一个新的状态,这个状态调用栈为空,事件记录表为空,事件队列也为空。监视程序一种保持运行,一旦事件队列中存在待执行的函数,就会重复前面的步骤,执行函数,这就是事件循环。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-MmPtbaLvP54DuH-jHAjEXg.png\" alt=\"此时状态\"></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>　　我第一个承认我的解释掩盖了JavaScript引擎，事件表，事件队列和事件循环底层的实际实现细节。 然而，对于我们绝大多数人来说，我们只需要对JavaScript执行异步功能时发生的情况有一个坚实的基础理解就可以了。 并且，我希望上面的解释能够对你理解事件循环有帮助，这将是我们作为Web开发人员所必需要了解的。</p>\n","site":{"data":{}},"excerpt":"<p>　　这篇文章是对个人认为讲解　JavaScript　事件循环比较清楚的一篇英文文章的简单翻译,原文地址是<a href=\"http://altitudelabs.com/blog/what-is-the-javascript-event-loop/。\" target=\"_blank\" rel=\"external\">http://altitudelabs.com/blog/what-is-the-javascript-event-loop/。</a></p>","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>　　如果你像我一样,喜欢JavaScript,是的,你肯定也会认同,JavaScript这门语言并不完美,严肃的说,没有任何一门计算机语言是完美的。尽管JavaScript确实存在一些缺陷,但我喜欢编写web程序以及如何用JavaScript构建能够连接世界的应用。</p>\n<p>　　JavaScript这门语言水很深,他复杂的内部原理需要花费一段时间才能够真正的理解。其中的事件循环机制就不太好理解。很有可能一个多年使用JavaScript进行程序开发的人未必真正理解 JavaScript 的事件循环到底是怎么工作的。不管怎样,通过本篇博客,我希望能够揭示什么是事件循环以及能够让你觉得其实它真的没那么复杂。</p>\n<h2 id=\"浏览器中的JavaScript\"><a href=\"#浏览器中的JavaScript\" class=\"headerlink\" title=\"浏览器中的JavaScript\"></a>浏览器中的JavaScript</h2><p>　　当我们想到JavaScript时，我们通常会在Web浏览器的上下文中考虑它 - 这是有道理的，因为我们大多数情况下是在客户端中(浏览器)运行JavaScript。然后,我们需要清楚的知道(因为这很重要),运行一个web应用,涉及到一系列的技术术语,如 JavaScript 引擎(像chrome V8) , 一系列的Web API(像DOM,BOM),还有事件循环和事件队列。</p>\n<p>　　当看到这么多术语,你可能会想,”我的天哪(食屎啦),看起来超级复杂。。。”,你的想法有一定道理,但是你很快会看到,应用运行的基本原理其实并没有那么复杂,虽然具体的底层实现超出了我们的范围。</p>\n<p>　　在我们深入到事件循环之前,我们需要理解下JavaScript引擎是干什么的?</p>\n<h2 id=\"JavaScript-引擎\"><a href=\"#JavaScript-引擎\" class=\"headerlink\" title=\"JavaScript 引擎\"></a>JavaScript 引擎</h2><p>　　事实上,对于JavaScript引擎的实现有很多,但是目前为止最知名的就是谷歌的Chrome 的 V8 引擎(V8 引擎不仅仅只限存在于浏览器,它也存在于服务端,用于解析服务端的JavaScript 代码,如NodeJS)。那么,JavaScript 引擎到底做了些什么呢? 其实很简单,就是逐行逐句的处理JavaScript代码,没错,一次只能处理一句,所以JavaScript是单线程的。这样带来的主要问题是如果你运行的JavaScript语句需要很长时间才能返回,则这个语句后面的所有代码都会被阻塞。我们当然不希望我们写的代码会阻塞,特别是在浏览器端,可以想象一下,如果你在一个网站上点击一个按钮,然后代码就挂起了,你尝试去单击该网站页面上的其他按钮,但是并没有任何响应,会是怎么一种体验。这里最可能的原因是点击按钮触发的代码运行需要很长时间,使得后面的代码被阻塞,导致整个网站UI无法同时再响应用户的交互事件。</p>\n<p>　　那么 JavaScript 引擎是如何知道或者怎么做到一次只执行一句JavaScript语句的呢? 答案是通过调用栈,可以将调用栈想象成升降梯,第一个人进入升降梯将会在最后退出升降梯,然而最后一个进入的将会第一个出来。(作者在这里的比喻似乎不太好理解,但是大家肯定都学过数据结构中的栈,其特点就是先进后出)。我们看下下面的例子:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Within main.js */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> firstFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm first!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> secondFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </div><div class=\"line\">  firstFunction();</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm second!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">secondFunction();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Results:</span></div><div class=\"line\"> * =&gt; I'm first!</div><div class=\"line\"> * =&gt; I'm second!</div><div class=\"line\"> */</div></pre></td></tr></table></figure>\n<p>然后下面是调用栈中序列情况:</p>\n<ul>\n<li><p>首先是Main.js 匿名主函数被调用:</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-u51csgcFDi7SYoxnFljJ6w.png\" alt=\"调用栈初始状态\"></p>\n</li>\n<li><p>secondFunction 方法被调用:</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-QY4CM881bCmS908GSwlJiA.png\" alt=\"secondFunction被调用\"></p>\n</li>\n<li><p>调用 secondFunction 后导致 firstFunction 被调用:</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-pnI4YwJpXzt1mt1leOGl2Q.png\" alt=\"firstFunction被调用\"></p>\n</li>\n<li><p>执行 firstFunction 在控制台中打印了 “I’m first!”,执行完后 firstFunction 中没有更多的语句可以被执行了,所以 firstFunction 被移出了调用栈:</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-AKybdhXXHbkvL6Eg4pNxDQ.png\" alt=\"firstFunction返回\"></p>\n</li>\n<li><p>执行继续,到 secondFunction 中,”I’m second!” 输出到控制台,同样 secondFunction 中没有其他更多的代码要被执行了,所以也从调用栈中移出了。以此类推,最后调用栈会置空。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-Wx7x-aKIq2o7DmWlejRpeQ.png\" alt=\"调用栈移出secondFunction\"></p>\n</li>\n</ul>\n<h2 id=\"额-好的-但是我们能来讨论下事件循环吗\"><a href=\"#额-好的-但是我们能来讨论下事件循环吗\" class=\"headerlink\" title=\"额,好的,但是我们能来讨论下事件循环吗?\"></a>额,好的,但是我们能来讨论下事件循环吗?</h2><p>　　现在我们了解了JavaScript 引擎中的调用栈是怎么工作的,我们继续回到刚才说到代码阻塞那里,我们知道我们应该去避免它,但是应该怎么做呢?幸运的是 JavaScript 提供了一种机制,它通过异步函数,不要担心,异步函数其实和其他函数没什么区别,唯一区别是异步函数并不会立即马上执行,会在后面某个时间点被触发执行。如果你用过setTimeout函数,你已经对异步函数熟悉了。我们来看下下面的例子:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* Within main.js */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> firstFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </div><div class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm first!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> secondFunction = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  </div><div class=\"line\"> setTimeout(firstFunction, <span class=\"number\">5000</span>);</div><div class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm second!\"</span>);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">secondFunction();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* Results:</span></div><div class=\"line\"> * =&gt; I'm second!</div><div class=\"line\"> * (And 5 seconds later)</div><div class=\"line\"> * =&gt; I'm first!</div><div class=\"line\"> */</div></pre></td></tr></table></figure>\n<p>同样我们接下来看下调用栈中序列情况:</p>\n<ul>\n<li><p>在 secondFunction 执行到被放入调用栈之后,setTimeout 函数被调用,同样也放入了调用栈。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-s7d9UjolRGGjqFtfK0wZ8w.png\" alt=\"异步函数\"></p>\n</li>\n<li><p>在 setTimeout 函数执行之后,有个特别的地方,浏览器将 setTimeout 的回调函数(在上面例子中,firstFunction) 放在了一个可以称为事件表(Event Table)的地方。 为了便于理解,我们可以将这个事件表想象成注册表:调用栈告诉事件表注册特定的函数,只有当特定的事件发生了,这个函数才能被执行(应该是放入事件队列)。然后当事件发生后,事件表就会简单的将函数移动到事件队列(Event Queue)中。此事件队列的美妙之处在于,它只是函数等待被调用和移动到调用栈的一个临时存放区域。</p>\n</li>\n<li><p>你可能会问,”既然这样,那么事件队列里的这些函数什么时候会被移动到调用栈中执行?” 其实JavaScript引擎遵循着非常简单的规则:底层会有程序时不时的检查下调用栈是否为空,不管什么时候一旦为空,那么该程序会检查事件队列里是否会有正在等待被执行的函数。如果有,队列中的第一个函数会被移动到调用栈中然后被执行。如果事件队列为空,这个监视程序将会一直保持运行,瞧! 我刚刚描述的就是臭名昭着的事件循环(Event Loop)！</p>\n</li>\n<li><p>现在回到刚才的例子,执行setTimeout 函数,将回调函数(例子中:firstFunction) 移动到事件记录表中,并且按照五秒的时间延时进行注册:</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-XdKOatkDmsr-ft3nYs5wdQ.png\" alt=\"在 setTimeout 执行之后\"></p>\n</li>\n<li><p>这是另一个“啊哈！”的时刻 - 注意一旦回调函数被移动到事件表，没有任何东西(后面的代码)被阻塞！程序继续运行。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-f2g4OgjfB7WXfWuOJUTY5Q.png\" alt=\"在 secondFunction 执行之后\"></p>\n</li>\n<li><p>在幕后,事件表会时不时监视是否有事件发生从而触发将对应的函数移动到事件队列中等待被执行。在我们例子中,secondFunction 和 main.js 都完成了执行,调用栈为空。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-wLH1GZRlFvc0ZDawOB1XAQ.png\" alt=\"在 main 执行结束后 \"></p>\n</li>\n<li><p>在某一时刻,回调函数放在事件表中的时间将超过5秒。当发生这种情况时,事件表将firstFunction移动到事件队列中。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-0oy202Rt-94BDKOxKURVtw.png\" alt=\"过了5秒后\"></p>\n</li>\n<li><p>在事件循环不断监视调用栈是否为空,现在确实是空的时候,调用fistFunction,创建一个新的调用栈来执行代码。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-9Vpvh23CJNmxHVbkwrNpyQ.png\" alt=\"执行firstFunction\"></p>\n</li>\n<li><p>在执行完firstFunction之后,进入了一个新的状态,这个状态调用栈为空,事件记录表为空,事件队列也为空。监视程序一种保持运行,一旦事件队列中存在待执行的函数,就会重复前面的步骤,执行函数,这就是事件循环。</p>\n<p><img src=\"http://altitudelabs.com/blog/content/images/2014/Jul/1-MmPtbaLvP54DuH-jHAjEXg.png\" alt=\"此时状态\"></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>　　我第一个承认我的解释掩盖了JavaScript引擎，事件表，事件队列和事件循环底层的实际实现细节。 然而，对于我们绝大多数人来说，我们只需要对JavaScript执行异步功能时发生的情况有一个坚实的基础理解就可以了。 并且，我希望上面的解释能够对你理解事件循环有帮助，这将是我们作为Web开发人员所必需要了解的。</p>"},{"title":"Node Stream 初窥","date":"2017-04-26T03:13:00.000Z","description":"Node 将几乎所有 IO 操作都抽象成了 Stream 的操作。Stream 是一个抽象的概念，可以将Stream 想象成水流管道,管道有只用于输出的,有只接收的,有负责中间过渡的(既有输入的一端,也有输出的一端)。总之就是生产东西,或者消费东西,这个东西可以是Buffer,可以是String,甚至是可以Object。","_content":"\nNode 将几乎所有 IO 操作都抽象成了 Stream 的操作。Stream 是一个抽象的概念，可以将Stream 想象成水流管道,管道有只用于输出的,有只接收的,有负责中间过渡的(既有输入的一端,也有输出的一端)。总之就是生产东西,或者消费东西,这个东西可以是Buffer,可以是String,甚至是可以Object。从Node 官方文档对Stream的定义,\n\n>A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter\n\n我们可以了解到 :\n* Stream是Node中一个非常重要的概念，被大量对象实现，尤其是Node中的I/O操作\n* Stream是一个抽像的接口，一般不会直接使用，需要实现内部的某些抽象方法(例如_read、_write、_transform)\n* Stream是EventEmitter的子类，实际上Stream的数据传递内部依然是通过事件(data)来实现的\n\n那为什么会需要流。看下面这段代码:\n\n```javascript\nvar http = require('http');\nvar fs = require('fs');\n\nvar server = http.createServer(function (req, res) {\n    // req is an http.IncomingMessage, which is a Readable Stream\n    // res is an http.ServerResponse, which is a Writable Stream\n    fs.readFile(__dirname + '/data.txt', function (err, data) {\n        res.end(data);\n    });\n});\nserver.listen(8000);\n```\n\n> 每次当请求过来,程序都会接收到这个请求,然后去读``data.txt``文件,并把内容返回。但是每次读的时候都会把``data.txt``整个读入内存,在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。其次，上面的代码可能会造成很不好的用户体验，因为用户在接收到任何的内容之前首先需要等待程序将文件内容完全读入到内存中。所以更好的办法就是需要多少给多少,而不是一股脑的将整个数据放到内存中,通过流可以实现这一的效果。\n\n```\nvar http = require('http');\nvar fs = require('fs');\n\nvar server = http.createServer(function (req, res) {\n    // req is an http.IncomingMessage, which is a Readable Stream\n    // res is an http.ServerResponse, which is a Writable Stream\n    var stream = fs.createReadStream(__dirname + '/data.txt');\n    stream.pipe(res);\n});\nserver.listen(8000);\n```\n\n### Node 中Stream的类型\n\n在Node.js中,有四种基本的流类型,他们分别是:``Readable`` ,``Writable``,``Duplex ``,``Transform ``。流一般处理的数据类型都是String 和 Buffer的,但是你可以通过在创建流的时候指定选项参数``objectMode``,创建对象流,不过需要注意的是,尝试将已存在的流的模式切换成对象流是一种不安全的不被建议的操作。\n\n不管是``Readable`` 还是 ``Writable`` 流,工作的过程都会将数据保存在内部的一个缓冲区中,可以分别通过``readable._readableState.buffer`` , ``writable._writableState.getBuffer()`` 取出buffer内容。我们可以通过选项参数``highWaterMark``控制缓冲区的大小,对于String 或者 Buffer流来说,highWaterMark 控制的字节数,对于对象流,highWaterMark控制的是对象的个数。\n\n#### 1. ``Readable``\n\n可读流,是输出流,通过``readable.push(chunk)``将数据读入流的缓冲区以供读取,消费者可以通过``readable.read()``读取流中的数据,如果缓冲区中的数据一直没有被消费掉,一旦到达 ``highWaterMark`` 设置的阈值,那么输出流就会停止往缓冲区中放数据,知道有消费者消耗掉这些数据。\n\n> Once the total size of the internal read buffer reaches the threshold specified by highWaterMark, the stream will temporarily stop reading data from the underlying resource until the data currently buffered can be consumed (that is, the stream will stop calling the internal readable._read() method that is used to fill the read buffer).\n\nReadable 有两种模式,分别是 flowing 和 paused 模式。flowing 模式,会自动的从源读取数据通过事件的方式提供给应用消费,而paused 模式需要显示手动调用readable.read()方法,从流中读取数据。所有的Readable流一开始都是paused模式,但是可以通过下面的几种方法切换成flowing 模式:\n1. 添加``data``事件处理器。\n2. 调用 `` readable.resume()`` 方法。\n3. 调用 ``readable.pipe() `` 方法发送数据到Writeable 流。\n\n只要监听了``data``事件或者是调用`` readable.resume()``,``readable.pipe() ``方法,都会将``readable._readableState.flowing`` 设置为true。使得Readable当数据生成时不断的触发data事件。流程图大致如下:\n\n![Readable 流程](http://tech.meituan.com/img/stream-how-data-comes-out.png)\n\n同样可以通过一些方式将模式从 flowing 切换回 paused。 具体方法参考官方文档。\n\n#### 2. ``Writable``\n\n可写流,输入流,是对数据写入目标的一个抽象,将内容通过`` writable.write(chunk) ``存入流缓冲区中,如果没有超出限制,则返回true,如果超出限制,则返回false。\n\n* 实现自己的``Writable``\n\n  > 继承``Writable`` ,重写方法``_write``,``_writev``,任何的可写流都必须提供方法``_write``,用于将数据写入底层资源(如某个文件)。实现自己的``Writable``代码如下:\n\n  ```javascript\n    //写法1:\n    const Writable = require('stream').Writable;\n\n    class MyWritable extends Writable {\n      constructor(options) {\n        // Calls the stream.Writable() constructor\n        super(options);\n      }\n    }\n\n    //写法2:\n    const Writable = require('stream').Writable;\n\n    const myWritable = new Writable({\n      write(chunk, encoding, callback) {\n        // ...\n      },\n      writev(chunks, callback) {\n        // ...\n      }\n    });\n  ```\n  Writeable 与 Readable 的关系大致如下图:\n\n  ![Writeable 与 Readable 的关系](https://segmentfault.com/img/bVoLre)\n\n#### 3. ``Duplex`` & ``Transform``\n\n``Duplex`` & ``Transform`` 既是可读流也是可写流,类比水流管道中间部分,既有输入也有输出,输入输出分别都有各自的缓冲区。经常会有一种情况,就是输入和输出的速率不一样的情况,所以两端应该相对独立,可以为另一端调节速率。Transform 是一种特殊的 Duplex, Transform的输出以某种方式和输入相联系。Transform 内部流程图大致如下:\n\n![Transform 内部工作流程图](https://segmentfault.com/img/bVoLri)\n\ngulp插件就是通过through2创建一个Transform,并执行一些操作然后返回创建的流。\n\n\n### 参考资料\n1. [streamify-your-node-program](https://github.com/zoubin/streamify-your-node-program)\n2. [node源码解析 -- Stream探究](https://segmentfault.com/a/1190000003479884)\n3. [Node.js Stream - 进阶篇](http://tech.meituan.com/stream-internals.html)\n4. [Node Stream](https://nodejs.org/api/stream.html)\n5. [stream-handbook](https://github.com/substack/stream-handbook)\n6. [源码](https://github.com/nodejs/node/blob/master/lib/_stream_readable.js)\n","source":"_posts/node-stream.md","raw":"---\ntitle: Node Stream 初窥\ntags: [NodeJS]\ncategories: [NodeJS,前端大杂烩]\ndate: 2017-04-26 11:13:00\ndescription: Node 将几乎所有 IO 操作都抽象成了 Stream 的操作。Stream 是一个抽象的概念，可以将Stream 想象成水流管道,管道有只用于输出的,有只接收的,有负责中间过渡的(既有输入的一端,也有输出的一端)。总之就是生产东西,或者消费东西,这个东西可以是Buffer,可以是String,甚至是可以Object。\n---\n\nNode 将几乎所有 IO 操作都抽象成了 Stream 的操作。Stream 是一个抽象的概念，可以将Stream 想象成水流管道,管道有只用于输出的,有只接收的,有负责中间过渡的(既有输入的一端,也有输出的一端)。总之就是生产东西,或者消费东西,这个东西可以是Buffer,可以是String,甚至是可以Object。从Node 官方文档对Stream的定义,\n\n>A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter\n\n我们可以了解到 :\n* Stream是Node中一个非常重要的概念，被大量对象实现，尤其是Node中的I/O操作\n* Stream是一个抽像的接口，一般不会直接使用，需要实现内部的某些抽象方法(例如_read、_write、_transform)\n* Stream是EventEmitter的子类，实际上Stream的数据传递内部依然是通过事件(data)来实现的\n\n那为什么会需要流。看下面这段代码:\n\n```javascript\nvar http = require('http');\nvar fs = require('fs');\n\nvar server = http.createServer(function (req, res) {\n    // req is an http.IncomingMessage, which is a Readable Stream\n    // res is an http.ServerResponse, which is a Writable Stream\n    fs.readFile(__dirname + '/data.txt', function (err, data) {\n        res.end(data);\n    });\n});\nserver.listen(8000);\n```\n\n> 每次当请求过来,程序都会接收到这个请求,然后去读``data.txt``文件,并把内容返回。但是每次读的时候都会把``data.txt``整个读入内存,在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。其次，上面的代码可能会造成很不好的用户体验，因为用户在接收到任何的内容之前首先需要等待程序将文件内容完全读入到内存中。所以更好的办法就是需要多少给多少,而不是一股脑的将整个数据放到内存中,通过流可以实现这一的效果。\n\n```\nvar http = require('http');\nvar fs = require('fs');\n\nvar server = http.createServer(function (req, res) {\n    // req is an http.IncomingMessage, which is a Readable Stream\n    // res is an http.ServerResponse, which is a Writable Stream\n    var stream = fs.createReadStream(__dirname + '/data.txt');\n    stream.pipe(res);\n});\nserver.listen(8000);\n```\n\n### Node 中Stream的类型\n\n在Node.js中,有四种基本的流类型,他们分别是:``Readable`` ,``Writable``,``Duplex ``,``Transform ``。流一般处理的数据类型都是String 和 Buffer的,但是你可以通过在创建流的时候指定选项参数``objectMode``,创建对象流,不过需要注意的是,尝试将已存在的流的模式切换成对象流是一种不安全的不被建议的操作。\n\n不管是``Readable`` 还是 ``Writable`` 流,工作的过程都会将数据保存在内部的一个缓冲区中,可以分别通过``readable._readableState.buffer`` , ``writable._writableState.getBuffer()`` 取出buffer内容。我们可以通过选项参数``highWaterMark``控制缓冲区的大小,对于String 或者 Buffer流来说,highWaterMark 控制的字节数,对于对象流,highWaterMark控制的是对象的个数。\n\n#### 1. ``Readable``\n\n可读流,是输出流,通过``readable.push(chunk)``将数据读入流的缓冲区以供读取,消费者可以通过``readable.read()``读取流中的数据,如果缓冲区中的数据一直没有被消费掉,一旦到达 ``highWaterMark`` 设置的阈值,那么输出流就会停止往缓冲区中放数据,知道有消费者消耗掉这些数据。\n\n> Once the total size of the internal read buffer reaches the threshold specified by highWaterMark, the stream will temporarily stop reading data from the underlying resource until the data currently buffered can be consumed (that is, the stream will stop calling the internal readable._read() method that is used to fill the read buffer).\n\nReadable 有两种模式,分别是 flowing 和 paused 模式。flowing 模式,会自动的从源读取数据通过事件的方式提供给应用消费,而paused 模式需要显示手动调用readable.read()方法,从流中读取数据。所有的Readable流一开始都是paused模式,但是可以通过下面的几种方法切换成flowing 模式:\n1. 添加``data``事件处理器。\n2. 调用 `` readable.resume()`` 方法。\n3. 调用 ``readable.pipe() `` 方法发送数据到Writeable 流。\n\n只要监听了``data``事件或者是调用`` readable.resume()``,``readable.pipe() ``方法,都会将``readable._readableState.flowing`` 设置为true。使得Readable当数据生成时不断的触发data事件。流程图大致如下:\n\n![Readable 流程](http://tech.meituan.com/img/stream-how-data-comes-out.png)\n\n同样可以通过一些方式将模式从 flowing 切换回 paused。 具体方法参考官方文档。\n\n#### 2. ``Writable``\n\n可写流,输入流,是对数据写入目标的一个抽象,将内容通过`` writable.write(chunk) ``存入流缓冲区中,如果没有超出限制,则返回true,如果超出限制,则返回false。\n\n* 实现自己的``Writable``\n\n  > 继承``Writable`` ,重写方法``_write``,``_writev``,任何的可写流都必须提供方法``_write``,用于将数据写入底层资源(如某个文件)。实现自己的``Writable``代码如下:\n\n  ```javascript\n    //写法1:\n    const Writable = require('stream').Writable;\n\n    class MyWritable extends Writable {\n      constructor(options) {\n        // Calls the stream.Writable() constructor\n        super(options);\n      }\n    }\n\n    //写法2:\n    const Writable = require('stream').Writable;\n\n    const myWritable = new Writable({\n      write(chunk, encoding, callback) {\n        // ...\n      },\n      writev(chunks, callback) {\n        // ...\n      }\n    });\n  ```\n  Writeable 与 Readable 的关系大致如下图:\n\n  ![Writeable 与 Readable 的关系](https://segmentfault.com/img/bVoLre)\n\n#### 3. ``Duplex`` & ``Transform``\n\n``Duplex`` & ``Transform`` 既是可读流也是可写流,类比水流管道中间部分,既有输入也有输出,输入输出分别都有各自的缓冲区。经常会有一种情况,就是输入和输出的速率不一样的情况,所以两端应该相对独立,可以为另一端调节速率。Transform 是一种特殊的 Duplex, Transform的输出以某种方式和输入相联系。Transform 内部流程图大致如下:\n\n![Transform 内部工作流程图](https://segmentfault.com/img/bVoLri)\n\ngulp插件就是通过through2创建一个Transform,并执行一些操作然后返回创建的流。\n\n\n### 参考资料\n1. [streamify-your-node-program](https://github.com/zoubin/streamify-your-node-program)\n2. [node源码解析 -- Stream探究](https://segmentfault.com/a/1190000003479884)\n3. [Node.js Stream - 进阶篇](http://tech.meituan.com/stream-internals.html)\n4. [Node Stream](https://nodejs.org/api/stream.html)\n5. [stream-handbook](https://github.com/substack/stream-handbook)\n6. [源码](https://github.com/nodejs/node/blob/master/lib/_stream_readable.js)\n","slug":"node-stream","published":1,"updated":"2017-05-03T03:21:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhqg000mb37qe22i97cf","content":"<p>Node 将几乎所有 IO 操作都抽象成了 Stream 的操作。Stream 是一个抽象的概念，可以将Stream 想象成水流管道,管道有只用于输出的,有只接收的,有负责中间过渡的(既有输入的一端,也有输出的一端)。总之就是生产东西,或者消费东西,这个东西可以是Buffer,可以是String,甚至是可以Object。从Node 官方文档对Stream的定义,</p>\n<blockquote>\n<p>A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter</p>\n</blockquote>\n<p>我们可以了解到 :</p>\n<ul>\n<li>Stream是Node中一个非常重要的概念，被大量对象实现，尤其是Node中的I/O操作</li>\n<li>Stream是一个抽像的接口，一般不会直接使用，需要实现内部的某些抽象方法(例如_read、_write、_transform)</li>\n<li>Stream是EventEmitter的子类，实际上Stream的数据传递内部依然是通过事件(data)来实现的</li>\n</ul>\n<p>那为什么会需要流。看下面这段代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// req is an http.IncomingMessage, which is a Readable Stream</span></div><div class=\"line\">    <span class=\"comment\">// res is an http.ServerResponse, which is a Writable Stream</span></div><div class=\"line\">    fs.readFile(__dirname + <span class=\"string\">'/data.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">        res.end(data);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">server.listen(<span class=\"number\">8000</span>);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>每次当请求过来,程序都会接收到这个请求,然后去读<code>data.txt</code>文件,并把内容返回。但是每次读的时候都会把<code>data.txt</code>整个读入内存,在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。其次，上面的代码可能会造成很不好的用户体验，因为用户在接收到任何的内容之前首先需要等待程序将文件内容完全读入到内存中。所以更好的办法就是需要多少给多少,而不是一股脑的将整个数据放到内存中,通过流可以实现这一的效果。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var http = require(&apos;http&apos;);</div><div class=\"line\">var fs = require(&apos;fs&apos;);</div><div class=\"line\"></div><div class=\"line\">var server = http.createServer(function (req, res) &#123;</div><div class=\"line\">    // req is an http.IncomingMessage, which is a Readable Stream</div><div class=\"line\">    // res is an http.ServerResponse, which is a Writable Stream</div><div class=\"line\">    var stream = fs.createReadStream(__dirname + &apos;/data.txt&apos;);</div><div class=\"line\">    stream.pipe(res);</div><div class=\"line\">&#125;);</div><div class=\"line\">server.listen(8000);</div></pre></td></tr></table></figure>\n<h3 id=\"Node-中Stream的类型\"><a href=\"#Node-中Stream的类型\" class=\"headerlink\" title=\"Node 中Stream的类型\"></a>Node 中Stream的类型</h3><p>在Node.js中,有四种基本的流类型,他们分别是:<code>Readable</code> ,<code>Writable</code>,<code>Duplex</code>,<code>Transform</code>。流一般处理的数据类型都是String 和 Buffer的,但是你可以通过在创建流的时候指定选项参数<code>objectMode</code>,创建对象流,不过需要注意的是,尝试将已存在的流的模式切换成对象流是一种不安全的不被建议的操作。</p>\n<p>不管是<code>Readable</code> 还是 <code>Writable</code> 流,工作的过程都会将数据保存在内部的一个缓冲区中,可以分别通过<code>readable._readableState.buffer</code> , <code>writable._writableState.getBuffer()</code> 取出buffer内容。我们可以通过选项参数<code>highWaterMark</code>控制缓冲区的大小,对于String 或者 Buffer流来说,highWaterMark 控制的字节数,对于对象流,highWaterMark控制的是对象的个数。</p>\n<h4 id=\"1-Readable\"><a href=\"#1-Readable\" class=\"headerlink\" title=\"1. Readable\"></a>1. <code>Readable</code></h4><p>可读流,是输出流,通过<code>readable.push(chunk)</code>将数据读入流的缓冲区以供读取,消费者可以通过<code>readable.read()</code>读取流中的数据,如果缓冲区中的数据一直没有被消费掉,一旦到达 <code>highWaterMark</code> 设置的阈值,那么输出流就会停止往缓冲区中放数据,知道有消费者消耗掉这些数据。</p>\n<blockquote>\n<p>Once the total size of the internal read buffer reaches the threshold specified by highWaterMark, the stream will temporarily stop reading data from the underlying resource until the data currently buffered can be consumed (that is, the stream will stop calling the internal readable._read() method that is used to fill the read buffer).</p>\n</blockquote>\n<p>Readable 有两种模式,分别是 flowing 和 paused 模式。flowing 模式,会自动的从源读取数据通过事件的方式提供给应用消费,而paused 模式需要显示手动调用readable.read()方法,从流中读取数据。所有的Readable流一开始都是paused模式,但是可以通过下面的几种方法切换成flowing 模式:</p>\n<ol>\n<li>添加<code>data</code>事件处理器。</li>\n<li>调用 <code>readable.resume()</code> 方法。</li>\n<li>调用 <code>readable.pipe()</code> 方法发送数据到Writeable 流。</li>\n</ol>\n<p>只要监听了<code>data</code>事件或者是调用<code>readable.resume()</code>,<code>readable.pipe()</code>方法,都会将<code>readable._readableState.flowing</code> 设置为true。使得Readable当数据生成时不断的触发data事件。流程图大致如下:</p>\n<p><img src=\"http://tech.meituan.com/img/stream-how-data-comes-out.png\" alt=\"Readable 流程\"></p>\n<p>同样可以通过一些方式将模式从 flowing 切换回 paused。 具体方法参考官方文档。</p>\n<h4 id=\"2-Writable\"><a href=\"#2-Writable\" class=\"headerlink\" title=\"2. Writable\"></a>2. <code>Writable</code></h4><p>可写流,输入流,是对数据写入目标的一个抽象,将内容通过<code>writable.write(chunk)</code>存入流缓冲区中,如果没有超出限制,则返回true,如果超出限制,则返回false。</p>\n<ul>\n<li><p>实现自己的<code>Writable</code></p>\n<blockquote>\n<p>继承<code>Writable</code> ,重写方法<code>_write</code>,<code>_writev</code>,任何的可写流都必须提供方法<code>_write</code>,用于将数据写入底层资源(如某个文件)。实现自己的<code>Writable</code>代码如下:</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//写法1:</span></div><div class=\"line\"><span class=\"keyword\">const</span> Writable = <span class=\"built_in\">require</span>(<span class=\"string\">'stream'</span>).Writable;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWritable</span> <span class=\"keyword\">extends</span> <span class=\"title\">Writable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(options) &#123;</div><div class=\"line\">    <span class=\"comment\">// Calls the stream.Writable() constructor</span></div><div class=\"line\">    <span class=\"keyword\">super</span>(options);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//写法2:</span></div><div class=\"line\"><span class=\"keyword\">const</span> Writable = <span class=\"built_in\">require</span>(<span class=\"string\">'stream'</span>).Writable;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myWritable = <span class=\"keyword\">new</span> Writable(&#123;</div><div class=\"line\">  write(chunk, encoding, callback) &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  writev(chunks, callback) &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Writeable 与 Readable 的关系大致如下图:</p>\n<p><img src=\"https://segmentfault.com/img/bVoLre\" alt=\"Writeable 与 Readable 的关系\"></p>\n</li>\n</ul>\n<h4 id=\"3-Duplex-amp-Transform\"><a href=\"#3-Duplex-amp-Transform\" class=\"headerlink\" title=\"3. Duplex &amp; Transform\"></a>3. <code>Duplex</code> &amp; <code>Transform</code></h4><p><code>Duplex</code> &amp; <code>Transform</code> 既是可读流也是可写流,类比水流管道中间部分,既有输入也有输出,输入输出分别都有各自的缓冲区。经常会有一种情况,就是输入和输出的速率不一样的情况,所以两端应该相对独立,可以为另一端调节速率。Transform 是一种特殊的 Duplex, Transform的输出以某种方式和输入相联系。Transform 内部流程图大致如下:</p>\n<p><img src=\"https://segmentfault.com/img/bVoLri\" alt=\"Transform 内部工作流程图\"></p>\n<p>gulp插件就是通过through2创建一个Transform,并执行一些操作然后返回创建的流。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://github.com/zoubin/streamify-your-node-program\" target=\"_blank\" rel=\"external\">streamify-your-node-program</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000003479884\" target=\"_blank\" rel=\"external\">node源码解析 – Stream探究</a></li>\n<li><a href=\"http://tech.meituan.com/stream-internals.html\" target=\"_blank\" rel=\"external\">Node.js Stream - 进阶篇</a></li>\n<li><a href=\"https://nodejs.org/api/stream.html\" target=\"_blank\" rel=\"external\">Node Stream</a></li>\n<li><a href=\"https://github.com/substack/stream-handbook\" target=\"_blank\" rel=\"external\">stream-handbook</a></li>\n<li><a href=\"https://github.com/nodejs/node/blob/master/lib/_stream_readable.js\" target=\"_blank\" rel=\"external\">源码</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>Node 将几乎所有 IO 操作都抽象成了 Stream 的操作。Stream 是一个抽象的概念，可以将Stream 想象成水流管道,管道有只用于输出的,有只接收的,有负责中间过渡的(既有输入的一端,也有输出的一端)。总之就是生产东西,或者消费东西,这个东西可以是Buffer,可以是String,甚至是可以Object。从Node 官方文档对Stream的定义,</p>\n<blockquote>\n<p>A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter</p>\n</blockquote>\n<p>我们可以了解到 :</p>\n<ul>\n<li>Stream是Node中一个非常重要的概念，被大量对象实现，尤其是Node中的I/O操作</li>\n<li>Stream是一个抽像的接口，一般不会直接使用，需要实现内部的某些抽象方法(例如_read、_write、_transform)</li>\n<li>Stream是EventEmitter的子类，实际上Stream的数据传递内部依然是通过事件(data)来实现的</li>\n</ul>\n<p>那为什么会需要流。看下面这段代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> server = http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// req is an http.IncomingMessage, which is a Readable Stream</span></div><div class=\"line\">    <span class=\"comment\">// res is an http.ServerResponse, which is a Writable Stream</span></div><div class=\"line\">    fs.readFile(__dirname + <span class=\"string\">'/data.txt'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</div><div class=\"line\">        res.end(data);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;);</div><div class=\"line\">server.listen(<span class=\"number\">8000</span>);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>每次当请求过来,程序都会接收到这个请求,然后去读<code>data.txt</code>文件,并把内容返回。但是每次读的时候都会把<code>data.txt</code>整个读入内存,在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。其次，上面的代码可能会造成很不好的用户体验，因为用户在接收到任何的内容之前首先需要等待程序将文件内容完全读入到内存中。所以更好的办法就是需要多少给多少,而不是一股脑的将整个数据放到内存中,通过流可以实现这一的效果。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var http = require(&apos;http&apos;);</div><div class=\"line\">var fs = require(&apos;fs&apos;);</div><div class=\"line\"></div><div class=\"line\">var server = http.createServer(function (req, res) &#123;</div><div class=\"line\">    // req is an http.IncomingMessage, which is a Readable Stream</div><div class=\"line\">    // res is an http.ServerResponse, which is a Writable Stream</div><div class=\"line\">    var stream = fs.createReadStream(__dirname + &apos;/data.txt&apos;);</div><div class=\"line\">    stream.pipe(res);</div><div class=\"line\">&#125;);</div><div class=\"line\">server.listen(8000);</div></pre></td></tr></table></figure>\n<h3 id=\"Node-中Stream的类型\"><a href=\"#Node-中Stream的类型\" class=\"headerlink\" title=\"Node 中Stream的类型\"></a>Node 中Stream的类型</h3><p>在Node.js中,有四种基本的流类型,他们分别是:<code>Readable</code> ,<code>Writable</code>,<code>Duplex</code>,<code>Transform</code>。流一般处理的数据类型都是String 和 Buffer的,但是你可以通过在创建流的时候指定选项参数<code>objectMode</code>,创建对象流,不过需要注意的是,尝试将已存在的流的模式切换成对象流是一种不安全的不被建议的操作。</p>\n<p>不管是<code>Readable</code> 还是 <code>Writable</code> 流,工作的过程都会将数据保存在内部的一个缓冲区中,可以分别通过<code>readable._readableState.buffer</code> , <code>writable._writableState.getBuffer()</code> 取出buffer内容。我们可以通过选项参数<code>highWaterMark</code>控制缓冲区的大小,对于String 或者 Buffer流来说,highWaterMark 控制的字节数,对于对象流,highWaterMark控制的是对象的个数。</p>\n<h4 id=\"1-Readable\"><a href=\"#1-Readable\" class=\"headerlink\" title=\"1. Readable\"></a>1. <code>Readable</code></h4><p>可读流,是输出流,通过<code>readable.push(chunk)</code>将数据读入流的缓冲区以供读取,消费者可以通过<code>readable.read()</code>读取流中的数据,如果缓冲区中的数据一直没有被消费掉,一旦到达 <code>highWaterMark</code> 设置的阈值,那么输出流就会停止往缓冲区中放数据,知道有消费者消耗掉这些数据。</p>\n<blockquote>\n<p>Once the total size of the internal read buffer reaches the threshold specified by highWaterMark, the stream will temporarily stop reading data from the underlying resource until the data currently buffered can be consumed (that is, the stream will stop calling the internal readable._read() method that is used to fill the read buffer).</p>\n</blockquote>\n<p>Readable 有两种模式,分别是 flowing 和 paused 模式。flowing 模式,会自动的从源读取数据通过事件的方式提供给应用消费,而paused 模式需要显示手动调用readable.read()方法,从流中读取数据。所有的Readable流一开始都是paused模式,但是可以通过下面的几种方法切换成flowing 模式:</p>\n<ol>\n<li>添加<code>data</code>事件处理器。</li>\n<li>调用 <code>readable.resume()</code> 方法。</li>\n<li>调用 <code>readable.pipe()</code> 方法发送数据到Writeable 流。</li>\n</ol>\n<p>只要监听了<code>data</code>事件或者是调用<code>readable.resume()</code>,<code>readable.pipe()</code>方法,都会将<code>readable._readableState.flowing</code> 设置为true。使得Readable当数据生成时不断的触发data事件。流程图大致如下:</p>\n<p><img src=\"http://tech.meituan.com/img/stream-how-data-comes-out.png\" alt=\"Readable 流程\"></p>\n<p>同样可以通过一些方式将模式从 flowing 切换回 paused。 具体方法参考官方文档。</p>\n<h4 id=\"2-Writable\"><a href=\"#2-Writable\" class=\"headerlink\" title=\"2. Writable\"></a>2. <code>Writable</code></h4><p>可写流,输入流,是对数据写入目标的一个抽象,将内容通过<code>writable.write(chunk)</code>存入流缓冲区中,如果没有超出限制,则返回true,如果超出限制,则返回false。</p>\n<ul>\n<li><p>实现自己的<code>Writable</code></p>\n<blockquote>\n<p>继承<code>Writable</code> ,重写方法<code>_write</code>,<code>_writev</code>,任何的可写流都必须提供方法<code>_write</code>,用于将数据写入底层资源(如某个文件)。实现自己的<code>Writable</code>代码如下:</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//写法1:</span></div><div class=\"line\"><span class=\"keyword\">const</span> Writable = <span class=\"built_in\">require</span>(<span class=\"string\">'stream'</span>).Writable;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWritable</span> <span class=\"keyword\">extends</span> <span class=\"title\">Writable</span> </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">constructor</span>(options) &#123;</div><div class=\"line\">    <span class=\"comment\">// Calls the stream.Writable() constructor</span></div><div class=\"line\">    <span class=\"keyword\">super</span>(options);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//写法2:</span></div><div class=\"line\"><span class=\"keyword\">const</span> Writable = <span class=\"built_in\">require</span>(<span class=\"string\">'stream'</span>).Writable;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> myWritable = <span class=\"keyword\">new</span> Writable(&#123;</div><div class=\"line\">  write(chunk, encoding, callback) &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  writev(chunks, callback) &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>Writeable 与 Readable 的关系大致如下图:</p>\n<p><img src=\"https://segmentfault.com/img/bVoLre\" alt=\"Writeable 与 Readable 的关系\"></p>\n</li>\n</ul>\n<h4 id=\"3-Duplex-amp-Transform\"><a href=\"#3-Duplex-amp-Transform\" class=\"headerlink\" title=\"3. Duplex &amp; Transform\"></a>3. <code>Duplex</code> &amp; <code>Transform</code></h4><p><code>Duplex</code> &amp; <code>Transform</code> 既是可读流也是可写流,类比水流管道中间部分,既有输入也有输出,输入输出分别都有各自的缓冲区。经常会有一种情况,就是输入和输出的速率不一样的情况,所以两端应该相对独立,可以为另一端调节速率。Transform 是一种特殊的 Duplex, Transform的输出以某种方式和输入相联系。Transform 内部流程图大致如下:</p>\n<p><img src=\"https://segmentfault.com/img/bVoLri\" alt=\"Transform 内部工作流程图\"></p>\n<p>gulp插件就是通过through2创建一个Transform,并执行一些操作然后返回创建的流。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://github.com/zoubin/streamify-your-node-program\" target=\"_blank\" rel=\"external\">streamify-your-node-program</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000003479884\" target=\"_blank\" rel=\"external\">node源码解析 – Stream探究</a></li>\n<li><a href=\"http://tech.meituan.com/stream-internals.html\" target=\"_blank\" rel=\"external\">Node.js Stream - 进阶篇</a></li>\n<li><a href=\"https://nodejs.org/api/stream.html\" target=\"_blank\" rel=\"external\">Node Stream</a></li>\n<li><a href=\"https://github.com/substack/stream-handbook\" target=\"_blank\" rel=\"external\">stream-handbook</a></li>\n<li><a href=\"https://github.com/nodejs/node/blob/master/lib/_stream_readable.js\" target=\"_blank\" rel=\"external\">源码</a></li>\n</ol>\n"},{"title":"使用ngrok让你的本地mock可以提供给外网访问","type":"original","date":"2017-04-26T08:51:07.000Z","description":"前端开发往往需要在本地启动mock服务提供模拟数据进行代码调试和自测。简单的mock已经足够满足本地代码调试和自测。然而开发过程中往往需要和其他端进行联调或者将代码作为demo给别人展示，例如：在开发完react-native页面，需要将页面嵌入到原生代码中，和native的同学对接，这个时候本地的mock接口往往是这样的接口地址 http://localhost:9000/getData 不能成功被请求，如果处于同一个内网这个时候可以通过写死接口ip地址来解决，如果不在同一个内网则（远程协作等情况）的时候，往往需要对接代码的人在本地也同样mock一份数据，过程较为复杂。","_content":"\n> __问题：__  前端开发往往需要在本地启动mock服务提供模拟数据进行代码调试和自测。简单的mock已经足够满足本地代码调试和自测。然而开发过程中往往需要和其他端进行联调或者将代码作为demo给别人展示，例如：在开发完react-native页面，需要将页面嵌入到原生代码中，和native的同学对接，这个时候本地的mock接口往往是这样的接口地址``http://localhost:9000/getData``不能成功被请求，如果处于同一个内网这个时候可以通过写死接口ip地址来解决，如果不在同一个内网则（远程协作等情况）的时候，往往需要对接代码的人在本地也同样mock一份数据，过程较为复杂。\n\n## ngrok 介绍\n[ngrok](https://ngrok.com/) 可以让本地地址穿透nat,firewall映射到能够在外网被访问的某个域名地址。这样本地请求可以改成使用这个统一的域名地址去请求，从而对接的时候不用手动去修改代码中的请求地址，提高了对接联调的效率。然后天下没有免费的午餐，自定义子域名这个功能只有付费的用户才能使用，但国内已经有人无私贡献了ngrok服务，造福于开发者，网站地址[ngrok 国内](http://qydev.com/)\n\n## ngrok 安装使用\n- 下载对对应平台的ngrok (eg: mac osx)\n- 解压ngrok\n  官方版本只有一个ngrok可执行文件 ，国内版本有两个文件一个ngrok（后续需要手动添加可执行权限）和 ngrok.cfg 配置文件。国内重命名为ngrok2并添加可执行权限  ``mv ngrok ngrok2 && chmod u+x ngrok2 ``\n- ``mv unzip-path/ngrok unzip-path/ngrok2 /usr/local/bin``  或者 再path环境变量中添加解压后的目录路径。\n- 使用\n  1. 配置ngrok 配置文件 （国内版本不需要）\n      ```\n       authtoken: youtoken \n       json_resolver_url: \"\"\n       dns_resolver_ips: []\n       tunnels:\n           dev:\n               addr: 9000\n               auth: username:paswd\n               proto: http\n         #    subdomain: xxxxx 付费用户才能用\n      ```\n      [token获取](https://dashboard.ngrok.com/auth)\n  2.  启动本地mock \n\n      ```\n       [SUCCESS] 16:52:38 mock 服务启动成功: http://:::9000\n      ```\n\n  3.  启用ngrok\n       ```\n        国内 : ngrok2 --config=ngrok.cfg -subdomain xxx 9000 \n        官方: ngrok start --config=ngrok.yml --all\n       ```\n    访问地址分别是: ``http://xxx.tunnel.qydev.com/getData`` 和 ``http://b79fb37b.ngrok.io/getData``\n\n## alias 命令\n设置别名:在~/.bashrc 或者 ~/.bash_profile 中添加``alias ngrok2=\"ngrok2 --config=/usr/local/opt/config/ngrok2.cfg\"`` 就可以直接使用ngrok2 -subdomain xxx 9000 启动服务\n![ngrok 运行结果](http://rainypin.qiniudn.com/git_imgs/ngrok01.png)","source":"_posts/ngrok.md","raw":"---\ntitle: 使用ngrok让你的本地mock可以提供给外网访问\ntype: original\ntags: [前端大杂烩]\ncategories: [前端大杂烩]\ndate: 2017-04-26 16:51:07\ndescription: 前端开发往往需要在本地启动mock服务提供模拟数据进行代码调试和自测。简单的mock已经足够满足本地代码调试和自测。然而开发过程中往往需要和其他端进行联调或者将代码作为demo给别人展示，例如：在开发完react-native页面，需要将页面嵌入到原生代码中，和native的同学对接，这个时候本地的mock接口往往是这样的接口地址 http://localhost:9000/getData 不能成功被请求，如果处于同一个内网这个时候可以通过写死接口ip地址来解决，如果不在同一个内网则（远程协作等情况）的时候，往往需要对接代码的人在本地也同样mock一份数据，过程较为复杂。\n---\n\n> __问题：__  前端开发往往需要在本地启动mock服务提供模拟数据进行代码调试和自测。简单的mock已经足够满足本地代码调试和自测。然而开发过程中往往需要和其他端进行联调或者将代码作为demo给别人展示，例如：在开发完react-native页面，需要将页面嵌入到原生代码中，和native的同学对接，这个时候本地的mock接口往往是这样的接口地址``http://localhost:9000/getData``不能成功被请求，如果处于同一个内网这个时候可以通过写死接口ip地址来解决，如果不在同一个内网则（远程协作等情况）的时候，往往需要对接代码的人在本地也同样mock一份数据，过程较为复杂。\n\n## ngrok 介绍\n[ngrok](https://ngrok.com/) 可以让本地地址穿透nat,firewall映射到能够在外网被访问的某个域名地址。这样本地请求可以改成使用这个统一的域名地址去请求，从而对接的时候不用手动去修改代码中的请求地址，提高了对接联调的效率。然后天下没有免费的午餐，自定义子域名这个功能只有付费的用户才能使用，但国内已经有人无私贡献了ngrok服务，造福于开发者，网站地址[ngrok 国内](http://qydev.com/)\n\n## ngrok 安装使用\n- 下载对对应平台的ngrok (eg: mac osx)\n- 解压ngrok\n  官方版本只有一个ngrok可执行文件 ，国内版本有两个文件一个ngrok（后续需要手动添加可执行权限）和 ngrok.cfg 配置文件。国内重命名为ngrok2并添加可执行权限  ``mv ngrok ngrok2 && chmod u+x ngrok2 ``\n- ``mv unzip-path/ngrok unzip-path/ngrok2 /usr/local/bin``  或者 再path环境变量中添加解压后的目录路径。\n- 使用\n  1. 配置ngrok 配置文件 （国内版本不需要）\n      ```\n       authtoken: youtoken \n       json_resolver_url: \"\"\n       dns_resolver_ips: []\n       tunnels:\n           dev:\n               addr: 9000\n               auth: username:paswd\n               proto: http\n         #    subdomain: xxxxx 付费用户才能用\n      ```\n      [token获取](https://dashboard.ngrok.com/auth)\n  2.  启动本地mock \n\n      ```\n       [SUCCESS] 16:52:38 mock 服务启动成功: http://:::9000\n      ```\n\n  3.  启用ngrok\n       ```\n        国内 : ngrok2 --config=ngrok.cfg -subdomain xxx 9000 \n        官方: ngrok start --config=ngrok.yml --all\n       ```\n    访问地址分别是: ``http://xxx.tunnel.qydev.com/getData`` 和 ``http://b79fb37b.ngrok.io/getData``\n\n## alias 命令\n设置别名:在~/.bashrc 或者 ~/.bash_profile 中添加``alias ngrok2=\"ngrok2 --config=/usr/local/opt/config/ngrok2.cfg\"`` 就可以直接使用ngrok2 -subdomain xxx 9000 启动服务\n![ngrok 运行结果](http://rainypin.qiniudn.com/git_imgs/ngrok01.png)","slug":"ngrok","published":1,"updated":"2017-05-03T05:53:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhqm000pb37qblff9kxm","content":"<blockquote>\n<p><strong>问题：</strong>  前端开发往往需要在本地启动mock服务提供模拟数据进行代码调试和自测。简单的mock已经足够满足本地代码调试和自测。然而开发过程中往往需要和其他端进行联调或者将代码作为demo给别人展示，例如：在开发完react-native页面，需要将页面嵌入到原生代码中，和native的同学对接，这个时候本地的mock接口往往是这样的接口地址<code>http://localhost:9000/getData</code>不能成功被请求，如果处于同一个内网这个时候可以通过写死接口ip地址来解决，如果不在同一个内网则（远程协作等情况）的时候，往往需要对接代码的人在本地也同样mock一份数据，过程较为复杂。</p>\n</blockquote>\n<h2 id=\"ngrok-介绍\"><a href=\"#ngrok-介绍\" class=\"headerlink\" title=\"ngrok 介绍\"></a>ngrok 介绍</h2><p><a href=\"https://ngrok.com/\" target=\"_blank\" rel=\"external\">ngrok</a> 可以让本地地址穿透nat,firewall映射到能够在外网被访问的某个域名地址。这样本地请求可以改成使用这个统一的域名地址去请求，从而对接的时候不用手动去修改代码中的请求地址，提高了对接联调的效率。然后天下没有免费的午餐，自定义子域名这个功能只有付费的用户才能使用，但国内已经有人无私贡献了ngrok服务，造福于开发者，网站地址<a href=\"http://qydev.com/\" target=\"_blank\" rel=\"external\">ngrok 国内</a></p>\n<h2 id=\"ngrok-安装使用\"><a href=\"#ngrok-安装使用\" class=\"headerlink\" title=\"ngrok 安装使用\"></a>ngrok 安装使用</h2><ul>\n<li>下载对对应平台的ngrok (eg: mac osx)</li>\n<li>解压ngrok<br>官方版本只有一个ngrok可执行文件 ，国内版本有两个文件一个ngrok（后续需要手动添加可执行权限）和 ngrok.cfg 配置文件。国内重命名为ngrok2并添加可执行权限  <code>mv ngrok ngrok2 &amp;&amp; chmod u+x ngrok2</code></li>\n<li><code>mv unzip-path/ngrok unzip-path/ngrok2 /usr/local/bin</code>  或者 再path环境变量中添加解压后的目录路径。</li>\n<li><p>使用</p>\n<ol>\n<li><p>配置ngrok 配置文件 （国内版本不需要）</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">authtoken: youtoken </div><div class=\"line\">json_resolver_url: &quot;&quot;</div><div class=\"line\">dns_resolver_ips: []</div><div class=\"line\">tunnels:</div><div class=\"line\">    dev:</div><div class=\"line\">        addr: 9000</div><div class=\"line\">        auth: username:paswd</div><div class=\"line\">        proto: http</div><div class=\"line\">  #    subdomain: xxxxx 付费用户才能用</div></pre></td></tr></table></figure>\n<p> <a href=\"https://dashboard.ngrok.com/auth\" target=\"_blank\" rel=\"external\">token获取</a></p>\n</li>\n<li><p>启动本地mock </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[SUCCESS] 16:52:38 mock 服务启动成功: http://:::9000</div></pre></td></tr></table></figure>\n</li>\n<li><p>启用ngrok</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">国内 : ngrok2 --config=ngrok.cfg -subdomain xxx 9000 </div><div class=\"line\">官方: ngrok start --config=ngrok.yml --all</div></pre></td></tr></table></figure>\n<p>访问地址分别是: <code>http://xxx.tunnel.qydev.com/getData</code> 和 <code>http://b79fb37b.ngrok.io/getData</code></p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"alias-命令\"><a href=\"#alias-命令\" class=\"headerlink\" title=\"alias 命令\"></a>alias 命令</h2><p>设置别名:在~/.bashrc 或者 ~/.bash_profile 中添加<code>alias ngrok2=&quot;ngrok2 --config=/usr/local/opt/config/ngrok2.cfg&quot;</code> 就可以直接使用ngrok2 -subdomain xxx 9000 启动服务<br><img src=\"http://rainypin.qiniudn.com/git_imgs/ngrok01.png\" alt=\"ngrok 运行结果\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><strong>问题：</strong>  前端开发往往需要在本地启动mock服务提供模拟数据进行代码调试和自测。简单的mock已经足够满足本地代码调试和自测。然而开发过程中往往需要和其他端进行联调或者将代码作为demo给别人展示，例如：在开发完react-native页面，需要将页面嵌入到原生代码中，和native的同学对接，这个时候本地的mock接口往往是这样的接口地址<code>http://localhost:9000/getData</code>不能成功被请求，如果处于同一个内网这个时候可以通过写死接口ip地址来解决，如果不在同一个内网则（远程协作等情况）的时候，往往需要对接代码的人在本地也同样mock一份数据，过程较为复杂。</p>\n</blockquote>\n<h2 id=\"ngrok-介绍\"><a href=\"#ngrok-介绍\" class=\"headerlink\" title=\"ngrok 介绍\"></a>ngrok 介绍</h2><p><a href=\"https://ngrok.com/\" target=\"_blank\" rel=\"external\">ngrok</a> 可以让本地地址穿透nat,firewall映射到能够在外网被访问的某个域名地址。这样本地请求可以改成使用这个统一的域名地址去请求，从而对接的时候不用手动去修改代码中的请求地址，提高了对接联调的效率。然后天下没有免费的午餐，自定义子域名这个功能只有付费的用户才能使用，但国内已经有人无私贡献了ngrok服务，造福于开发者，网站地址<a href=\"http://qydev.com/\" target=\"_blank\" rel=\"external\">ngrok 国内</a></p>\n<h2 id=\"ngrok-安装使用\"><a href=\"#ngrok-安装使用\" class=\"headerlink\" title=\"ngrok 安装使用\"></a>ngrok 安装使用</h2><ul>\n<li>下载对对应平台的ngrok (eg: mac osx)</li>\n<li>解压ngrok<br>官方版本只有一个ngrok可执行文件 ，国内版本有两个文件一个ngrok（后续需要手动添加可执行权限）和 ngrok.cfg 配置文件。国内重命名为ngrok2并添加可执行权限  <code>mv ngrok ngrok2 &amp;&amp; chmod u+x ngrok2</code></li>\n<li><code>mv unzip-path/ngrok unzip-path/ngrok2 /usr/local/bin</code>  或者 再path环境变量中添加解压后的目录路径。</li>\n<li><p>使用</p>\n<ol>\n<li><p>配置ngrok 配置文件 （国内版本不需要）</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">authtoken: youtoken </div><div class=\"line\">json_resolver_url: &quot;&quot;</div><div class=\"line\">dns_resolver_ips: []</div><div class=\"line\">tunnels:</div><div class=\"line\">    dev:</div><div class=\"line\">        addr: 9000</div><div class=\"line\">        auth: username:paswd</div><div class=\"line\">        proto: http</div><div class=\"line\">  #    subdomain: xxxxx 付费用户才能用</div></pre></td></tr></table></figure>\n<p> <a href=\"https://dashboard.ngrok.com/auth\" target=\"_blank\" rel=\"external\">token获取</a></p>\n</li>\n<li><p>启动本地mock </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[SUCCESS] 16:52:38 mock 服务启动成功: http://:::9000</div></pre></td></tr></table></figure>\n</li>\n<li><p>启用ngrok</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">国内 : ngrok2 --config=ngrok.cfg -subdomain xxx 9000 </div><div class=\"line\">官方: ngrok start --config=ngrok.yml --all</div></pre></td></tr></table></figure>\n<p>访问地址分别是: <code>http://xxx.tunnel.qydev.com/getData</code> 和 <code>http://b79fb37b.ngrok.io/getData</code></p>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"alias-命令\"><a href=\"#alias-命令\" class=\"headerlink\" title=\"alias 命令\"></a>alias 命令</h2><p>设置别名:在~/.bashrc 或者 ~/.bash_profile 中添加<code>alias ngrok2=&quot;ngrok2 --config=/usr/local/opt/config/ngrok2.cfg&quot;</code> 就可以直接使用ngrok2 -subdomain xxx 9000 启动服务<br><img src=\"http://rainypin.qiniudn.com/git_imgs/ngrok01.png\" alt=\"ngrok 运行结果\"></p>\n"},{"title":"Mongoose 学习笔记二 — Query 和 Population","type":"original","description":"数据库操作中查询肯定少不了,Documents 可以通过models的一些静态辅助方法来获取,这些方法可以以两种方式执行。1. 当 callback 回调函数作为参数传递给这些静态辅助函数的时候,相应的操作会立即执行,并将结果传递给 callback 回调函数。","date":"2017-04-26T16:06:04.000Z","_content":"\n### Query\n\n　　数据库操作中查询肯定少不了,Documents 可以通过models的一些静态辅助方法来获取,这些方法可以以两种方式执行。\n\n1. 当 callback 回调函数作为参数传递给这些静态辅助函数的时候,相应的操作会立即执行,并将结果传递给 callback 回调函数。\n\n    ```javascript\n        var Person = mongoose.model('Person', yourSchema);\n        \n        // find each person with a last name matching 'Ghost', selecting the `name` and `occupation` fields\n        Person.findOne({ 'name.last': 'Ghost' }, 'name occupation', function (err, person) {\n          if (err) return handleError(err);\n          console.log('%s %s is a %s.', person.name.first, person.name.last, person.occupation) // Space Ghost is a talk show host.\n        })\n    ```\n    \n    callback 需要接受两个参数,一个是err,一个是result。`` callback(error, result)`` 这种模式,如果有错误,则error为错误对象,result为空,反之error为空,result为返回的结果,可能是文档对象,可能是文档对象数组,或者是文档个数。\n    \n2. 当没有 callback , Query的实例会被返回,这个相当于promise,通过query对象我们可以进行后续的操作。\n    \n    ```javascript\n    // find each person with a last name matching 'Ghost'\n    var query = Person.findOne({ 'name.last': 'Ghost' });\n    \n    // selecting the `name` and `occupation` fields\n    query.select('name occupation');\n    \n    // execute the query at a later time\n    query.exec(function (err, person) {\n      if (err) return handleError(err);\n      console.log('%s %s is a %s.', person.name.first, person.name.last, person.occupation) // Space Ghost is a talk show host.\n    })\n    ```\n    query 对象提供了一种让你能够链式调用的方法,让你经过一系列处理和过滤后得到最终想要的结果。如下代码:\n    \n    ```javascript\n    // With a JSON doc\n    Person.\n      find({\n        occupation: /host/,\n        'name.last': 'Ghost',\n        age: { $gt: 17, $lt: 66 },\n        likes: { $in: ['vaporizing', 'talking'] }\n      }).\n      limit(10).\n      sort({ occupation: -1 }).\n      select({ name: 1, occupation: 1 }).\n      exec(callback);\n      \n    // Using query builder\n    Person.\n      find({ occupation: /host/ }).\n      where('name.last').equals('Ghost').\n      where('age').gt(17).lt(66).\n      where('likes').in(['vaporizing', 'talking']).\n      limit(10).\n      sort('-occupation').\n      select('name occupation').\n      exec(callback);\n    ```\n\n### Population\n\n　　在 Mongodb 中并没有像关系数据库中的表一样拥有 join 操作, 能够将多个表连接起来作为结果返回,但 mongoose 提供了Population,让不同集合中的多个 document 可以联系在一起,然后整体作为结果返回,这和关系数据库中的表连接有些类似。\n\n　　首先要连接两个 document ,在创建的时候,这两个 document 需要有对应的关系,像\"一对多\",\"多对一\",\"多对多\"。如下:\n\n```javascript\nvar mongoose = require('mongoose')\n  , Schema = mongoose.Schema\n  \nvar personSchema = Schema({\n  _id     : Number,\n  name    : String,\n  age     : Number,\n  stories : [{ type: Schema.Types.ObjectId, ref: 'Story' }]\n});\n\nvar storySchema = Schema({\n  _creator : { type: Number, ref: 'Person' },\n  title    : String,\n  fans     : [{ type: Number, ref: 'Person' }]\n});\n\nvar Story  = mongoose.model('Story', storySchema);\nvar Person = mongoose.model('Person', personSchema);\n\n```\n\nPerson 和 Story 就存在着一种或者多种对应关系, 一个 Person 对应着多个 Story,在Person Schema中表现出来就是有一个 stories 字段,它的值是这个 Person 所拥有的 stories objectId 数组。对于 Story 也同样存在着这样的保存对应关系的字段。在需要 populate 时,就会根据这些关系进行连接填充。首先我们先创建 Person 和 Story :\n \n ```javascript\n //创建 document 并保存对应关系到相应的字段中去。\n var aaron = new Person({ _id: 0, name: 'Aaron', age: 100 });\n \n aaron.save(function (err) {\n   if (err) return handleError(err);\n   \n   var story1 = new Story({\n     title: \"Once upon a timex.\",\n     _creator: aaron._id    // assign the _id from the person\n   });\n   \n   story1.save(function (err) {\n     if (err) return handleError(err);\n     // thats it!\n   });\n });\n ```\n \n 目前为止,并没有什么特殊的地方,仅仅就是创建了 document 并保存。接下来我们看下 population 的作用,我们 populate story中的 _creator 字段,其实就是 mongoose 通过一定的方式,将 _creator 值(Person 的 object Id),作为查询条件得到对应的Person,然后赋值给story 中的 _creator字段。如下:\n \n ```javascript\n Story\n .findOne({ title: 'Once upon a timex.' })\n .populate('_creator')\n .exec(function (err, story) {\n   if (err) return handleError(err);\n   console.log('The creator is %s', story._creator.name);\n   // prints \"The creator is Aaron\"\n });\n ```\n 其中,populate 方法中的参数 \"_creator\" 就是 populate path。 上面的方法你可以通过先查询得到对应 objectId 的 Person 文档,然后手动赋值给对应的story _creator达到目的。\n \n ```javascript\n Story.findOne({ title: 'Once upon a timex.' }, function(error, story) {\n   if (error) {\n     return handleError(error);\n   }\n   story._creator = aaron;\n   console.log(story._creator.name); // prints \"Aaron\"\n });\n ```\n \n > Note that this only works for single refs. You currently can't manually populate an array of refs.\n \n在 populate 的过程中,你可以剔除不需要的字段,仅仅连接你所需要的字段到当前 document 中,比如你只需要 Person 的 name,那么你可以这么干:\n\n```javascript\nStory\n.findOne({ title: /timex/i })\n.populate('_creator', 'name') // only return the Persons name\n.exec(function (err, story) {\n  if (err) return handleError(err);\n  \n  console.log('The creator is %s', story._creator.name);\n  // prints \"The creator is Aaron\"\n  \n  console.log('The creators age is %s', story._creator.age);\n  // prints \"The creators age is null'\n})\n```\n\nPopulating 多个 Path,如果你同时想要story 中的 _creator 字段和 fans 字段被具体对应的 document 填充,可以通过空格分隔多个 path 作为 populate 方法的参数。如下:\n\n```javascript\nStory\n.find(...)\n.populate('fans _creator') // space delimited path names\n.exec()\n```\n\n但是在 mongoose 3.6版本以及这个版本之后我们才能这么干,在这之前我们只能通过如下的方式实现相同的目的:\n \n ```javascript\n Story\n .find(...)\n .populate('fans')\n .populate('_creator')\n .exec()\n ```\n \npopulate 方法支持 Object 对象作为参数,如你想只populate 一定年龄的,只需要填充返回你指定的字段,返回指定数目的documents,那么你可以这么干\n\n```javascript\nStory\n.find(...)\n.populate({\n  path: 'fans',\n  match: { age: { $gte: 21 }},\n  select: 'name -_id',\n  options: { limit: 5 }\n})\n.exec()\n```\n\n\n### 总结\n\nmongoose 给用户提供了便利的方法来查询文档和连接相关的文档,上面只是对用法做了简单的说明,更多的内容大家可以参看官方提供的文档[Query](http://mongoosejs.com/docs/queries.html),[Population](http://mongoosejs.com/docs/populate.html)。","source":"_posts/mongoose-tutorial-2.md","raw":"---\ntitle: Mongoose 学习笔记二 — Query 和 Population\ntype: original\ndescription: >-\n  数据库操作中查询肯定少不了,Documents 可以通过models的一些静态辅助方法来获取,这些方法可以以两种方式执行。1. 当 callback\n  回调函数作为参数传递给这些静态辅助函数的时候,相应的操作会立即执行,并将结果传递给 callback 回调函数。\ntags: [Mongoose,Mongodb]\ncategories: [nodeclub源码学习]\ndate: 2017-04-27 00:06:04\n---\n\n### Query\n\n　　数据库操作中查询肯定少不了,Documents 可以通过models的一些静态辅助方法来获取,这些方法可以以两种方式执行。\n\n1. 当 callback 回调函数作为参数传递给这些静态辅助函数的时候,相应的操作会立即执行,并将结果传递给 callback 回调函数。\n\n    ```javascript\n        var Person = mongoose.model('Person', yourSchema);\n        \n        // find each person with a last name matching 'Ghost', selecting the `name` and `occupation` fields\n        Person.findOne({ 'name.last': 'Ghost' }, 'name occupation', function (err, person) {\n          if (err) return handleError(err);\n          console.log('%s %s is a %s.', person.name.first, person.name.last, person.occupation) // Space Ghost is a talk show host.\n        })\n    ```\n    \n    callback 需要接受两个参数,一个是err,一个是result。`` callback(error, result)`` 这种模式,如果有错误,则error为错误对象,result为空,反之error为空,result为返回的结果,可能是文档对象,可能是文档对象数组,或者是文档个数。\n    \n2. 当没有 callback , Query的实例会被返回,这个相当于promise,通过query对象我们可以进行后续的操作。\n    \n    ```javascript\n    // find each person with a last name matching 'Ghost'\n    var query = Person.findOne({ 'name.last': 'Ghost' });\n    \n    // selecting the `name` and `occupation` fields\n    query.select('name occupation');\n    \n    // execute the query at a later time\n    query.exec(function (err, person) {\n      if (err) return handleError(err);\n      console.log('%s %s is a %s.', person.name.first, person.name.last, person.occupation) // Space Ghost is a talk show host.\n    })\n    ```\n    query 对象提供了一种让你能够链式调用的方法,让你经过一系列处理和过滤后得到最终想要的结果。如下代码:\n    \n    ```javascript\n    // With a JSON doc\n    Person.\n      find({\n        occupation: /host/,\n        'name.last': 'Ghost',\n        age: { $gt: 17, $lt: 66 },\n        likes: { $in: ['vaporizing', 'talking'] }\n      }).\n      limit(10).\n      sort({ occupation: -1 }).\n      select({ name: 1, occupation: 1 }).\n      exec(callback);\n      \n    // Using query builder\n    Person.\n      find({ occupation: /host/ }).\n      where('name.last').equals('Ghost').\n      where('age').gt(17).lt(66).\n      where('likes').in(['vaporizing', 'talking']).\n      limit(10).\n      sort('-occupation').\n      select('name occupation').\n      exec(callback);\n    ```\n\n### Population\n\n　　在 Mongodb 中并没有像关系数据库中的表一样拥有 join 操作, 能够将多个表连接起来作为结果返回,但 mongoose 提供了Population,让不同集合中的多个 document 可以联系在一起,然后整体作为结果返回,这和关系数据库中的表连接有些类似。\n\n　　首先要连接两个 document ,在创建的时候,这两个 document 需要有对应的关系,像\"一对多\",\"多对一\",\"多对多\"。如下:\n\n```javascript\nvar mongoose = require('mongoose')\n  , Schema = mongoose.Schema\n  \nvar personSchema = Schema({\n  _id     : Number,\n  name    : String,\n  age     : Number,\n  stories : [{ type: Schema.Types.ObjectId, ref: 'Story' }]\n});\n\nvar storySchema = Schema({\n  _creator : { type: Number, ref: 'Person' },\n  title    : String,\n  fans     : [{ type: Number, ref: 'Person' }]\n});\n\nvar Story  = mongoose.model('Story', storySchema);\nvar Person = mongoose.model('Person', personSchema);\n\n```\n\nPerson 和 Story 就存在着一种或者多种对应关系, 一个 Person 对应着多个 Story,在Person Schema中表现出来就是有一个 stories 字段,它的值是这个 Person 所拥有的 stories objectId 数组。对于 Story 也同样存在着这样的保存对应关系的字段。在需要 populate 时,就会根据这些关系进行连接填充。首先我们先创建 Person 和 Story :\n \n ```javascript\n //创建 document 并保存对应关系到相应的字段中去。\n var aaron = new Person({ _id: 0, name: 'Aaron', age: 100 });\n \n aaron.save(function (err) {\n   if (err) return handleError(err);\n   \n   var story1 = new Story({\n     title: \"Once upon a timex.\",\n     _creator: aaron._id    // assign the _id from the person\n   });\n   \n   story1.save(function (err) {\n     if (err) return handleError(err);\n     // thats it!\n   });\n });\n ```\n \n 目前为止,并没有什么特殊的地方,仅仅就是创建了 document 并保存。接下来我们看下 population 的作用,我们 populate story中的 _creator 字段,其实就是 mongoose 通过一定的方式,将 _creator 值(Person 的 object Id),作为查询条件得到对应的Person,然后赋值给story 中的 _creator字段。如下:\n \n ```javascript\n Story\n .findOne({ title: 'Once upon a timex.' })\n .populate('_creator')\n .exec(function (err, story) {\n   if (err) return handleError(err);\n   console.log('The creator is %s', story._creator.name);\n   // prints \"The creator is Aaron\"\n });\n ```\n 其中,populate 方法中的参数 \"_creator\" 就是 populate path。 上面的方法你可以通过先查询得到对应 objectId 的 Person 文档,然后手动赋值给对应的story _creator达到目的。\n \n ```javascript\n Story.findOne({ title: 'Once upon a timex.' }, function(error, story) {\n   if (error) {\n     return handleError(error);\n   }\n   story._creator = aaron;\n   console.log(story._creator.name); // prints \"Aaron\"\n });\n ```\n \n > Note that this only works for single refs. You currently can't manually populate an array of refs.\n \n在 populate 的过程中,你可以剔除不需要的字段,仅仅连接你所需要的字段到当前 document 中,比如你只需要 Person 的 name,那么你可以这么干:\n\n```javascript\nStory\n.findOne({ title: /timex/i })\n.populate('_creator', 'name') // only return the Persons name\n.exec(function (err, story) {\n  if (err) return handleError(err);\n  \n  console.log('The creator is %s', story._creator.name);\n  // prints \"The creator is Aaron\"\n  \n  console.log('The creators age is %s', story._creator.age);\n  // prints \"The creators age is null'\n})\n```\n\nPopulating 多个 Path,如果你同时想要story 中的 _creator 字段和 fans 字段被具体对应的 document 填充,可以通过空格分隔多个 path 作为 populate 方法的参数。如下:\n\n```javascript\nStory\n.find(...)\n.populate('fans _creator') // space delimited path names\n.exec()\n```\n\n但是在 mongoose 3.6版本以及这个版本之后我们才能这么干,在这之前我们只能通过如下的方式实现相同的目的:\n \n ```javascript\n Story\n .find(...)\n .populate('fans')\n .populate('_creator')\n .exec()\n ```\n \npopulate 方法支持 Object 对象作为参数,如你想只populate 一定年龄的,只需要填充返回你指定的字段,返回指定数目的documents,那么你可以这么干\n\n```javascript\nStory\n.find(...)\n.populate({\n  path: 'fans',\n  match: { age: { $gte: 21 }},\n  select: 'name -_id',\n  options: { limit: 5 }\n})\n.exec()\n```\n\n\n### 总结\n\nmongoose 给用户提供了便利的方法来查询文档和连接相关的文档,上面只是对用法做了简单的说明,更多的内容大家可以参看官方提供的文档[Query](http://mongoosejs.com/docs/queries.html),[Population](http://mongoosejs.com/docs/populate.html)。","slug":"mongoose-tutorial-2","published":1,"updated":"2017-05-08T14:40:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhqr000ub37qo0xcteh7","content":"<h3 id=\"Query\"><a href=\"#Query\" class=\"headerlink\" title=\"Query\"></a>Query</h3><p>　　数据库操作中查询肯定少不了,Documents 可以通过models的一些静态辅助方法来获取,这些方法可以以两种方式执行。</p>\n<ol>\n<li><p>当 callback 回调函数作为参数传递给这些静态辅助函数的时候,相应的操作会立即执行,并将结果传递给 callback 回调函数。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Person = mongoose.model(<span class=\"string\">'Person'</span>, yourSchema);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// find each person with a last name matching 'Ghost', selecting the `name` and `occupation` fields</span></div><div class=\"line\">Person.findOne(&#123; <span class=\"string\">'name.last'</span>: <span class=\"string\">'Ghost'</span> &#125;, <span class=\"string\">'name occupation'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, person</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'%s %s is a %s.'</span>, person.name.first, person.name.last, person.occupation) <span class=\"comment\">// Space Ghost is a talk show host.</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>callback 需要接受两个参数,一个是err,一个是result。`` callback(error, result)`` 这种模式,如果有错误,则error为错误对象,result为空,反之error为空,result为返回的结果,可能是文档对象,可能是文档对象数组,或者是文档个数。\n</code></pre><ol>\n<li><p>当没有 callback , Query的实例会被返回,这个相当于promise,通过query对象我们可以进行后续的操作。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// find each person with a last name matching 'Ghost'</span></div><div class=\"line\"><span class=\"keyword\">var</span> query = Person.findOne(&#123; <span class=\"string\">'name.last'</span>: <span class=\"string\">'Ghost'</span> &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// selecting the `name` and `occupation` fields</span></div><div class=\"line\">query.select(<span class=\"string\">'name occupation'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// execute the query at a later time</span></div><div class=\"line\">query.exec(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, person</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'%s %s is a %s.'</span>, person.name.first, person.name.last, person.occupation) <span class=\"comment\">// Space Ghost is a talk show host.</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p> query 对象提供了一种让你能够链式调用的方法,让你经过一系列处理和过滤后得到最终想要的结果。如下代码:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// With a JSON doc</span></div><div class=\"line\">Person.</div><div class=\"line\">  find(&#123;</div><div class=\"line\">    <span class=\"attr\">occupation</span>: <span class=\"regexp\">/host/</span>,</div><div class=\"line\">    <span class=\"string\">'name.last'</span>: <span class=\"string\">'Ghost'</span>,</div><div class=\"line\">    <span class=\"attr\">age</span>: &#123; <span class=\"attr\">$gt</span>: <span class=\"number\">17</span>, <span class=\"attr\">$lt</span>: <span class=\"number\">66</span> &#125;,</div><div class=\"line\">    <span class=\"attr\">likes</span>: &#123; <span class=\"attr\">$in</span>: [<span class=\"string\">'vaporizing'</span>, <span class=\"string\">'talking'</span>] &#125;</div><div class=\"line\">  &#125;).</div><div class=\"line\">  limit(<span class=\"number\">10</span>).</div><div class=\"line\">  sort(&#123; <span class=\"attr\">occupation</span>: <span class=\"number\">-1</span> &#125;).</div><div class=\"line\">  select(&#123; <span class=\"attr\">name</span>: <span class=\"number\">1</span>, <span class=\"attr\">occupation</span>: <span class=\"number\">1</span> &#125;).</div><div class=\"line\">  exec(callback);</div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// Using query builder</span></div><div class=\"line\">Person.</div><div class=\"line\">  find(&#123; <span class=\"attr\">occupation</span>: <span class=\"regexp\">/host/</span> &#125;).</div><div class=\"line\">  where(<span class=\"string\">'name.last'</span>).equals(<span class=\"string\">'Ghost'</span>).</div><div class=\"line\">  where(<span class=\"string\">'age'</span>).gt(<span class=\"number\">17</span>).lt(<span class=\"number\">66</span>).</div><div class=\"line\">  where(<span class=\"string\">'likes'</span>).in([<span class=\"string\">'vaporizing'</span>, <span class=\"string\">'talking'</span>]).</div><div class=\"line\">  limit(<span class=\"number\">10</span>).</div><div class=\"line\">  sort(<span class=\"string\">'-occupation'</span>).</div><div class=\"line\">  select(<span class=\"string\">'name occupation'</span>).</div><div class=\"line\">  exec(callback);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Population\"><a href=\"#Population\" class=\"headerlink\" title=\"Population\"></a>Population</h3><p>　　在 Mongodb 中并没有像关系数据库中的表一样拥有 join 操作, 能够将多个表连接起来作为结果返回,但 mongoose 提供了Population,让不同集合中的多个 document 可以联系在一起,然后整体作为结果返回,这和关系数据库中的表连接有些类似。</p>\n<p>　　首先要连接两个 document ,在创建的时候,这两个 document 需要有对应的关系,像”一对多”,”多对一”,”多对多”。如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>)</div><div class=\"line\">  , Schema = mongoose.Schema</div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">var</span> personSchema = Schema(&#123;</div><div class=\"line\">  <span class=\"attr\">_id</span>     : <span class=\"built_in\">Number</span>,</div><div class=\"line\">  <span class=\"attr\">name</span>    : <span class=\"built_in\">String</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>     : <span class=\"built_in\">Number</span>,</div><div class=\"line\">  <span class=\"attr\">stories</span> : [&#123; <span class=\"attr\">type</span>: Schema.Types.ObjectId, <span class=\"attr\">ref</span>: <span class=\"string\">'Story'</span> &#125;]</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> storySchema = Schema(&#123;</div><div class=\"line\">  <span class=\"attr\">_creator</span> : &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>, <span class=\"attr\">ref</span>: <span class=\"string\">'Person'</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">title</span>    : <span class=\"built_in\">String</span>,</div><div class=\"line\">  <span class=\"attr\">fans</span>     : [&#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>, <span class=\"attr\">ref</span>: <span class=\"string\">'Person'</span> &#125;]</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Story  = mongoose.model(<span class=\"string\">'Story'</span>, storySchema);</div><div class=\"line\"><span class=\"keyword\">var</span> Person = mongoose.model(<span class=\"string\">'Person'</span>, personSchema);</div></pre></td></tr></table></figure>\n<p>Person 和 Story 就存在着一种或者多种对应关系, 一个 Person 对应着多个 Story,在Person Schema中表现出来就是有一个 stories 字段,它的值是这个 Person 所拥有的 stories objectId 数组。对于 Story 也同样存在着这样的保存对应关系的字段。在需要 populate 时,就会根据这些关系进行连接填充。首先我们先创建 Person 和 Story :</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建 document 并保存对应关系到相应的字段中去。</span></div><div class=\"line\"><span class=\"keyword\">var</span> aaron = <span class=\"keyword\">new</span> Person(&#123; <span class=\"attr\">_id</span>: <span class=\"number\">0</span>, <span class=\"attr\">name</span>: <span class=\"string\">'Aaron'</span>, <span class=\"attr\">age</span>: <span class=\"number\">100</span> &#125;);</div><div class=\"line\"></div><div class=\"line\">aaron.save(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">var</span> story1 = <span class=\"keyword\">new</span> Story(&#123;</div><div class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">\"Once upon a timex.\"</span>,</div><div class=\"line\">    <span class=\"attr\">_creator</span>: aaron._id    <span class=\"comment\">// assign the _id from the person</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  </div><div class=\"line\">  story1.save(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">    <span class=\"comment\">// thats it!</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 目前为止,并没有什么特殊的地方,仅仅就是创建了 document 并保存。接下来我们看下 population 的作用,我们 populate story中的 _creator 字段,其实就是 mongoose 通过一定的方式,将 _creator 值(Person 的 object Id),作为查询条件得到对应的Person,然后赋值给story 中的 _creator字段。如下:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story</div><div class=\"line\">.findOne(&#123; <span class=\"attr\">title</span>: <span class=\"string\">'Once upon a timex.'</span> &#125;)</div><div class=\"line\">.populate(<span class=\"string\">'_creator'</span>)</div><div class=\"line\">.exec(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, story</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The creator is %s'</span>, story._creator.name);</div><div class=\"line\">  <span class=\"comment\">// prints \"The creator is Aaron\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 其中,populate 方法中的参数 “_creator” 就是 populate path。 上面的方法你可以通过先查询得到对应 objectId 的 Person 文档,然后手动赋值给对应的story _creator达到目的。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story.findOne(&#123; <span class=\"attr\">title</span>: <span class=\"string\">'Once upon a timex.'</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, story</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> handleError(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">  story._creator = aaron;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(story._creator.name); <span class=\"comment\">// prints \"Aaron\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Note that this only works for single refs. You currently can’t manually populate an array of refs.</p>\n</blockquote>\n<p>在 populate 的过程中,你可以剔除不需要的字段,仅仅连接你所需要的字段到当前 document 中,比如你只需要 Person 的 name,那么你可以这么干:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story</div><div class=\"line\">.findOne(&#123; <span class=\"attr\">title</span>: <span class=\"regexp\">/timex/i</span> &#125;)</div><div class=\"line\">.populate(<span class=\"string\">'_creator'</span>, <span class=\"string\">'name'</span>) <span class=\"comment\">// only return the Persons name</span></div><div class=\"line\">.exec(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, story</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The creator is %s'</span>, story._creator.name);</div><div class=\"line\">  <span class=\"comment\">// prints \"The creator is Aaron\"</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The creators age is %s'</span>, story._creator.age);</div><div class=\"line\">  <span class=\"comment\">// prints \"The creators age is null'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>Populating 多个 Path,如果你同时想要story 中的 _creator 字段和 fans 字段被具体对应的 document 填充,可以通过空格分隔多个 path 作为 populate 方法的参数。如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story</div><div class=\"line\">.find(...)</div><div class=\"line\">.populate(<span class=\"string\">'fans _creator'</span>) <span class=\"comment\">// space delimited path names</span></div><div class=\"line\">.exec()</div></pre></td></tr></table></figure>\n<p>但是在 mongoose 3.6版本以及这个版本之后我们才能这么干,在这之前我们只能通过如下的方式实现相同的目的:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story</div><div class=\"line\">.find(...)</div><div class=\"line\">.populate(<span class=\"string\">'fans'</span>)</div><div class=\"line\">.populate(<span class=\"string\">'_creator'</span>)</div><div class=\"line\">.exec()</div></pre></td></tr></table></figure>\n<p>populate 方法支持 Object 对象作为参数,如你想只populate 一定年龄的,只需要填充返回你指定的字段,返回指定数目的documents,那么你可以这么干</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story</div><div class=\"line\">.find(...)</div><div class=\"line\">.populate(&#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'fans'</span>,</div><div class=\"line\">  <span class=\"attr\">match</span>: &#123; <span class=\"attr\">age</span>: &#123; <span class=\"attr\">$gte</span>: <span class=\"number\">21</span> &#125;&#125;,</div><div class=\"line\">  <span class=\"attr\">select</span>: <span class=\"string\">'name -_id'</span>,</div><div class=\"line\">  <span class=\"attr\">options</span>: &#123; <span class=\"attr\">limit</span>: <span class=\"number\">5</span> &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">.exec()</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>mongoose 给用户提供了便利的方法来查询文档和连接相关的文档,上面只是对用法做了简单的说明,更多的内容大家可以参看官方提供的文档<a href=\"http://mongoosejs.com/docs/queries.html\" target=\"_blank\" rel=\"external\">Query</a>,<a href=\"http://mongoosejs.com/docs/populate.html\" target=\"_blank\" rel=\"external\">Population</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Query\"><a href=\"#Query\" class=\"headerlink\" title=\"Query\"></a>Query</h3><p>　　数据库操作中查询肯定少不了,Documents 可以通过models的一些静态辅助方法来获取,这些方法可以以两种方式执行。</p>\n<ol>\n<li><p>当 callback 回调函数作为参数传递给这些静态辅助函数的时候,相应的操作会立即执行,并将结果传递给 callback 回调函数。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Person = mongoose.model(<span class=\"string\">'Person'</span>, yourSchema);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// find each person with a last name matching 'Ghost', selecting the `name` and `occupation` fields</span></div><div class=\"line\">Person.findOne(&#123; <span class=\"string\">'name.last'</span>: <span class=\"string\">'Ghost'</span> &#125;, <span class=\"string\">'name occupation'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, person</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'%s %s is a %s.'</span>, person.name.first, person.name.last, person.occupation) <span class=\"comment\">// Space Ghost is a talk show host.</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<pre><code>callback 需要接受两个参数,一个是err,一个是result。`` callback(error, result)`` 这种模式,如果有错误,则error为错误对象,result为空,反之error为空,result为返回的结果,可能是文档对象,可能是文档对象数组,或者是文档个数。\n</code></pre><ol>\n<li><p>当没有 callback , Query的实例会被返回,这个相当于promise,通过query对象我们可以进行后续的操作。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// find each person with a last name matching 'Ghost'</span></div><div class=\"line\"><span class=\"keyword\">var</span> query = Person.findOne(&#123; <span class=\"string\">'name.last'</span>: <span class=\"string\">'Ghost'</span> &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// selecting the `name` and `occupation` fields</span></div><div class=\"line\">query.select(<span class=\"string\">'name occupation'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// execute the query at a later time</span></div><div class=\"line\">query.exec(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, person</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'%s %s is a %s.'</span>, person.name.first, person.name.last, person.occupation) <span class=\"comment\">// Space Ghost is a talk show host.</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p> query 对象提供了一种让你能够链式调用的方法,让你经过一系列处理和过滤后得到最终想要的结果。如下代码:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// With a JSON doc</span></div><div class=\"line\">Person.</div><div class=\"line\">  find(&#123;</div><div class=\"line\">    <span class=\"attr\">occupation</span>: <span class=\"regexp\">/host/</span>,</div><div class=\"line\">    <span class=\"string\">'name.last'</span>: <span class=\"string\">'Ghost'</span>,</div><div class=\"line\">    <span class=\"attr\">age</span>: &#123; <span class=\"attr\">$gt</span>: <span class=\"number\">17</span>, <span class=\"attr\">$lt</span>: <span class=\"number\">66</span> &#125;,</div><div class=\"line\">    <span class=\"attr\">likes</span>: &#123; <span class=\"attr\">$in</span>: [<span class=\"string\">'vaporizing'</span>, <span class=\"string\">'talking'</span>] &#125;</div><div class=\"line\">  &#125;).</div><div class=\"line\">  limit(<span class=\"number\">10</span>).</div><div class=\"line\">  sort(&#123; <span class=\"attr\">occupation</span>: <span class=\"number\">-1</span> &#125;).</div><div class=\"line\">  select(&#123; <span class=\"attr\">name</span>: <span class=\"number\">1</span>, <span class=\"attr\">occupation</span>: <span class=\"number\">1</span> &#125;).</div><div class=\"line\">  exec(callback);</div><div class=\"line\">  </div><div class=\"line\"><span class=\"comment\">// Using query builder</span></div><div class=\"line\">Person.</div><div class=\"line\">  find(&#123; <span class=\"attr\">occupation</span>: <span class=\"regexp\">/host/</span> &#125;).</div><div class=\"line\">  where(<span class=\"string\">'name.last'</span>).equals(<span class=\"string\">'Ghost'</span>).</div><div class=\"line\">  where(<span class=\"string\">'age'</span>).gt(<span class=\"number\">17</span>).lt(<span class=\"number\">66</span>).</div><div class=\"line\">  where(<span class=\"string\">'likes'</span>).in([<span class=\"string\">'vaporizing'</span>, <span class=\"string\">'talking'</span>]).</div><div class=\"line\">  limit(<span class=\"number\">10</span>).</div><div class=\"line\">  sort(<span class=\"string\">'-occupation'</span>).</div><div class=\"line\">  select(<span class=\"string\">'name occupation'</span>).</div><div class=\"line\">  exec(callback);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"Population\"><a href=\"#Population\" class=\"headerlink\" title=\"Population\"></a>Population</h3><p>　　在 Mongodb 中并没有像关系数据库中的表一样拥有 join 操作, 能够将多个表连接起来作为结果返回,但 mongoose 提供了Population,让不同集合中的多个 document 可以联系在一起,然后整体作为结果返回,这和关系数据库中的表连接有些类似。</p>\n<p>　　首先要连接两个 document ,在创建的时候,这两个 document 需要有对应的关系,像”一对多”,”多对一”,”多对多”。如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mongoose = <span class=\"built_in\">require</span>(<span class=\"string\">'mongoose'</span>)</div><div class=\"line\">  , Schema = mongoose.Schema</div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">var</span> personSchema = Schema(&#123;</div><div class=\"line\">  <span class=\"attr\">_id</span>     : <span class=\"built_in\">Number</span>,</div><div class=\"line\">  <span class=\"attr\">name</span>    : <span class=\"built_in\">String</span>,</div><div class=\"line\">  <span class=\"attr\">age</span>     : <span class=\"built_in\">Number</span>,</div><div class=\"line\">  <span class=\"attr\">stories</span> : [&#123; <span class=\"attr\">type</span>: Schema.Types.ObjectId, <span class=\"attr\">ref</span>: <span class=\"string\">'Story'</span> &#125;]</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> storySchema = Schema(&#123;</div><div class=\"line\">  <span class=\"attr\">_creator</span> : &#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>, <span class=\"attr\">ref</span>: <span class=\"string\">'Person'</span> &#125;,</div><div class=\"line\">  <span class=\"attr\">title</span>    : <span class=\"built_in\">String</span>,</div><div class=\"line\">  <span class=\"attr\">fans</span>     : [&#123; <span class=\"attr\">type</span>: <span class=\"built_in\">Number</span>, <span class=\"attr\">ref</span>: <span class=\"string\">'Person'</span> &#125;]</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> Story  = mongoose.model(<span class=\"string\">'Story'</span>, storySchema);</div><div class=\"line\"><span class=\"keyword\">var</span> Person = mongoose.model(<span class=\"string\">'Person'</span>, personSchema);</div></pre></td></tr></table></figure>\n<p>Person 和 Story 就存在着一种或者多种对应关系, 一个 Person 对应着多个 Story,在Person Schema中表现出来就是有一个 stories 字段,它的值是这个 Person 所拥有的 stories objectId 数组。对于 Story 也同样存在着这样的保存对应关系的字段。在需要 populate 时,就会根据这些关系进行连接填充。首先我们先创建 Person 和 Story :</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建 document 并保存对应关系到相应的字段中去。</span></div><div class=\"line\"><span class=\"keyword\">var</span> aaron = <span class=\"keyword\">new</span> Person(&#123; <span class=\"attr\">_id</span>: <span class=\"number\">0</span>, <span class=\"attr\">name</span>: <span class=\"string\">'Aaron'</span>, <span class=\"attr\">age</span>: <span class=\"number\">100</span> &#125;);</div><div class=\"line\"></div><div class=\"line\">aaron.save(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"keyword\">var</span> story1 = <span class=\"keyword\">new</span> Story(&#123;</div><div class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">\"Once upon a timex.\"</span>,</div><div class=\"line\">    <span class=\"attr\">_creator</span>: aaron._id    <span class=\"comment\">// assign the _id from the person</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">  </div><div class=\"line\">  story1.save(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">    <span class=\"comment\">// thats it!</span></div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 目前为止,并没有什么特殊的地方,仅仅就是创建了 document 并保存。接下来我们看下 population 的作用,我们 populate story中的 _creator 字段,其实就是 mongoose 通过一定的方式,将 _creator 值(Person 的 object Id),作为查询条件得到对应的Person,然后赋值给story 中的 _creator字段。如下:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story</div><div class=\"line\">.findOne(&#123; <span class=\"attr\">title</span>: <span class=\"string\">'Once upon a timex.'</span> &#125;)</div><div class=\"line\">.populate(<span class=\"string\">'_creator'</span>)</div><div class=\"line\">.exec(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, story</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The creator is %s'</span>, story._creator.name);</div><div class=\"line\">  <span class=\"comment\">// prints \"The creator is Aaron\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p> 其中,populate 方法中的参数 “_creator” 就是 populate path。 上面的方法你可以通过先查询得到对应 objectId 的 Person 文档,然后手动赋值给对应的story _creator达到目的。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story.findOne(&#123; <span class=\"attr\">title</span>: <span class=\"string\">'Once upon a timex.'</span> &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, story</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (error) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> handleError(error);</div><div class=\"line\">  &#125;</div><div class=\"line\">  story._creator = aaron;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(story._creator.name); <span class=\"comment\">// prints \"Aaron\"</span></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Note that this only works for single refs. You currently can’t manually populate an array of refs.</p>\n</blockquote>\n<p>在 populate 的过程中,你可以剔除不需要的字段,仅仅连接你所需要的字段到当前 document 中,比如你只需要 Person 的 name,那么你可以这么干:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story</div><div class=\"line\">.findOne(&#123; <span class=\"attr\">title</span>: <span class=\"regexp\">/timex/i</span> &#125;)</div><div class=\"line\">.populate(<span class=\"string\">'_creator'</span>, <span class=\"string\">'name'</span>) <span class=\"comment\">// only return the Persons name</span></div><div class=\"line\">.exec(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, story</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handleError(err);</div><div class=\"line\">  </div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The creator is %s'</span>, story._creator.name);</div><div class=\"line\">  <span class=\"comment\">// prints \"The creator is Aaron\"</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'The creators age is %s'</span>, story._creator.age);</div><div class=\"line\">  <span class=\"comment\">// prints \"The creators age is null'</span></div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>Populating 多个 Path,如果你同时想要story 中的 _creator 字段和 fans 字段被具体对应的 document 填充,可以通过空格分隔多个 path 作为 populate 方法的参数。如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story</div><div class=\"line\">.find(...)</div><div class=\"line\">.populate(<span class=\"string\">'fans _creator'</span>) <span class=\"comment\">// space delimited path names</span></div><div class=\"line\">.exec()</div></pre></td></tr></table></figure>\n<p>但是在 mongoose 3.6版本以及这个版本之后我们才能这么干,在这之前我们只能通过如下的方式实现相同的目的:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story</div><div class=\"line\">.find(...)</div><div class=\"line\">.populate(<span class=\"string\">'fans'</span>)</div><div class=\"line\">.populate(<span class=\"string\">'_creator'</span>)</div><div class=\"line\">.exec()</div></pre></td></tr></table></figure>\n<p>populate 方法支持 Object 对象作为参数,如你想只populate 一定年龄的,只需要填充返回你指定的字段,返回指定数目的documents,那么你可以这么干</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">Story</div><div class=\"line\">.find(...)</div><div class=\"line\">.populate(&#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'fans'</span>,</div><div class=\"line\">  <span class=\"attr\">match</span>: &#123; <span class=\"attr\">age</span>: &#123; <span class=\"attr\">$gte</span>: <span class=\"number\">21</span> &#125;&#125;,</div><div class=\"line\">  <span class=\"attr\">select</span>: <span class=\"string\">'name -_id'</span>,</div><div class=\"line\">  <span class=\"attr\">options</span>: &#123; <span class=\"attr\">limit</span>: <span class=\"number\">5</span> &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\">.exec()</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>mongoose 给用户提供了便利的方法来查询文档和连接相关的文档,上面只是对用法做了简单的说明,更多的内容大家可以参看官方提供的文档<a href=\"http://mongoosejs.com/docs/queries.html\" target=\"_blank\" rel=\"external\">Query</a>,<a href=\"http://mongoosejs.com/docs/populate.html\" target=\"_blank\" rel=\"external\">Population</a>。</p>\n"},{"title":"React 的生命周期","type":"original","date":"2017-04-26T08:54:58.000Z","description":"对于React的生命周期,只要知道在整个生命周期里,有的生命周期函数只调用一次,有的在每次数据更新的时候会被反复调用。","_content":"\n对于React的生命周期,只要知道在整个生命周期里,有的生命周期函数只调用一次,有的在每次数据更新的时候会被反复调用。如下图:\n\n![react-life-cycle](http://rainypin.qiniudn.com/git_imgs/react-life-cycle.png)\n\n### React 生命周期的三个阶段\n\n#### 1. 组件初始化\n初始化阶段执行的生命周期函数(除了render)在整个生命周期中只会被执行一次。\n* ``getDefaultProps`` \n\n    > 设置组件的初始属性,ES6写法和这里的ES5写法有所区别:\n    \n     ```\n       static defaultProps = {\n         defaultTxt : 'AA'\n       };\n     ```\n    \n* ``getInitialState``\n\n    > 设置组件的初始状态,ES6写法和这里的ES5写法有所区别,是在ES6类的构造器中进行初始化:\n    \n    ```\n     constructor(props) {\n        super(props);\n        this.state = {\n          state1 : 'xxx'\n        };\n      }\n    ```\n    \n* ``componentWillMount``\n\n    > 组件即将被挂载前执行的生命周期函数,在这个函数里是组件挂载之前修改组件状态的最后机会。这个函数只会在第一次初始化的时候才会被执行到,后续组件存在期,组件状态的变更将不再被执行。\n* ``render``\n\n    > 将React Elements 渲染进DOM,整个生命周期被执行最多的函数,渲染的时候采用的是最小化增量更新,所以理论上React 会有不错的性能。\n* ``componentDidMount``\n\n    > React 组件以及成功挂载到DOM中的hooks函数。在这个函数内可以对组件进行DOM操作,在初始化阶段,只有在这个方法内才能够通过``this.refs.elementId``读取到组件的DOM节点。 \n    \n### 2. 组件存在期\n\n组件的存在期,应该是整个生命周期中最长的一个阶段,也是组件响应用户的行为的一个阶段。\n\n* ``componentWillReceiveProps(nextProps)``\n\n    > 组件在存在期接受的父组件提供的属性发生变化,或者调用了setProps修改组件属性的时候将会被调用,开始一个组件更新的cycle。\n    \n* ``shouldComponentUpdate(nextProps,nextState)``\n\n    > 这个生命周期方法只会在存在期阶段被调用,当组件的属性发生变化(父组件下发的属性改变,setProps被调用),组件的状态发生改变(setState被调用)该方法就会在一个cycle中被执行到且只有当该方法返回true,cycle中后续的函数才有机会被执行,不然后续函数将不会被执行,所以这个函数常常作为React性能优化的地方,省去不必要的渲染更新。\n\n* ``componentWillUpdate(nextProps,nextState)``\n\n    > 组件更新之前会被执行的函数。\n* ``render``\n\n    > 同初始阶段,但在componentWillUpdate之后componentDidUpdate之前执行。\n    \n* ``componentDidUpdate(prevProps,prevState)``\n\n    > 组件成功更新后的hooks函数。当组件更新完成会被调用。\n    \n### 3. 组件销毁&清理 \n\n当切换页面,或者切换组件的时候,组件就会被销毁,这个时候,往往需要对组件进行一些清理操作,释放一些资源。\n* componentWillUnmount \n\n  > 这个方法用来在组件销毁前做一些清理,释放占用资源,解除事件绑定等操作。整个生命周期会被执行一次。\n","source":"_posts/react-life-cycle.md","raw":"---\ntitle: React 的生命周期\ntype: original\ntags: [React]\ncategories: [React]\ndate: 2017-04-26 16:54:58\ndescription: 对于React的生命周期,只要知道在整个生命周期里,有的生命周期函数只调用一次,有的在每次数据更新的时候会被反复调用。\n---\n\n对于React的生命周期,只要知道在整个生命周期里,有的生命周期函数只调用一次,有的在每次数据更新的时候会被反复调用。如下图:\n\n![react-life-cycle](http://rainypin.qiniudn.com/git_imgs/react-life-cycle.png)\n\n### React 生命周期的三个阶段\n\n#### 1. 组件初始化\n初始化阶段执行的生命周期函数(除了render)在整个生命周期中只会被执行一次。\n* ``getDefaultProps`` \n\n    > 设置组件的初始属性,ES6写法和这里的ES5写法有所区别:\n    \n     ```\n       static defaultProps = {\n         defaultTxt : 'AA'\n       };\n     ```\n    \n* ``getInitialState``\n\n    > 设置组件的初始状态,ES6写法和这里的ES5写法有所区别,是在ES6类的构造器中进行初始化:\n    \n    ```\n     constructor(props) {\n        super(props);\n        this.state = {\n          state1 : 'xxx'\n        };\n      }\n    ```\n    \n* ``componentWillMount``\n\n    > 组件即将被挂载前执行的生命周期函数,在这个函数里是组件挂载之前修改组件状态的最后机会。这个函数只会在第一次初始化的时候才会被执行到,后续组件存在期,组件状态的变更将不再被执行。\n* ``render``\n\n    > 将React Elements 渲染进DOM,整个生命周期被执行最多的函数,渲染的时候采用的是最小化增量更新,所以理论上React 会有不错的性能。\n* ``componentDidMount``\n\n    > React 组件以及成功挂载到DOM中的hooks函数。在这个函数内可以对组件进行DOM操作,在初始化阶段,只有在这个方法内才能够通过``this.refs.elementId``读取到组件的DOM节点。 \n    \n### 2. 组件存在期\n\n组件的存在期,应该是整个生命周期中最长的一个阶段,也是组件响应用户的行为的一个阶段。\n\n* ``componentWillReceiveProps(nextProps)``\n\n    > 组件在存在期接受的父组件提供的属性发生变化,或者调用了setProps修改组件属性的时候将会被调用,开始一个组件更新的cycle。\n    \n* ``shouldComponentUpdate(nextProps,nextState)``\n\n    > 这个生命周期方法只会在存在期阶段被调用,当组件的属性发生变化(父组件下发的属性改变,setProps被调用),组件的状态发生改变(setState被调用)该方法就会在一个cycle中被执行到且只有当该方法返回true,cycle中后续的函数才有机会被执行,不然后续函数将不会被执行,所以这个函数常常作为React性能优化的地方,省去不必要的渲染更新。\n\n* ``componentWillUpdate(nextProps,nextState)``\n\n    > 组件更新之前会被执行的函数。\n* ``render``\n\n    > 同初始阶段,但在componentWillUpdate之后componentDidUpdate之前执行。\n    \n* ``componentDidUpdate(prevProps,prevState)``\n\n    > 组件成功更新后的hooks函数。当组件更新完成会被调用。\n    \n### 3. 组件销毁&清理 \n\n当切换页面,或者切换组件的时候,组件就会被销毁,这个时候,往往需要对组件进行一些清理操作,释放一些资源。\n* componentWillUnmount \n\n  > 这个方法用来在组件销毁前做一些清理,释放占用资源,解除事件绑定等操作。整个生命周期会被执行一次。\n","slug":"react-life-cycle","published":1,"updated":"2017-05-03T05:53:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhqu000xb37qpgw9ssd9","content":"<p>对于React的生命周期,只要知道在整个生命周期里,有的生命周期函数只调用一次,有的在每次数据更新的时候会被反复调用。如下图:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/react-life-cycle.png\" alt=\"react-life-cycle\"></p>\n<h3 id=\"React-生命周期的三个阶段\"><a href=\"#React-生命周期的三个阶段\" class=\"headerlink\" title=\"React 生命周期的三个阶段\"></a>React 生命周期的三个阶段</h3><h4 id=\"1-组件初始化\"><a href=\"#1-组件初始化\" class=\"headerlink\" title=\"1. 组件初始化\"></a>1. 组件初始化</h4><p>初始化阶段执行的生命周期函数(除了render)在整个生命周期中只会被执行一次。</p>\n<ul>\n<li><p><code>getDefaultProps</code> </p>\n<blockquote>\n<p>设置组件的初始属性,ES6写法和这里的ES5写法有所区别:</p>\n</blockquote>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">static defaultProps = &#123;</div><div class=\"line\">  defaultTxt : &apos;AA&apos;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><code>getInitialState</code></p>\n<blockquote>\n<p>设置组件的初始状态,ES6写法和这里的ES5写法有所区别,是在ES6类的构造器中进行初始化:</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">constructor(props) &#123;</div><div class=\"line\">   super(props);</div><div class=\"line\">   this.state = &#123;</div><div class=\"line\">     state1 : &apos;xxx&apos;</div><div class=\"line\">   &#125;;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><code>componentWillMount</code></p>\n<blockquote>\n<p>组件即将被挂载前执行的生命周期函数,在这个函数里是组件挂载之前修改组件状态的最后机会。这个函数只会在第一次初始化的时候才会被执行到,后续组件存在期,组件状态的变更将不再被执行。</p>\n</blockquote>\n</li>\n<li><p><code>render</code></p>\n<blockquote>\n<p>将React Elements 渲染进DOM,整个生命周期被执行最多的函数,渲染的时候采用的是最小化增量更新,所以理论上React 会有不错的性能。</p>\n</blockquote>\n</li>\n<li><p><code>componentDidMount</code></p>\n<blockquote>\n<p>React 组件以及成功挂载到DOM中的hooks函数。在这个函数内可以对组件进行DOM操作,在初始化阶段,只有在这个方法内才能够通过<code>this.refs.elementId</code>读取到组件的DOM节点。 </p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2-组件存在期\"><a href=\"#2-组件存在期\" class=\"headerlink\" title=\"2. 组件存在期\"></a>2. 组件存在期</h3><p>组件的存在期,应该是整个生命周期中最长的一个阶段,也是组件响应用户的行为的一个阶段。</p>\n<ul>\n<li><p><code>componentWillReceiveProps(nextProps)</code></p>\n<blockquote>\n<p>组件在存在期接受的父组件提供的属性发生变化,或者调用了setProps修改组件属性的时候将会被调用,开始一个组件更新的cycle。</p>\n</blockquote>\n</li>\n<li><p><code>shouldComponentUpdate(nextProps,nextState)</code></p>\n<blockquote>\n<p>这个生命周期方法只会在存在期阶段被调用,当组件的属性发生变化(父组件下发的属性改变,setProps被调用),组件的状态发生改变(setState被调用)该方法就会在一个cycle中被执行到且只有当该方法返回true,cycle中后续的函数才有机会被执行,不然后续函数将不会被执行,所以这个函数常常作为React性能优化的地方,省去不必要的渲染更新。</p>\n</blockquote>\n</li>\n<li><p><code>componentWillUpdate(nextProps,nextState)</code></p>\n<blockquote>\n<p>组件更新之前会被执行的函数。</p>\n</blockquote>\n</li>\n<li><p><code>render</code></p>\n<blockquote>\n<p>同初始阶段,但在componentWillUpdate之后componentDidUpdate之前执行。</p>\n</blockquote>\n</li>\n<li><p><code>componentDidUpdate(prevProps,prevState)</code></p>\n<blockquote>\n<p>组件成功更新后的hooks函数。当组件更新完成会被调用。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"3-组件销毁-amp-清理\"><a href=\"#3-组件销毁-amp-清理\" class=\"headerlink\" title=\"3. 组件销毁&amp;清理\"></a>3. 组件销毁&amp;清理</h3><p>当切换页面,或者切换组件的时候,组件就会被销毁,这个时候,往往需要对组件进行一些清理操作,释放一些资源。</p>\n<ul>\n<li><p>componentWillUnmount </p>\n<blockquote>\n<p>这个方法用来在组件销毁前做一些清理,释放占用资源,解除事件绑定等操作。整个生命周期会被执行一次。</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>对于React的生命周期,只要知道在整个生命周期里,有的生命周期函数只调用一次,有的在每次数据更新的时候会被反复调用。如下图:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/react-life-cycle.png\" alt=\"react-life-cycle\"></p>\n<h3 id=\"React-生命周期的三个阶段\"><a href=\"#React-生命周期的三个阶段\" class=\"headerlink\" title=\"React 生命周期的三个阶段\"></a>React 生命周期的三个阶段</h3><h4 id=\"1-组件初始化\"><a href=\"#1-组件初始化\" class=\"headerlink\" title=\"1. 组件初始化\"></a>1. 组件初始化</h4><p>初始化阶段执行的生命周期函数(除了render)在整个生命周期中只会被执行一次。</p>\n<ul>\n<li><p><code>getDefaultProps</code> </p>\n<blockquote>\n<p>设置组件的初始属性,ES6写法和这里的ES5写法有所区别:</p>\n</blockquote>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">static defaultProps = &#123;</div><div class=\"line\">  defaultTxt : &apos;AA&apos;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><code>getInitialState</code></p>\n<blockquote>\n<p>设置组件的初始状态,ES6写法和这里的ES5写法有所区别,是在ES6类的构造器中进行初始化:</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">constructor(props) &#123;</div><div class=\"line\">   super(props);</div><div class=\"line\">   this.state = &#123;</div><div class=\"line\">     state1 : &apos;xxx&apos;</div><div class=\"line\">   &#125;;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p><code>componentWillMount</code></p>\n<blockquote>\n<p>组件即将被挂载前执行的生命周期函数,在这个函数里是组件挂载之前修改组件状态的最后机会。这个函数只会在第一次初始化的时候才会被执行到,后续组件存在期,组件状态的变更将不再被执行。</p>\n</blockquote>\n</li>\n<li><p><code>render</code></p>\n<blockquote>\n<p>将React Elements 渲染进DOM,整个生命周期被执行最多的函数,渲染的时候采用的是最小化增量更新,所以理论上React 会有不错的性能。</p>\n</blockquote>\n</li>\n<li><p><code>componentDidMount</code></p>\n<blockquote>\n<p>React 组件以及成功挂载到DOM中的hooks函数。在这个函数内可以对组件进行DOM操作,在初始化阶段,只有在这个方法内才能够通过<code>this.refs.elementId</code>读取到组件的DOM节点。 </p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"2-组件存在期\"><a href=\"#2-组件存在期\" class=\"headerlink\" title=\"2. 组件存在期\"></a>2. 组件存在期</h3><p>组件的存在期,应该是整个生命周期中最长的一个阶段,也是组件响应用户的行为的一个阶段。</p>\n<ul>\n<li><p><code>componentWillReceiveProps(nextProps)</code></p>\n<blockquote>\n<p>组件在存在期接受的父组件提供的属性发生变化,或者调用了setProps修改组件属性的时候将会被调用,开始一个组件更新的cycle。</p>\n</blockquote>\n</li>\n<li><p><code>shouldComponentUpdate(nextProps,nextState)</code></p>\n<blockquote>\n<p>这个生命周期方法只会在存在期阶段被调用,当组件的属性发生变化(父组件下发的属性改变,setProps被调用),组件的状态发生改变(setState被调用)该方法就会在一个cycle中被执行到且只有当该方法返回true,cycle中后续的函数才有机会被执行,不然后续函数将不会被执行,所以这个函数常常作为React性能优化的地方,省去不必要的渲染更新。</p>\n</blockquote>\n</li>\n<li><p><code>componentWillUpdate(nextProps,nextState)</code></p>\n<blockquote>\n<p>组件更新之前会被执行的函数。</p>\n</blockquote>\n</li>\n<li><p><code>render</code></p>\n<blockquote>\n<p>同初始阶段,但在componentWillUpdate之后componentDidUpdate之前执行。</p>\n</blockquote>\n</li>\n<li><p><code>componentDidUpdate(prevProps,prevState)</code></p>\n<blockquote>\n<p>组件成功更新后的hooks函数。当组件更新完成会被调用。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"3-组件销毁-amp-清理\"><a href=\"#3-组件销毁-amp-清理\" class=\"headerlink\" title=\"3. 组件销毁&amp;清理\"></a>3. 组件销毁&amp;清理</h3><p>当切换页面,或者切换组件的时候,组件就会被销毁,这个时候,往往需要对组件进行一些清理操作,释放一些资源。</p>\n<ul>\n<li><p>componentWillUnmount </p>\n<blockquote>\n<p>这个方法用来在组件销毁前做一些清理,释放占用资源,解除事件绑定等操作。整个生命周期会被执行一次。</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"JavaScript中的正则表达式之正向环视(正向断言)","type":"original","date":"2017-04-26T08:47:21.000Z","description":null,"_content":"\n正则表达式在前端页面中很多地方有被应用到,特别是表单的验证逻辑部分,像验证邮箱,手机号,网址等,以及格式化字符串。比如最近遇到一个需求如下:\n\n```\n输入: 15210790946 \n输出: 152 1079 0946\n对11位的手机号从最后面一位数字开始每4位数字前就需要加一个空格\n```\n要写好一个正则表达式最重要的首先是要清楚的知道组成每一个正则表达式部分的含义,元字符是正则表达式的重要组成部分。\n### 元字符 \n\n|   元字符        | 名称          | 匹配对象  |\n|:--------------  |:-------------:| -----:|\n|  .             |   点号     | 单个任意字符  |\n|  * | 星号 | 之前紧邻的字符出现0+次 | \n| + | 加号 | 之前紧邻的字符出现1+次  |\n| ? | 问号 | 之前紧邻的字符出现0或者1次  |\n| [...]      | 字符组      |   列出的任意一个字符 |\n| \\[^...] | 排除型字符组      |   除列出的字符外任意一个字符  |\n| (...) | 分组符 | 括号内的分为一组 |\n| {n,m} | 匹配次数限制 | 之前紧邻的字符出现至少n次至多m次 |\n| ^ | 脱字符 | 行的起始位置 | \n| $ | 美元符 | 行的末尾位置 | \n| &#124; | 竖线 | 匹配任意分隔的表达式 |\n| \\\\< or \\b | 单词分界符 | 单词左边界 |\n| \\\\> or \\b | 单词分界符 | 单词右边界 | \n| \\1,\\2 | 反向引用 | 分别存放匹配第一组括号,第二组括号文本内容 |\n| (?:...) | 非捕获型分组 | 这个括号中匹配的内容不会被反向引用 |\n|\\w| 缩写 | 等价于[A-Za-z0-9_] |\n| \\W | 缩写 |等价于\\[^A-Za-z0-9_] |\n| \\d | 缩写 |等价于[0-9]| \n| \\D | 缩写 |等价于\\[^0-9]| \n|\\s|缩写|匹配一个空白字符，包括空格、制表符、换页符和换行符。|\n|\\S|缩写|排除\\s |\n|(?=...) | 正向环视 | 匹配前面(右边)是...的位置 |\n|(?<=...) | 逆向环视 | 匹配后面是...的位置 |\n\n### 完成需求 \n\n```\n// 对手机号码参数进行调整,去除手机号码中非数字字符,然后对手机号码应用格式化正则规则\n// (?=(?:\\d{4})+$) 这个部分匹配以整数倍4个数字结尾的位置\n// (\\d) 这里用来匹配一个数字,即只有以整数倍4个数字结尾的位置前面还有一个数字的情况下才需要添加空格。\n// 因JavaScript 不支持逆向环视(逆向断言) 所以不能用replace(/(?<=\\d)(?=(?:\\d{4})+$)/g,' ');\nreturn (num + '').replace(/[^\\d]/g, '').replace(/(\\d)(?=(?:\\d{4})+$)/g,'$1 ');\n```\n","source":"_posts/regular-expression.md","raw":"---\ntitle: JavaScript中的正则表达式之正向环视(正向断言)\ntype: original\ntags: [前端大杂烩]\ncategories: [前端大杂烩]\ndate: 2017-04-26 16:47:21\ndescription:\n---\n\n正则表达式在前端页面中很多地方有被应用到,特别是表单的验证逻辑部分,像验证邮箱,手机号,网址等,以及格式化字符串。比如最近遇到一个需求如下:\n\n```\n输入: 15210790946 \n输出: 152 1079 0946\n对11位的手机号从最后面一位数字开始每4位数字前就需要加一个空格\n```\n要写好一个正则表达式最重要的首先是要清楚的知道组成每一个正则表达式部分的含义,元字符是正则表达式的重要组成部分。\n### 元字符 \n\n|   元字符        | 名称          | 匹配对象  |\n|:--------------  |:-------------:| -----:|\n|  .             |   点号     | 单个任意字符  |\n|  * | 星号 | 之前紧邻的字符出现0+次 | \n| + | 加号 | 之前紧邻的字符出现1+次  |\n| ? | 问号 | 之前紧邻的字符出现0或者1次  |\n| [...]      | 字符组      |   列出的任意一个字符 |\n| \\[^...] | 排除型字符组      |   除列出的字符外任意一个字符  |\n| (...) | 分组符 | 括号内的分为一组 |\n| {n,m} | 匹配次数限制 | 之前紧邻的字符出现至少n次至多m次 |\n| ^ | 脱字符 | 行的起始位置 | \n| $ | 美元符 | 行的末尾位置 | \n| &#124; | 竖线 | 匹配任意分隔的表达式 |\n| \\\\< or \\b | 单词分界符 | 单词左边界 |\n| \\\\> or \\b | 单词分界符 | 单词右边界 | \n| \\1,\\2 | 反向引用 | 分别存放匹配第一组括号,第二组括号文本内容 |\n| (?:...) | 非捕获型分组 | 这个括号中匹配的内容不会被反向引用 |\n|\\w| 缩写 | 等价于[A-Za-z0-9_] |\n| \\W | 缩写 |等价于\\[^A-Za-z0-9_] |\n| \\d | 缩写 |等价于[0-9]| \n| \\D | 缩写 |等价于\\[^0-9]| \n|\\s|缩写|匹配一个空白字符，包括空格、制表符、换页符和换行符。|\n|\\S|缩写|排除\\s |\n|(?=...) | 正向环视 | 匹配前面(右边)是...的位置 |\n|(?<=...) | 逆向环视 | 匹配后面是...的位置 |\n\n### 完成需求 \n\n```\n// 对手机号码参数进行调整,去除手机号码中非数字字符,然后对手机号码应用格式化正则规则\n// (?=(?:\\d{4})+$) 这个部分匹配以整数倍4个数字结尾的位置\n// (\\d) 这里用来匹配一个数字,即只有以整数倍4个数字结尾的位置前面还有一个数字的情况下才需要添加空格。\n// 因JavaScript 不支持逆向环视(逆向断言) 所以不能用replace(/(?<=\\d)(?=(?:\\d{4})+$)/g,' ');\nreturn (num + '').replace(/[^\\d]/g, '').replace(/(\\d)(?=(?:\\d{4})+$)/g,'$1 ');\n```\n","slug":"regular-expression","published":1,"updated":"2017-05-03T05:53:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhqy0012b37qub9ghszh","content":"<p>正则表达式在前端页面中很多地方有被应用到,特别是表单的验证逻辑部分,像验证邮箱,手机号,网址等,以及格式化字符串。比如最近遇到一个需求如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">输入: 15210790946 </div><div class=\"line\">输出: 152 1079 0946</div><div class=\"line\">对11位的手机号从最后面一位数字开始每4位数字前就需要加一个空格</div></pre></td></tr></table></figure>\n<p>要写好一个正则表达式最重要的首先是要清楚的知道组成每一个正则表达式部分的含义,元字符是正则表达式的重要组成部分。</p>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元字符</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:right\">匹配对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">.</td>\n<td style=\"text-align:center\">点号</td>\n<td style=\"text-align:right\">单个任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*</td>\n<td style=\"text-align:center\">星号</td>\n<td style=\"text-align:right\">之前紧邻的字符出现0+次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+</td>\n<td style=\"text-align:center\">加号</td>\n<td style=\"text-align:right\">之前紧邻的字符出现1+次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">?</td>\n<td style=\"text-align:center\">问号</td>\n<td style=\"text-align:right\">之前紧邻的字符出现0或者1次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[…]</td>\n<td style=\"text-align:center\">字符组</td>\n<td style=\"text-align:right\">列出的任意一个字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[^…]</td>\n<td style=\"text-align:center\">排除型字符组</td>\n<td style=\"text-align:right\">除列出的字符外任意一个字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(…)</td>\n<td style=\"text-align:center\">分组符</td>\n<td style=\"text-align:right\">括号内的分为一组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">{n,m}</td>\n<td style=\"text-align:center\">匹配次数限制</td>\n<td style=\"text-align:right\">之前紧邻的字符出现至少n次至多m次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">^</td>\n<td style=\"text-align:center\">脱字符</td>\n<td style=\"text-align:right\">行的起始位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$</td>\n<td style=\"text-align:center\">美元符</td>\n<td style=\"text-align:right\">行的末尾位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&#124;</td>\n<td style=\"text-align:center\">竖线</td>\n<td style=\"text-align:right\">匹配任意分隔的表达式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\&lt; or \\b</td>\n<td style=\"text-align:center\">单词分界符</td>\n<td style=\"text-align:right\">单词左边界</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\&gt; or \\b</td>\n<td style=\"text-align:center\">单词分界符</td>\n<td style=\"text-align:right\">单词右边界</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\1,\\2</td>\n<td style=\"text-align:center\">反向引用</td>\n<td style=\"text-align:right\">分别存放匹配第一组括号,第二组括号文本内容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?:…)</td>\n<td style=\"text-align:center\">非捕获型分组</td>\n<td style=\"text-align:right\">这个括号中匹配的内容不会被反向引用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\w</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">等价于[A-Za-z0-9_]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\W</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">等价于[^A-Za-z0-9_]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\d</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">等价于[0-9]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\D</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">等价于[^0-9]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\s</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">匹配一个空白字符，包括空格、制表符、换页符和换行符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\S</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">排除\\s</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?=…)</td>\n<td style=\"text-align:center\">正向环视</td>\n<td style=\"text-align:right\">匹配前面(右边)是…的位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?&lt;=…)</td>\n<td style=\"text-align:center\">逆向环视</td>\n<td style=\"text-align:right\">匹配后面是…的位置</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"完成需求\"><a href=\"#完成需求\" class=\"headerlink\" title=\"完成需求\"></a>完成需求</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 对手机号码参数进行调整,去除手机号码中非数字字符,然后对手机号码应用格式化正则规则</div><div class=\"line\">// (?=(?:\\d&#123;4&#125;)+$) 这个部分匹配以整数倍4个数字结尾的位置</div><div class=\"line\">// (\\d) 这里用来匹配一个数字,即只有以整数倍4个数字结尾的位置前面还有一个数字的情况下才需要添加空格。</div><div class=\"line\">// 因JavaScript 不支持逆向环视(逆向断言) 所以不能用replace(/(?&lt;=\\d)(?=(?:\\d&#123;4&#125;)+$)/g,&apos; &apos;);</div><div class=\"line\">return (num + &apos;&apos;).replace(/[^\\d]/g, &apos;&apos;).replace(/(\\d)(?=(?:\\d&#123;4&#125;)+$)/g,&apos;$1 &apos;);</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>正则表达式在前端页面中很多地方有被应用到,特别是表单的验证逻辑部分,像验证邮箱,手机号,网址等,以及格式化字符串。比如最近遇到一个需求如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">输入: 15210790946 </div><div class=\"line\">输出: 152 1079 0946</div><div class=\"line\">对11位的手机号从最后面一位数字开始每4位数字前就需要加一个空格</div></pre></td></tr></table></figure>\n<p>要写好一个正则表达式最重要的首先是要清楚的知道组成每一个正则表达式部分的含义,元字符是正则表达式的重要组成部分。</p>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">元字符</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:right\">匹配对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">.</td>\n<td style=\"text-align:center\">点号</td>\n<td style=\"text-align:right\">单个任意字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">*</td>\n<td style=\"text-align:center\">星号</td>\n<td style=\"text-align:right\">之前紧邻的字符出现0+次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">+</td>\n<td style=\"text-align:center\">加号</td>\n<td style=\"text-align:right\">之前紧邻的字符出现1+次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">?</td>\n<td style=\"text-align:center\">问号</td>\n<td style=\"text-align:right\">之前紧邻的字符出现0或者1次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[…]</td>\n<td style=\"text-align:center\">字符组</td>\n<td style=\"text-align:right\">列出的任意一个字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[^…]</td>\n<td style=\"text-align:center\">排除型字符组</td>\n<td style=\"text-align:right\">除列出的字符外任意一个字符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(…)</td>\n<td style=\"text-align:center\">分组符</td>\n<td style=\"text-align:right\">括号内的分为一组</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">{n,m}</td>\n<td style=\"text-align:center\">匹配次数限制</td>\n<td style=\"text-align:right\">之前紧邻的字符出现至少n次至多m次</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">^</td>\n<td style=\"text-align:center\">脱字符</td>\n<td style=\"text-align:right\">行的起始位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">$</td>\n<td style=\"text-align:center\">美元符</td>\n<td style=\"text-align:right\">行的末尾位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">&#124;</td>\n<td style=\"text-align:center\">竖线</td>\n<td style=\"text-align:right\">匹配任意分隔的表达式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\&lt; or \\b</td>\n<td style=\"text-align:center\">单词分界符</td>\n<td style=\"text-align:right\">单词左边界</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\&gt; or \\b</td>\n<td style=\"text-align:center\">单词分界符</td>\n<td style=\"text-align:right\">单词右边界</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\1,\\2</td>\n<td style=\"text-align:center\">反向引用</td>\n<td style=\"text-align:right\">分别存放匹配第一组括号,第二组括号文本内容</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?:…)</td>\n<td style=\"text-align:center\">非捕获型分组</td>\n<td style=\"text-align:right\">这个括号中匹配的内容不会被反向引用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\w</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">等价于[A-Za-z0-9_]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\W</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">等价于[^A-Za-z0-9_]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\d</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">等价于[0-9]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\D</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">等价于[^0-9]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\s</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">匹配一个空白字符，包括空格、制表符、换页符和换行符。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">\\S</td>\n<td style=\"text-align:center\">缩写</td>\n<td style=\"text-align:right\">排除\\s</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?=…)</td>\n<td style=\"text-align:center\">正向环视</td>\n<td style=\"text-align:right\">匹配前面(右边)是…的位置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">(?&lt;=…)</td>\n<td style=\"text-align:center\">逆向环视</td>\n<td style=\"text-align:right\">匹配后面是…的位置</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"完成需求\"><a href=\"#完成需求\" class=\"headerlink\" title=\"完成需求\"></a>完成需求</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 对手机号码参数进行调整,去除手机号码中非数字字符,然后对手机号码应用格式化正则规则</div><div class=\"line\">// (?=(?:\\d&#123;4&#125;)+$) 这个部分匹配以整数倍4个数字结尾的位置</div><div class=\"line\">// (\\d) 这里用来匹配一个数字,即只有以整数倍4个数字结尾的位置前面还有一个数字的情况下才需要添加空格。</div><div class=\"line\">// 因JavaScript 不支持逆向环视(逆向断言) 所以不能用replace(/(?&lt;=\\d)(?=(?:\\d&#123;4&#125;)+$)/g,&apos; &apos;);</div><div class=\"line\">return (num + &apos;&apos;).replace(/[^\\d]/g, &apos;&apos;).replace(/(\\d)(?=(?:\\d&#123;4&#125;)+$)/g,&apos;$1 &apos;);</div></pre></td></tr></table></figure>\n"},{"title":"Redux 简介","type":"original","date":"2017-04-26T08:48:54.000Z","description":null,"_content":"\n　　一个单页应用,最重要的在于应用的数据管理,状态维护,还有页面的路由管理。Redux作为一个JavaScript应用的可预测状态容器,不仅仅给你很爽的编程体验,而且让你写的应用在不同平台上有很好的一致性。\n\n　　到目前为止,在两个项目中用到了Redux,一次是结合react框架,一次是结合网易的regular框架。对于一个比较复杂的系统,在开发之前我们往往会进行组件的划分,从顶层组件到底层的子组件,从容器组件到展示组件。在没有引进Redux之前,我们往往需要自己去维护整个系统的状态的管理,状态的一致性。一般我们会将子组件状态的变更通过emit事件到上层组件,然后再由上层组件emit事件告知顶层根组件,然后顶层根组件接收到事件和数据,变更状态,然后将新的状态数据一层一层的下发下去。如下图:\n\n![没有引入redux之前](http://rainypin.qiniudn.com/git_imgs/no-redux.png)\n\n这样会造成顶层更组件逻辑随着应用系统的逐渐复杂变成越来越庞大,即使对顶层逻辑进行拆分,整个系统的状态State的管理也不会很轻松,且组件直接的通信都需要通过事件的方式告知共同的父组件才能进行,随着系统的复杂度的提高,将会导致代码变得杂乱难以维护和扩展。所以Redux恰到好处的出现,作为整个系统状态State的管家,使得你可以专心的去关注业务逻辑代码,省去了很多状态管理上耗费的精力,使得代码也变得更清晰更容易扩展和维护。引入Redux之后的组件关系图如下:\n\n![引入Redux之后](http://rainypin.qiniudn.com/git_imgs/with-redux.png)\n\n底层组件状态变更或者与其他组件交互的时候不再需要一层一层的往上抛出事件,然后由上层组件去管理了,而是通过Redux,通过dispatch一个action给Redux,然后Redux进行相应的处理,告知顶层组件有部分状态已经发生变化,然后顶层组件告知相应的子组件进行状态变更,渲染页面。这样,你的状态处理的逻辑不再维护在顶层组件里,而且Redux可以很方便的看到action处理前的状态和action处理后的状态,一旦逻辑出现问题,可以很快的进行定位。同时组件的交互不再是杂乱无章的,而是通过Redux,再由顶层组件下发数据变更,使得数据交互变得更单一更清晰。\n\n### 那么Redux内部用了什么黑科技?\n\n　　Redux本身很简单,我们的应用系统的整个状态一般会表示成一个对象,对象中存放了应用系统的各个状态,而Redux就替我们接管了这个对象,管理着这个对象的变更。在Redux中,我们只能通过dispatch action来变更这个State对象,然后Redux会有相应的叫Reducer的函数去处理这个action,这个函数接受两个参数,当前State对象,和action对象,然后进行相应的处理返回新的State。Redux再把State的变更告诉整个应用,此时应用再去进行相应变更的渲染。那么这里提到的action,Reducer是什么? action 和 Reducer又是怎样对应起来的? Redux又是怎么样将整个应用状态数据变更告知应用的?\n\n*  黑科技之action\n \n    Redux的三大原则其中之一就是:唯一改变State的方式是dispatch action。什么是action,action其实就是对发生的事情的一个描述对象。比如一次用户按钮点击,一次ajax请求,请求数据的返回等等这些在Redux中都可以用一个唯一对应的action去描述他们。在这个对象中必须包含一个key为type的字段,值为字符串常量,代表这个action的类型。这是用于后面Reducer处理的时候区分action的关键字段。比如这里的按钮点击,我们的action的type值可以是``XXX_BUTTON_CLICK``。因为是字符串常量,所以这里用大写进行区分。除了type字段之外,你还想在action中添加什么字段完全取决你自己,一般情况下我们有可能会带上需要传给Reducer的数据信息。所以完整的action可能会像下面一样:\n   \n   ```javascript\n      //action 示例\n      {\n          type : \"XXX_BUTTON_CLICK\",\n          payload : {\n             data1 : \"data1\"\n             ...\n          }\n      }\n   ```\n   \n* 黑科技之action creator \n\n   顾名思义,action creator即那些仅仅用来创建并返回action对象的函数。这些函数很简单,只做一件事情,所以很方便测试。如上action,我们就可以有一个action creator来生成并返回上面的``XXX_BUTTON_CLICK`` action,如下:\n   \n   ```javascript\n    function xxxButtonClick() {\n       return {\n           type : 'XXX_BUTTON_CLICK',\n           payload : {\n               \"data1\" : \"data1\",\n                ...\n           }\n       }\n    }\n   ``` \n   \n* 黑科技之Reducer\n\n   前面的action定义并描述了发生的事件,但是并没有指定对应的处理方法,那么这里的Reducer就是用来处理action所描述的事件的函数。该函数接受两个参数,分别是previous state 和 action。然后返回新的state。之所以称为Reducer,主要是因为这个函数的行为和数组原型中的reduce方法很像,``Array.prototype.reduce()``。在应用最开始的时候,Redux在没有初始state的时候,就会给state赋值undefined,为了避免这种情况,所以在Reducer的时候应该设置一个初始化状态。如下:\n   \n   ```javascript\n   function xxxButtonClickReducer(state = initialState,action) {\n       // todo something\n       return newState;   \n    }\n   ```\n   在实践过程中,我们发现整个系统的State会变得比较大,而每一个Reducer需要关注的状态并不是全部的State,可能是其中的某一个状态数据,所以如果每次都将全部State传给只关注部分状态数据的Reducer,就会导致这个Reducer的处理逻辑变得复杂,你不得不在这个Reducer中通过action的type来处理特定的数据,这样就导致``switch case``变得冗长。所以Redux提供了一种拆分Reducer的方式,让某个Reducer只关注他需要关注的状态数据。最后在通过Redux的 combineReducers,将多个拆分的Reducers合成一个rootReducer,这个rootReducer会返回所有全部的state状态数据。代码如下:\n  \n   ```javascript\n      function visibilityFilter(state = 'SHOW_ALL', action) {\n        switch (action.type) {\n          case 'SET_VISIBILITY_FILTER':\n            return action.filter\n          default:\n            return state\n        }\n      }\n      \n      function todos(state = [], action) {\n        switch (action.type) {\n          case 'ADD_TODO':\n            return [\n              ...state,\n              {\n                text: action.text,\n                completed: false\n              }\n            ]\n          case 'COMPLETE_TODO':\n            return state.map((todo, index) => {\n              if (index === action.index) {\n                return Object.assign({}, todo, {\n                  completed: true\n                })\n              }\n              return todo\n            })\n          default:\n            return state\n        }\n      }\n      \n      import { combineReducers, createStore } from 'redux'\n      let reducer = combineReducers({ visibilityFilter, todos })\n      let store = createStore(reducer)\n   ```\n\n    在了解action 和 处理action的Reducer之后,我们来看下Redux是怎么将这两者结合起来的。\n    \n* 黑科技之Store\n \n   Redux的三大原则之一的第一个原则说的就是:单一数据源原则,整个应用的数据状态将被Redux的一个Store维护着。Store主要有以下功能:\n   * 管理着整个应用的状态\n   * 允许我们通过``getState()``来访问整个应用的状态\n   * 允许我们通过``dispatch(action)``来更新应用的状态。\n   * 注册应用状态变更事件监听函数``subscribe(listener)``。\n   * 解绑状态变更事件监听函数,通过使用``subscribe(listener)``的返回值。\n   \n    我们通过调用Redux提供的``createStore``方法来创建一个``store`` 对象,第一个参数为``rootReducer``,第二个参数可以是``initialState``。``store`` 对象提供了几个方法,分别是``dispatch``,``subscribe``,用来让我们能够将 ``action`` 和 ``Reducer`` 关联在一起,将整个 ``store`` 维护的 ``state`` 的变更告知整个系统应用。通过调用``store.dispatch(action)``可以让对应的 ``Reducer`` 进行处理,从而响应action描述的事件,完成应用状态的变更。再通过``store.subscribe(fn)``在fn回调函数中通过``store.getState()``获取到变更后的应用状态``state``,然后从应用的顶层组件下发到底层的子组件更新相应的页面展示。\n\n\n### 更进一步\n\n　　在页面交互过程中存在着两种操作,同步操作和异步操作,对于同步操作页面需要等待完这个操作结束才能继续响应用户,而异步的操作页面可以继续响应用户的操作,待异步结果返回再相应的更新页面状态。那么作为描述这些事件的对象action,也存在同步和'异步',这里的异步指的是通过一个中间件,提供的类似语法糖的功能,可以让你的actionCreator返回的不是action对象而是一个function,在这个function中存在着异步操作,以及针对异步操作的每个阶段所dispatch的action。\n\n　　我们举个栗子,对于ajax请求的操作,我们的页面往往有几种状态的变更,第一,请求发起(这个时候页面会出现loading状态,俗称转菊花),这个时候会有一个action表示开始请求事件。第二,请求成功响应,这个时候页面会获取到服务器返回的数据,更新UI,这个阶段会有一个action,描述请求成功事件,并会将成功的数据带上给Reducer处理更新相应的UI。第三,在没有第二的情况下,请求失败,这个时候的action代表的是请求失败事件,UI往往会弹出失败提示。所以在一次异步过程中,你将会进行三次dispatch。\n\n 　　 面对一次异步操作就需要三次action,让事情变得繁琐,但Redux提供了对应的方法来解决这个问题,让你在需要异步请求的时候,只有触发封装好了三个异步请求的函数,就可以完成以上过程。如下:\n \n ```javascript\n const ImportRecordsActionCreators = {\n     startLoadRecords : () => {\n         return {\n             type : 'START_LOAD_IMPORT_RECORDS'\n         }\n     },\n     onRecordsLoad : (data) => {\n         return {\n             type : 'ON_IMPORT_RECORDS_LOAD',\n             payload : data\n         }\n     },\n     onRecordsFail : (err) => {\n         return {\n             type : 'ON_IMPORT_RECORDS_FAIL',\n             payload : err\n         }\n     },\n     getImportRecords : (params) => {\n         params.id = '601';\n         return function (dispatch) {\n             dispatch(ImportRecordsActionCreators.startLoadRecords());\n             $.ajax({\n                 type: 'post',\n                 url: '/slice/explore',\n                 data: params,\n                 dataType: 'json',\n                 success: (data) => {\n                     dispatch(ImportRecordsActionCreators.onRecordsLoad(data));\n                 },\n                 error: (err) => {\n                     dispatch(ImportRecordsActionCreators.onRecordsFail(err))\n                 }\n             });\n         }\n     }\n };\n \n export default ImportRecordsActionCreators;\n ```\n \n 为了使得store能够处理function形式的action,在创建store的过程中需要传入``redux-thunk``提供的中间件``thunkMiddleware``,对于中间件,我们后面会讲到。先来看下代码:\n \n ```javascript\n import thunkMiddleware from 'redux-thunk'\n import { createStore, applyMiddleware } from 'redux'\n import rootReducer from './reducers'\n \n const store = createStore(\n   rootReducer,\n   applyMiddleware(\n     thunkMiddleware, // lets us dispatch() functions\n   )\n )\n ```\n \n 这样你的store就具备了dispatch异步action(函数)的能力。这样我们只要调用``dispatch(ImportRecordsActionCreators.getImportRecords)``就可以一次触发过程中所涉及到的action了。\n \n \n ### 中间件\n \n　　中间件这个词对大家来说并不陌生,一般都是在输入和输出中间进行处理的那层插件,对于Express 和 Koa 用户来说,中间件就是请求之后和响应之前中间处理层,比如添加CORS headers, 日志记录, 压缩等。而对于Redux中间件来说,主要是一些第三方扩展,用在dispatch action之后和action 到达具体的Reducer进行处理之前的那层,用于日志记录,崩溃报告,处理异步action,路由等。Redux中间件的代码结构我们一redux-thunk为例子,代码如下:\n  \n  ```javascript\n  //redux-thunk代码\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n  ```\n \n \nRedux中间件的写法可以参考这个插件,通过一个函数创建返回如下形式的函数:\n\n```javascript\n({dispatch, getState}) => next => action => {\n    //里面为这个中间件的处理逻辑\n    //处理完后不要忘记将action交由下一个中间件处理\n    //此时需要调用next(action)\n    next(action);\n}\n```\n\n### Reducer 处理逻辑拆分新思路\n\n　　根据之前Reducer的介绍,如果系统应用的状态变得复杂,数据层次嵌套多的时候,必然需要我们去拆分Reducer的处理逻辑,让多个Reducer处理不同的,自己关心的状态数据,最后通过combineReducer进行整合。但是这也会突出新的问题,嵌套层数多的State就需要嵌套的combineReducer,可以参看[深入到源码：解读 redux 的设计思路与用法](http://div.io/topic/1309)这篇文章提出的针对复杂State的三种解决方案。这里我们提出一种新的方式,使得Reducer的逻辑能得以拆分。\n\n　　在这种方案下我们会按业务拆分Reducer,相同业务的Reducers被拆分到一个单独的文件里,通过Map的形式代替switch case语句来组织相同业务的Reducers,其中Map的key为对应Reducer所要处理的action中的type,Map的值为对应的Reducer函数。然后我们会在一个名为``reducer.js``的文件中导入所有的Reducers,导出一个rootReducer用于创建store。如下:\n\n* import-records-reducers.js\n\n  ```javascript\n  import {message} from 'antd';\n  const immutable = require(\"object-path-immutable\");\n  \n  export default {\n      'START_IMPORT_RECORDS' : (state) => {\n          return immutable(state).set('xxx.loading',true).value();\n      },\n      'ON_IMPORT_RECORDS_LOAD' : (state,payload) => {\n          let immOp = immutable(state).set('xxx.loading',false);\n          if(payload) {\n             // todo something\n          }\n          return immOp.value();\n      },\n      'ON_IMPORT_RECORDS_FAIL' : (state,payload) => {\n          return immutable(state).set('xxx.loading',false).value();\n      }\n  }\n  ```\n  \n* reducer.js\n\n  ```javascript\n   import r1 from 'reducers/import-records-reducer';\n   \n   //初始State状态\n   const initialState = {\n       \n   }\n   \n   //合并所有reducer Map\n   const reducerMap = $.extend({}, r1/*, r2, r3, r4, r5, r6,r7,r8*/);\n   \n   //导出rootReducer\n   export default function (state = initialState, action) {\n       if (reducerMap[action.type]) {\n           return reducerMap[action.type](state, typeof action.payload === 'undefined' ? null : action.payload);\n       } else {\n           return state\n       }\n   } \n  ```\n\n这样我们的action也就可以根据业务进行划分到不同的文件里,这样使得代码更加便于维护和扩展。\n\n### 最后\n\nRedux固然好,但是我们需要根据我们自身项目的实际情况,从需要解决什么问题出发,去考虑是不是一定需要引入Redux,以及引入Redux利弊之间的权衡,以到达发挥工具所应有的作用。\n\n\n### 参考资料\n\n[Redux 官方文档](http://redux.js.org/docs/introduction/)","source":"_posts/redux-introduction.md","raw":"---\ntitle: Redux 简介\ntype: original\ntags: [前端大杂烩]\ncategories: [前端大杂烩]\ndate: 2017-04-26 16:48:54\ndescription:\n---\n\n　　一个单页应用,最重要的在于应用的数据管理,状态维护,还有页面的路由管理。Redux作为一个JavaScript应用的可预测状态容器,不仅仅给你很爽的编程体验,而且让你写的应用在不同平台上有很好的一致性。\n\n　　到目前为止,在两个项目中用到了Redux,一次是结合react框架,一次是结合网易的regular框架。对于一个比较复杂的系统,在开发之前我们往往会进行组件的划分,从顶层组件到底层的子组件,从容器组件到展示组件。在没有引进Redux之前,我们往往需要自己去维护整个系统的状态的管理,状态的一致性。一般我们会将子组件状态的变更通过emit事件到上层组件,然后再由上层组件emit事件告知顶层根组件,然后顶层根组件接收到事件和数据,变更状态,然后将新的状态数据一层一层的下发下去。如下图:\n\n![没有引入redux之前](http://rainypin.qiniudn.com/git_imgs/no-redux.png)\n\n这样会造成顶层更组件逻辑随着应用系统的逐渐复杂变成越来越庞大,即使对顶层逻辑进行拆分,整个系统的状态State的管理也不会很轻松,且组件直接的通信都需要通过事件的方式告知共同的父组件才能进行,随着系统的复杂度的提高,将会导致代码变得杂乱难以维护和扩展。所以Redux恰到好处的出现,作为整个系统状态State的管家,使得你可以专心的去关注业务逻辑代码,省去了很多状态管理上耗费的精力,使得代码也变得更清晰更容易扩展和维护。引入Redux之后的组件关系图如下:\n\n![引入Redux之后](http://rainypin.qiniudn.com/git_imgs/with-redux.png)\n\n底层组件状态变更或者与其他组件交互的时候不再需要一层一层的往上抛出事件,然后由上层组件去管理了,而是通过Redux,通过dispatch一个action给Redux,然后Redux进行相应的处理,告知顶层组件有部分状态已经发生变化,然后顶层组件告知相应的子组件进行状态变更,渲染页面。这样,你的状态处理的逻辑不再维护在顶层组件里,而且Redux可以很方便的看到action处理前的状态和action处理后的状态,一旦逻辑出现问题,可以很快的进行定位。同时组件的交互不再是杂乱无章的,而是通过Redux,再由顶层组件下发数据变更,使得数据交互变得更单一更清晰。\n\n### 那么Redux内部用了什么黑科技?\n\n　　Redux本身很简单,我们的应用系统的整个状态一般会表示成一个对象,对象中存放了应用系统的各个状态,而Redux就替我们接管了这个对象,管理着这个对象的变更。在Redux中,我们只能通过dispatch action来变更这个State对象,然后Redux会有相应的叫Reducer的函数去处理这个action,这个函数接受两个参数,当前State对象,和action对象,然后进行相应的处理返回新的State。Redux再把State的变更告诉整个应用,此时应用再去进行相应变更的渲染。那么这里提到的action,Reducer是什么? action 和 Reducer又是怎样对应起来的? Redux又是怎么样将整个应用状态数据变更告知应用的?\n\n*  黑科技之action\n \n    Redux的三大原则其中之一就是:唯一改变State的方式是dispatch action。什么是action,action其实就是对发生的事情的一个描述对象。比如一次用户按钮点击,一次ajax请求,请求数据的返回等等这些在Redux中都可以用一个唯一对应的action去描述他们。在这个对象中必须包含一个key为type的字段,值为字符串常量,代表这个action的类型。这是用于后面Reducer处理的时候区分action的关键字段。比如这里的按钮点击,我们的action的type值可以是``XXX_BUTTON_CLICK``。因为是字符串常量,所以这里用大写进行区分。除了type字段之外,你还想在action中添加什么字段完全取决你自己,一般情况下我们有可能会带上需要传给Reducer的数据信息。所以完整的action可能会像下面一样:\n   \n   ```javascript\n      //action 示例\n      {\n          type : \"XXX_BUTTON_CLICK\",\n          payload : {\n             data1 : \"data1\"\n             ...\n          }\n      }\n   ```\n   \n* 黑科技之action creator \n\n   顾名思义,action creator即那些仅仅用来创建并返回action对象的函数。这些函数很简单,只做一件事情,所以很方便测试。如上action,我们就可以有一个action creator来生成并返回上面的``XXX_BUTTON_CLICK`` action,如下:\n   \n   ```javascript\n    function xxxButtonClick() {\n       return {\n           type : 'XXX_BUTTON_CLICK',\n           payload : {\n               \"data1\" : \"data1\",\n                ...\n           }\n       }\n    }\n   ``` \n   \n* 黑科技之Reducer\n\n   前面的action定义并描述了发生的事件,但是并没有指定对应的处理方法,那么这里的Reducer就是用来处理action所描述的事件的函数。该函数接受两个参数,分别是previous state 和 action。然后返回新的state。之所以称为Reducer,主要是因为这个函数的行为和数组原型中的reduce方法很像,``Array.prototype.reduce()``。在应用最开始的时候,Redux在没有初始state的时候,就会给state赋值undefined,为了避免这种情况,所以在Reducer的时候应该设置一个初始化状态。如下:\n   \n   ```javascript\n   function xxxButtonClickReducer(state = initialState,action) {\n       // todo something\n       return newState;   \n    }\n   ```\n   在实践过程中,我们发现整个系统的State会变得比较大,而每一个Reducer需要关注的状态并不是全部的State,可能是其中的某一个状态数据,所以如果每次都将全部State传给只关注部分状态数据的Reducer,就会导致这个Reducer的处理逻辑变得复杂,你不得不在这个Reducer中通过action的type来处理特定的数据,这样就导致``switch case``变得冗长。所以Redux提供了一种拆分Reducer的方式,让某个Reducer只关注他需要关注的状态数据。最后在通过Redux的 combineReducers,将多个拆分的Reducers合成一个rootReducer,这个rootReducer会返回所有全部的state状态数据。代码如下:\n  \n   ```javascript\n      function visibilityFilter(state = 'SHOW_ALL', action) {\n        switch (action.type) {\n          case 'SET_VISIBILITY_FILTER':\n            return action.filter\n          default:\n            return state\n        }\n      }\n      \n      function todos(state = [], action) {\n        switch (action.type) {\n          case 'ADD_TODO':\n            return [\n              ...state,\n              {\n                text: action.text,\n                completed: false\n              }\n            ]\n          case 'COMPLETE_TODO':\n            return state.map((todo, index) => {\n              if (index === action.index) {\n                return Object.assign({}, todo, {\n                  completed: true\n                })\n              }\n              return todo\n            })\n          default:\n            return state\n        }\n      }\n      \n      import { combineReducers, createStore } from 'redux'\n      let reducer = combineReducers({ visibilityFilter, todos })\n      let store = createStore(reducer)\n   ```\n\n    在了解action 和 处理action的Reducer之后,我们来看下Redux是怎么将这两者结合起来的。\n    \n* 黑科技之Store\n \n   Redux的三大原则之一的第一个原则说的就是:单一数据源原则,整个应用的数据状态将被Redux的一个Store维护着。Store主要有以下功能:\n   * 管理着整个应用的状态\n   * 允许我们通过``getState()``来访问整个应用的状态\n   * 允许我们通过``dispatch(action)``来更新应用的状态。\n   * 注册应用状态变更事件监听函数``subscribe(listener)``。\n   * 解绑状态变更事件监听函数,通过使用``subscribe(listener)``的返回值。\n   \n    我们通过调用Redux提供的``createStore``方法来创建一个``store`` 对象,第一个参数为``rootReducer``,第二个参数可以是``initialState``。``store`` 对象提供了几个方法,分别是``dispatch``,``subscribe``,用来让我们能够将 ``action`` 和 ``Reducer`` 关联在一起,将整个 ``store`` 维护的 ``state`` 的变更告知整个系统应用。通过调用``store.dispatch(action)``可以让对应的 ``Reducer`` 进行处理,从而响应action描述的事件,完成应用状态的变更。再通过``store.subscribe(fn)``在fn回调函数中通过``store.getState()``获取到变更后的应用状态``state``,然后从应用的顶层组件下发到底层的子组件更新相应的页面展示。\n\n\n### 更进一步\n\n　　在页面交互过程中存在着两种操作,同步操作和异步操作,对于同步操作页面需要等待完这个操作结束才能继续响应用户,而异步的操作页面可以继续响应用户的操作,待异步结果返回再相应的更新页面状态。那么作为描述这些事件的对象action,也存在同步和'异步',这里的异步指的是通过一个中间件,提供的类似语法糖的功能,可以让你的actionCreator返回的不是action对象而是一个function,在这个function中存在着异步操作,以及针对异步操作的每个阶段所dispatch的action。\n\n　　我们举个栗子,对于ajax请求的操作,我们的页面往往有几种状态的变更,第一,请求发起(这个时候页面会出现loading状态,俗称转菊花),这个时候会有一个action表示开始请求事件。第二,请求成功响应,这个时候页面会获取到服务器返回的数据,更新UI,这个阶段会有一个action,描述请求成功事件,并会将成功的数据带上给Reducer处理更新相应的UI。第三,在没有第二的情况下,请求失败,这个时候的action代表的是请求失败事件,UI往往会弹出失败提示。所以在一次异步过程中,你将会进行三次dispatch。\n\n 　　 面对一次异步操作就需要三次action,让事情变得繁琐,但Redux提供了对应的方法来解决这个问题,让你在需要异步请求的时候,只有触发封装好了三个异步请求的函数,就可以完成以上过程。如下:\n \n ```javascript\n const ImportRecordsActionCreators = {\n     startLoadRecords : () => {\n         return {\n             type : 'START_LOAD_IMPORT_RECORDS'\n         }\n     },\n     onRecordsLoad : (data) => {\n         return {\n             type : 'ON_IMPORT_RECORDS_LOAD',\n             payload : data\n         }\n     },\n     onRecordsFail : (err) => {\n         return {\n             type : 'ON_IMPORT_RECORDS_FAIL',\n             payload : err\n         }\n     },\n     getImportRecords : (params) => {\n         params.id = '601';\n         return function (dispatch) {\n             dispatch(ImportRecordsActionCreators.startLoadRecords());\n             $.ajax({\n                 type: 'post',\n                 url: '/slice/explore',\n                 data: params,\n                 dataType: 'json',\n                 success: (data) => {\n                     dispatch(ImportRecordsActionCreators.onRecordsLoad(data));\n                 },\n                 error: (err) => {\n                     dispatch(ImportRecordsActionCreators.onRecordsFail(err))\n                 }\n             });\n         }\n     }\n };\n \n export default ImportRecordsActionCreators;\n ```\n \n 为了使得store能够处理function形式的action,在创建store的过程中需要传入``redux-thunk``提供的中间件``thunkMiddleware``,对于中间件,我们后面会讲到。先来看下代码:\n \n ```javascript\n import thunkMiddleware from 'redux-thunk'\n import { createStore, applyMiddleware } from 'redux'\n import rootReducer from './reducers'\n \n const store = createStore(\n   rootReducer,\n   applyMiddleware(\n     thunkMiddleware, // lets us dispatch() functions\n   )\n )\n ```\n \n 这样你的store就具备了dispatch异步action(函数)的能力。这样我们只要调用``dispatch(ImportRecordsActionCreators.getImportRecords)``就可以一次触发过程中所涉及到的action了。\n \n \n ### 中间件\n \n　　中间件这个词对大家来说并不陌生,一般都是在输入和输出中间进行处理的那层插件,对于Express 和 Koa 用户来说,中间件就是请求之后和响应之前中间处理层,比如添加CORS headers, 日志记录, 压缩等。而对于Redux中间件来说,主要是一些第三方扩展,用在dispatch action之后和action 到达具体的Reducer进行处理之前的那层,用于日志记录,崩溃报告,处理异步action,路由等。Redux中间件的代码结构我们一redux-thunk为例子,代码如下:\n  \n  ```javascript\n  //redux-thunk代码\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => next => action => {\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n  ```\n \n \nRedux中间件的写法可以参考这个插件,通过一个函数创建返回如下形式的函数:\n\n```javascript\n({dispatch, getState}) => next => action => {\n    //里面为这个中间件的处理逻辑\n    //处理完后不要忘记将action交由下一个中间件处理\n    //此时需要调用next(action)\n    next(action);\n}\n```\n\n### Reducer 处理逻辑拆分新思路\n\n　　根据之前Reducer的介绍,如果系统应用的状态变得复杂,数据层次嵌套多的时候,必然需要我们去拆分Reducer的处理逻辑,让多个Reducer处理不同的,自己关心的状态数据,最后通过combineReducer进行整合。但是这也会突出新的问题,嵌套层数多的State就需要嵌套的combineReducer,可以参看[深入到源码：解读 redux 的设计思路与用法](http://div.io/topic/1309)这篇文章提出的针对复杂State的三种解决方案。这里我们提出一种新的方式,使得Reducer的逻辑能得以拆分。\n\n　　在这种方案下我们会按业务拆分Reducer,相同业务的Reducers被拆分到一个单独的文件里,通过Map的形式代替switch case语句来组织相同业务的Reducers,其中Map的key为对应Reducer所要处理的action中的type,Map的值为对应的Reducer函数。然后我们会在一个名为``reducer.js``的文件中导入所有的Reducers,导出一个rootReducer用于创建store。如下:\n\n* import-records-reducers.js\n\n  ```javascript\n  import {message} from 'antd';\n  const immutable = require(\"object-path-immutable\");\n  \n  export default {\n      'START_IMPORT_RECORDS' : (state) => {\n          return immutable(state).set('xxx.loading',true).value();\n      },\n      'ON_IMPORT_RECORDS_LOAD' : (state,payload) => {\n          let immOp = immutable(state).set('xxx.loading',false);\n          if(payload) {\n             // todo something\n          }\n          return immOp.value();\n      },\n      'ON_IMPORT_RECORDS_FAIL' : (state,payload) => {\n          return immutable(state).set('xxx.loading',false).value();\n      }\n  }\n  ```\n  \n* reducer.js\n\n  ```javascript\n   import r1 from 'reducers/import-records-reducer';\n   \n   //初始State状态\n   const initialState = {\n       \n   }\n   \n   //合并所有reducer Map\n   const reducerMap = $.extend({}, r1/*, r2, r3, r4, r5, r6,r7,r8*/);\n   \n   //导出rootReducer\n   export default function (state = initialState, action) {\n       if (reducerMap[action.type]) {\n           return reducerMap[action.type](state, typeof action.payload === 'undefined' ? null : action.payload);\n       } else {\n           return state\n       }\n   } \n  ```\n\n这样我们的action也就可以根据业务进行划分到不同的文件里,这样使得代码更加便于维护和扩展。\n\n### 最后\n\nRedux固然好,但是我们需要根据我们自身项目的实际情况,从需要解决什么问题出发,去考虑是不是一定需要引入Redux,以及引入Redux利弊之间的权衡,以到达发挥工具所应有的作用。\n\n\n### 参考资料\n\n[Redux 官方文档](http://redux.js.org/docs/introduction/)","slug":"redux-introduction","published":1,"updated":"2017-05-03T05:53:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhr30015b37qr9kelrw8","content":"<p>　　一个单页应用,最重要的在于应用的数据管理,状态维护,还有页面的路由管理。Redux作为一个JavaScript应用的可预测状态容器,不仅仅给你很爽的编程体验,而且让你写的应用在不同平台上有很好的一致性。</p>\n<p>　　到目前为止,在两个项目中用到了Redux,一次是结合react框架,一次是结合网易的regular框架。对于一个比较复杂的系统,在开发之前我们往往会进行组件的划分,从顶层组件到底层的子组件,从容器组件到展示组件。在没有引进Redux之前,我们往往需要自己去维护整个系统的状态的管理,状态的一致性。一般我们会将子组件状态的变更通过emit事件到上层组件,然后再由上层组件emit事件告知顶层根组件,然后顶层根组件接收到事件和数据,变更状态,然后将新的状态数据一层一层的下发下去。如下图:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/no-redux.png\" alt=\"没有引入redux之前\"></p>\n<p>这样会造成顶层更组件逻辑随着应用系统的逐渐复杂变成越来越庞大,即使对顶层逻辑进行拆分,整个系统的状态State的管理也不会很轻松,且组件直接的通信都需要通过事件的方式告知共同的父组件才能进行,随着系统的复杂度的提高,将会导致代码变得杂乱难以维护和扩展。所以Redux恰到好处的出现,作为整个系统状态State的管家,使得你可以专心的去关注业务逻辑代码,省去了很多状态管理上耗费的精力,使得代码也变得更清晰更容易扩展和维护。引入Redux之后的组件关系图如下:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/with-redux.png\" alt=\"引入Redux之后\"></p>\n<p>底层组件状态变更或者与其他组件交互的时候不再需要一层一层的往上抛出事件,然后由上层组件去管理了,而是通过Redux,通过dispatch一个action给Redux,然后Redux进行相应的处理,告知顶层组件有部分状态已经发生变化,然后顶层组件告知相应的子组件进行状态变更,渲染页面。这样,你的状态处理的逻辑不再维护在顶层组件里,而且Redux可以很方便的看到action处理前的状态和action处理后的状态,一旦逻辑出现问题,可以很快的进行定位。同时组件的交互不再是杂乱无章的,而是通过Redux,再由顶层组件下发数据变更,使得数据交互变得更单一更清晰。</p>\n<h3 id=\"那么Redux内部用了什么黑科技\"><a href=\"#那么Redux内部用了什么黑科技\" class=\"headerlink\" title=\"那么Redux内部用了什么黑科技?\"></a>那么Redux内部用了什么黑科技?</h3><p>　　Redux本身很简单,我们的应用系统的整个状态一般会表示成一个对象,对象中存放了应用系统的各个状态,而Redux就替我们接管了这个对象,管理着这个对象的变更。在Redux中,我们只能通过dispatch action来变更这个State对象,然后Redux会有相应的叫Reducer的函数去处理这个action,这个函数接受两个参数,当前State对象,和action对象,然后进行相应的处理返回新的State。Redux再把State的变更告诉整个应用,此时应用再去进行相应变更的渲染。那么这里提到的action,Reducer是什么? action 和 Reducer又是怎样对应起来的? Redux又是怎么样将整个应用状态数据变更告知应用的?</p>\n<ul>\n<li><p>黑科技之action</p>\n<p> Redux的三大原则其中之一就是:唯一改变State的方式是dispatch action。什么是action,action其实就是对发生的事情的一个描述对象。比如一次用户按钮点击,一次ajax请求,请求数据的返回等等这些在Redux中都可以用一个唯一对应的action去描述他们。在这个对象中必须包含一个key为type的字段,值为字符串常量,代表这个action的类型。这是用于后面Reducer处理的时候区分action的关键字段。比如这里的按钮点击,我们的action的type值可以是<code>XXX_BUTTON_CLICK</code>。因为是字符串常量,所以这里用大写进行区分。除了type字段之外,你还想在action中添加什么字段完全取决你自己,一般情况下我们有可能会带上需要传给Reducer的数据信息。所以完整的action可能会像下面一样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//action 示例</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">type</span> : <span class=\"string\">\"XXX_BUTTON_CLICK\"</span>,</div><div class=\"line\">    <span class=\"attr\">payload</span> : &#123;</div><div class=\"line\">       <span class=\"attr\">data1</span> : <span class=\"string\">\"data1\"</span></div><div class=\"line\">       ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>黑科技之action creator </p>\n<p> 顾名思义,action creator即那些仅仅用来创建并返回action对象的函数。这些函数很简单,只做一件事情,所以很方便测试。如上action,我们就可以有一个action creator来生成并返回上面的<code>XXX_BUTTON_CLICK</code> action,如下:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">xxxButtonClick</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">           <span class=\"attr\">type</span> : <span class=\"string\">'XXX_BUTTON_CLICK'</span>,</div><div class=\"line\">           <span class=\"attr\">payload</span> : &#123;</div><div class=\"line\">               <span class=\"string\">\"data1\"</span> : <span class=\"string\">\"data1\"</span>,</div><div class=\"line\">                ...</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">   <span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\">   </div><div class=\"line\">* 黑科技之Reducer</div><div class=\"line\"></div><div class=\"line\">   前面的action定义并描述了发生的事件,但是并没有指定对应的处理方法,那么这里的Reducer就是用来处理action所描述的事件的函数。该函数接受两个参数,分别是previous state 和 action。然后返回新的state。之所以称为Reducer,主要是因为这个函数的行为和数组原型中的reduce方法很像,`<span class=\"string\">`Array.prototype.reduce()`</span><span class=\"string\">`。在应用最开始的时候,Redux在没有初始state的时候,就会给state赋值undefined,为了避免这种情况,所以在Reducer的时候应该设置一个初始化状态。如下:</span></div><div class=\"line\">   </div><div class=\"line\">   `<span class=\"string\">``</span>javascript</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">xxxButtonClickReducer</span>(<span class=\"params\">state = initialState,action</span>) </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// todo something</span></div><div class=\"line\">       <span class=\"keyword\">return</span> newState;   </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p> 在实践过程中,我们发现整个系统的State会变得比较大,而每一个Reducer需要关注的状态并不是全部的State,可能是其中的某一个状态数据,所以如果每次都将全部State传给只关注部分状态数据的Reducer,就会导致这个Reducer的处理逻辑变得复杂,你不得不在这个Reducer中通过action的type来处理特定的数据,这样就导致<code>switch case</code>变得冗长。所以Redux提供了一种拆分Reducer的方式,让某个Reducer只关注他需要关注的状态数据。最后在通过Redux的 combineReducers,将多个拆分的Reducers合成一个rootReducer,这个rootReducer会返回所有全部的state状态数据。代码如下:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">visibilityFilter</span>(<span class=\"params\">state = <span class=\"string\">'SHOW_ALL'</span>, action</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'SET_VISIBILITY_FILTER'</span>:</div><div class=\"line\">      <span class=\"keyword\">return</span> action.filter</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">      <span class=\"keyword\">return</span> state</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todos</span>(<span class=\"params\">state = [], action</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</div><div class=\"line\">      <span class=\"keyword\">return</span> [</div><div class=\"line\">        ...state,</div><div class=\"line\">        &#123;</div><div class=\"line\">          <span class=\"attr\">text</span>: action.text,</div><div class=\"line\">          <span class=\"attr\">completed</span>: <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      ]</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'COMPLETE_TODO'</span>:</div><div class=\"line\">      <span class=\"keyword\">return</span> state.map(<span class=\"function\">(<span class=\"params\">todo, index</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (index === action.index) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, todo, &#123;</div><div class=\"line\">            <span class=\"attr\">completed</span>: <span class=\"literal\">true</span></div><div class=\"line\">          &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> todo</div><div class=\"line\">      &#125;)</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">      <span class=\"keyword\">return</span> state</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers, createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></div><div class=\"line\"><span class=\"keyword\">let</span> reducer = combineReducers(&#123; visibilityFilter, todos &#125;)</div><div class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducer)</div></pre></td></tr></table></figure>\n<p>  在了解action 和 处理action的Reducer之后,我们来看下Redux是怎么将这两者结合起来的。</p>\n</li>\n<li><p>黑科技之Store</p>\n<p> Redux的三大原则之一的第一个原则说的就是:单一数据源原则,整个应用的数据状态将被Redux的一个Store维护着。Store主要有以下功能:</p>\n<ul>\n<li>管理着整个应用的状态</li>\n<li>允许我们通过<code>getState()</code>来访问整个应用的状态</li>\n<li>允许我们通过<code>dispatch(action)</code>来更新应用的状态。</li>\n<li>注册应用状态变更事件监听函数<code>subscribe(listener)</code>。</li>\n<li><p>解绑状态变更事件监听函数,通过使用<code>subscribe(listener)</code>的返回值。</p>\n<p>我们通过调用Redux提供的<code>createStore</code>方法来创建一个<code>store</code> 对象,第一个参数为<code>rootReducer</code>,第二个参数可以是<code>initialState</code>。<code>store</code> 对象提供了几个方法,分别是<code>dispatch</code>,<code>subscribe</code>,用来让我们能够将 <code>action</code> 和 <code>Reducer</code> 关联在一起,将整个 <code>store</code> 维护的 <code>state</code> 的变更告知整个系统应用。通过调用<code>store.dispatch(action)</code>可以让对应的 <code>Reducer</code> 进行处理,从而响应action描述的事件,完成应用状态的变更。再通过<code>store.subscribe(fn)</code>在fn回调函数中通过<code>store.getState()</code>获取到变更后的应用状态<code>state</code>,然后从应用的顶层组件下发到底层的子组件更新相应的页面展示。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"更进一步\"><a href=\"#更进一步\" class=\"headerlink\" title=\"更进一步\"></a>更进一步</h3><p>　　在页面交互过程中存在着两种操作,同步操作和异步操作,对于同步操作页面需要等待完这个操作结束才能继续响应用户,而异步的操作页面可以继续响应用户的操作,待异步结果返回再相应的更新页面状态。那么作为描述这些事件的对象action,也存在同步和’异步’,这里的异步指的是通过一个中间件,提供的类似语法糖的功能,可以让你的actionCreator返回的不是action对象而是一个function,在这个function中存在着异步操作,以及针对异步操作的每个阶段所dispatch的action。</p>\n<p>　　我们举个栗子,对于ajax请求的操作,我们的页面往往有几种状态的变更,第一,请求发起(这个时候页面会出现loading状态,俗称转菊花),这个时候会有一个action表示开始请求事件。第二,请求成功响应,这个时候页面会获取到服务器返回的数据,更新UI,这个阶段会有一个action,描述请求成功事件,并会将成功的数据带上给Reducer处理更新相应的UI。第三,在没有第二的情况下,请求失败,这个时候的action代表的是请求失败事件,UI往往会弹出失败提示。所以在一次异步过程中,你将会进行三次dispatch。</p>\n<p> 　　 面对一次异步操作就需要三次action,让事情变得繁琐,但Redux提供了对应的方法来解决这个问题,让你在需要异步请求的时候,只有触发封装好了三个异步请求的函数,就可以完成以上过程。如下:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> ImportRecordsActionCreators = &#123;</div><div class=\"line\">    <span class=\"attr\">startLoadRecords</span> : <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            <span class=\"attr\">type</span> : <span class=\"string\">'START_LOAD_IMPORT_RECORDS'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">onRecordsLoad</span> : <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            <span class=\"attr\">type</span> : <span class=\"string\">'ON_IMPORT_RECORDS_LOAD'</span>,</div><div class=\"line\">            <span class=\"attr\">payload</span> : data</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">onRecordsFail</span> : <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            <span class=\"attr\">type</span> : <span class=\"string\">'ON_IMPORT_RECORDS_FAIL'</span>,</div><div class=\"line\">            <span class=\"attr\">payload</span> : err</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">getImportRecords</span> : <span class=\"function\">(<span class=\"params\">params</span>) =&gt;</span> &#123;</div><div class=\"line\">        params.id = <span class=\"string\">'601'</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">dispatch</span>) </span>&#123;</div><div class=\"line\">            dispatch(ImportRecordsActionCreators.startLoadRecords());</div><div class=\"line\">            $.ajax(&#123;</div><div class=\"line\">                <span class=\"attr\">type</span>: <span class=\"string\">'post'</span>,</div><div class=\"line\">                <span class=\"attr\">url</span>: <span class=\"string\">'/slice/explore'</span>,</div><div class=\"line\">                <span class=\"attr\">data</span>: params,</div><div class=\"line\">                <span class=\"attr\">dataType</span>: <span class=\"string\">'json'</span>,</div><div class=\"line\">                <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                    dispatch(ImportRecordsActionCreators.onRecordsLoad(data));</div><div class=\"line\">                &#125;,</div><div class=\"line\">                <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</div><div class=\"line\">                    dispatch(ImportRecordsActionCreators.onRecordsFail(err))</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ImportRecordsActionCreators;</div></pre></td></tr></table></figure>\n<p> 为了使得store能够处理function形式的action,在创建store的过程中需要传入<code>redux-thunk</code>提供的中间件<code>thunkMiddleware</code>,对于中间件,我们后面会讲到。先来看下代码:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> thunkMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></div><div class=\"line\"><span class=\"keyword\">import</span> rootReducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> store = createStore(</div><div class=\"line\">  rootReducer,</div><div class=\"line\">  applyMiddleware(</div><div class=\"line\">    thunkMiddleware, <span class=\"comment\">// lets us dispatch() functions</span></div><div class=\"line\">  )</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p> 这样你的store就具备了dispatch异步action(函数)的能力。这样我们只要调用<code>dispatch(ImportRecordsActionCreators.getImportRecords)</code>就可以一次触发过程中所涉及到的action了。</p>\n<h3 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h3><p>　　中间件这个词对大家来说并不陌生,一般都是在输入和输出中间进行处理的那层插件,对于Express 和 Koa 用户来说,中间件就是请求之后和响应之前中间处理层,比如添加CORS headers, 日志记录, 压缩等。而对于Redux中间件来说,主要是一些第三方扩展,用在dispatch action之后和action 到达具体的Reducer进行处理之前的那层,用于日志记录,崩溃报告,处理异步action,路由等。Redux中间件的代码结构我们一redux-thunk为例子,代码如下:</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"comment\">//redux-thunk代码</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createThunkMiddleware</span>(<span class=\"params\">extraArgument</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">&#123; dispatch, getState &#125;</span>) =&gt;</span> next =&gt; <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> action(dispatch, getState, extraArgument);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> next(action);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> thunk = createThunkMiddleware();</div><div class=\"line\">thunk.withExtraArgument = createThunkMiddleware;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> thunk;</div></pre></td></tr></table></figure>\n<p>Redux中间件的写法可以参考这个插件,通过一个函数创建返回如下形式的函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(&#123;dispatch, getState&#125;) =&gt; <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> action =&gt; &#123;</div><div class=\"line\">    <span class=\"comment\">//里面为这个中间件的处理逻辑</span></div><div class=\"line\">    <span class=\"comment\">//处理完后不要忘记将action交由下一个中间件处理</span></div><div class=\"line\">    <span class=\"comment\">//此时需要调用next(action)</span></div><div class=\"line\">    next(action);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Reducer-处理逻辑拆分新思路\"><a href=\"#Reducer-处理逻辑拆分新思路\" class=\"headerlink\" title=\"Reducer 处理逻辑拆分新思路\"></a>Reducer 处理逻辑拆分新思路</h3><p>　　根据之前Reducer的介绍,如果系统应用的状态变得复杂,数据层次嵌套多的时候,必然需要我们去拆分Reducer的处理逻辑,让多个Reducer处理不同的,自己关心的状态数据,最后通过combineReducer进行整合。但是这也会突出新的问题,嵌套层数多的State就需要嵌套的combineReducer,可以参看<a href=\"http://div.io/topic/1309\" target=\"_blank\" rel=\"external\">深入到源码：解读 redux 的设计思路与用法</a>这篇文章提出的针对复杂State的三种解决方案。这里我们提出一种新的方式,使得Reducer的逻辑能得以拆分。</p>\n<p>　　在这种方案下我们会按业务拆分Reducer,相同业务的Reducers被拆分到一个单独的文件里,通过Map的形式代替switch case语句来组织相同业务的Reducers,其中Map的key为对应Reducer所要处理的action中的type,Map的值为对应的Reducer函数。然后我们会在一个名为<code>reducer.js</code>的文件中导入所有的Reducers,导出一个rootReducer用于创建store。如下:</p>\n<ul>\n<li><p>import-records-reducers.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;message&#125; <span class=\"keyword\">from</span> <span class=\"string\">'antd'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> immutable = <span class=\"built_in\">require</span>(<span class=\"string\">\"object-path-immutable\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    <span class=\"string\">'START_IMPORT_RECORDS'</span> : <span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> immutable(state).set(<span class=\"string\">'xxx.loading'</span>,<span class=\"literal\">true</span>).value();</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'ON_IMPORT_RECORDS_LOAD'</span> : <span class=\"function\">(<span class=\"params\">state,payload</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> immOp = immutable(state).set(<span class=\"string\">'xxx.loading'</span>,<span class=\"literal\">false</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span>(payload) &#123;</div><div class=\"line\">           <span class=\"comment\">// todo something</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> immOp.value();</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'ON_IMPORT_RECORDS_FAIL'</span> : <span class=\"function\">(<span class=\"params\">state,payload</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> immutable(state).set(<span class=\"string\">'xxx.loading'</span>,<span class=\"literal\">false</span>).value();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>reducer.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> r1 <span class=\"keyword\">from</span> <span class=\"string\">'reducers/import-records-reducer'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//初始State状态</span></div><div class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//合并所有reducer Map</span></div><div class=\"line\"><span class=\"keyword\">const</span> reducerMap = $.extend(&#123;&#125;, r1<span class=\"comment\">/*, r2, r3, r4, r5, r6,r7,r8*/</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//导出rootReducer</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">state = initialState, action</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (reducerMap[action.type]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> reducerMap[action.type](state, <span class=\"keyword\">typeof</span> action.payload === <span class=\"string\">'undefined'</span> ? <span class=\"literal\">null</span> : action.payload);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> state</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样我们的action也就可以根据业务进行划分到不同的文件里,这样使得代码更加便于维护和扩展。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>Redux固然好,但是我们需要根据我们自身项目的实际情况,从需要解决什么问题出发,去考虑是不是一定需要引入Redux,以及引入Redux利弊之间的权衡,以到达发挥工具所应有的作用。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://redux.js.org/docs/introduction/\" target=\"_blank\" rel=\"external\">Redux 官方文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>　　一个单页应用,最重要的在于应用的数据管理,状态维护,还有页面的路由管理。Redux作为一个JavaScript应用的可预测状态容器,不仅仅给你很爽的编程体验,而且让你写的应用在不同平台上有很好的一致性。</p>\n<p>　　到目前为止,在两个项目中用到了Redux,一次是结合react框架,一次是结合网易的regular框架。对于一个比较复杂的系统,在开发之前我们往往会进行组件的划分,从顶层组件到底层的子组件,从容器组件到展示组件。在没有引进Redux之前,我们往往需要自己去维护整个系统的状态的管理,状态的一致性。一般我们会将子组件状态的变更通过emit事件到上层组件,然后再由上层组件emit事件告知顶层根组件,然后顶层根组件接收到事件和数据,变更状态,然后将新的状态数据一层一层的下发下去。如下图:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/no-redux.png\" alt=\"没有引入redux之前\"></p>\n<p>这样会造成顶层更组件逻辑随着应用系统的逐渐复杂变成越来越庞大,即使对顶层逻辑进行拆分,整个系统的状态State的管理也不会很轻松,且组件直接的通信都需要通过事件的方式告知共同的父组件才能进行,随着系统的复杂度的提高,将会导致代码变得杂乱难以维护和扩展。所以Redux恰到好处的出现,作为整个系统状态State的管家,使得你可以专心的去关注业务逻辑代码,省去了很多状态管理上耗费的精力,使得代码也变得更清晰更容易扩展和维护。引入Redux之后的组件关系图如下:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/with-redux.png\" alt=\"引入Redux之后\"></p>\n<p>底层组件状态变更或者与其他组件交互的时候不再需要一层一层的往上抛出事件,然后由上层组件去管理了,而是通过Redux,通过dispatch一个action给Redux,然后Redux进行相应的处理,告知顶层组件有部分状态已经发生变化,然后顶层组件告知相应的子组件进行状态变更,渲染页面。这样,你的状态处理的逻辑不再维护在顶层组件里,而且Redux可以很方便的看到action处理前的状态和action处理后的状态,一旦逻辑出现问题,可以很快的进行定位。同时组件的交互不再是杂乱无章的,而是通过Redux,再由顶层组件下发数据变更,使得数据交互变得更单一更清晰。</p>\n<h3 id=\"那么Redux内部用了什么黑科技\"><a href=\"#那么Redux内部用了什么黑科技\" class=\"headerlink\" title=\"那么Redux内部用了什么黑科技?\"></a>那么Redux内部用了什么黑科技?</h3><p>　　Redux本身很简单,我们的应用系统的整个状态一般会表示成一个对象,对象中存放了应用系统的各个状态,而Redux就替我们接管了这个对象,管理着这个对象的变更。在Redux中,我们只能通过dispatch action来变更这个State对象,然后Redux会有相应的叫Reducer的函数去处理这个action,这个函数接受两个参数,当前State对象,和action对象,然后进行相应的处理返回新的State。Redux再把State的变更告诉整个应用,此时应用再去进行相应变更的渲染。那么这里提到的action,Reducer是什么? action 和 Reducer又是怎样对应起来的? Redux又是怎么样将整个应用状态数据变更告知应用的?</p>\n<ul>\n<li><p>黑科技之action</p>\n<p> Redux的三大原则其中之一就是:唯一改变State的方式是dispatch action。什么是action,action其实就是对发生的事情的一个描述对象。比如一次用户按钮点击,一次ajax请求,请求数据的返回等等这些在Redux中都可以用一个唯一对应的action去描述他们。在这个对象中必须包含一个key为type的字段,值为字符串常量,代表这个action的类型。这是用于后面Reducer处理的时候区分action的关键字段。比如这里的按钮点击,我们的action的type值可以是<code>XXX_BUTTON_CLICK</code>。因为是字符串常量,所以这里用大写进行区分。除了type字段之外,你还想在action中添加什么字段完全取决你自己,一般情况下我们有可能会带上需要传给Reducer的数据信息。所以完整的action可能会像下面一样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//action 示例</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">type</span> : <span class=\"string\">\"XXX_BUTTON_CLICK\"</span>,</div><div class=\"line\">    <span class=\"attr\">payload</span> : &#123;</div><div class=\"line\">       <span class=\"attr\">data1</span> : <span class=\"string\">\"data1\"</span></div><div class=\"line\">       ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>黑科技之action creator </p>\n<p> 顾名思义,action creator即那些仅仅用来创建并返回action对象的函数。这些函数很简单,只做一件事情,所以很方便测试。如上action,我们就可以有一个action creator来生成并返回上面的<code>XXX_BUTTON_CLICK</code> action,如下:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">xxxButtonClick</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">           <span class=\"attr\">type</span> : <span class=\"string\">'XXX_BUTTON_CLICK'</span>,</div><div class=\"line\">           <span class=\"attr\">payload</span> : &#123;</div><div class=\"line\">               <span class=\"string\">\"data1\"</span> : <span class=\"string\">\"data1\"</span>,</div><div class=\"line\">                ...</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">   <span class=\"string\">``</span><span class=\"string\">` </span></div><div class=\"line\">   </div><div class=\"line\">* 黑科技之Reducer</div><div class=\"line\"></div><div class=\"line\">   前面的action定义并描述了发生的事件,但是并没有指定对应的处理方法,那么这里的Reducer就是用来处理action所描述的事件的函数。该函数接受两个参数,分别是previous state 和 action。然后返回新的state。之所以称为Reducer,主要是因为这个函数的行为和数组原型中的reduce方法很像,`<span class=\"string\">`Array.prototype.reduce()`</span><span class=\"string\">`。在应用最开始的时候,Redux在没有初始state的时候,就会给state赋值undefined,为了避免这种情况,所以在Reducer的时候应该设置一个初始化状态。如下:</span></div><div class=\"line\">   </div><div class=\"line\">   `<span class=\"string\">``</span>javascript</div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">xxxButtonClickReducer</span>(<span class=\"params\">state = initialState,action</span>) </span>&#123;</div><div class=\"line\">       <span class=\"comment\">// todo something</span></div><div class=\"line\">       <span class=\"keyword\">return</span> newState;   </div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p> 在实践过程中,我们发现整个系统的State会变得比较大,而每一个Reducer需要关注的状态并不是全部的State,可能是其中的某一个状态数据,所以如果每次都将全部State传给只关注部分状态数据的Reducer,就会导致这个Reducer的处理逻辑变得复杂,你不得不在这个Reducer中通过action的type来处理特定的数据,这样就导致<code>switch case</code>变得冗长。所以Redux提供了一种拆分Reducer的方式,让某个Reducer只关注他需要关注的状态数据。最后在通过Redux的 combineReducers,将多个拆分的Reducers合成一个rootReducer,这个rootReducer会返回所有全部的state状态数据。代码如下:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">visibilityFilter</span>(<span class=\"params\">state = <span class=\"string\">'SHOW_ALL'</span>, action</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'SET_VISIBILITY_FILTER'</span>:</div><div class=\"line\">      <span class=\"keyword\">return</span> action.filter</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">      <span class=\"keyword\">return</span> state</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todos</span>(<span class=\"params\">state = [], action</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</div><div class=\"line\">      <span class=\"keyword\">return</span> [</div><div class=\"line\">        ...state,</div><div class=\"line\">        &#123;</div><div class=\"line\">          <span class=\"attr\">text</span>: action.text,</div><div class=\"line\">          <span class=\"attr\">completed</span>: <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">      ]</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'COMPLETE_TODO'</span>:</div><div class=\"line\">      <span class=\"keyword\">return</span> state.map(<span class=\"function\">(<span class=\"params\">todo, index</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (index === action.index) &#123;</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, todo, &#123;</div><div class=\"line\">            <span class=\"attr\">completed</span>: <span class=\"literal\">true</span></div><div class=\"line\">          &#125;)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> todo</div><div class=\"line\">      &#125;)</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">      <span class=\"keyword\">return</span> state</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers, createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></div><div class=\"line\"><span class=\"keyword\">let</span> reducer = combineReducers(&#123; visibilityFilter, todos &#125;)</div><div class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducer)</div></pre></td></tr></table></figure>\n<p>  在了解action 和 处理action的Reducer之后,我们来看下Redux是怎么将这两者结合起来的。</p>\n</li>\n<li><p>黑科技之Store</p>\n<p> Redux的三大原则之一的第一个原则说的就是:单一数据源原则,整个应用的数据状态将被Redux的一个Store维护着。Store主要有以下功能:</p>\n<ul>\n<li>管理着整个应用的状态</li>\n<li>允许我们通过<code>getState()</code>来访问整个应用的状态</li>\n<li>允许我们通过<code>dispatch(action)</code>来更新应用的状态。</li>\n<li>注册应用状态变更事件监听函数<code>subscribe(listener)</code>。</li>\n<li><p>解绑状态变更事件监听函数,通过使用<code>subscribe(listener)</code>的返回值。</p>\n<p>我们通过调用Redux提供的<code>createStore</code>方法来创建一个<code>store</code> 对象,第一个参数为<code>rootReducer</code>,第二个参数可以是<code>initialState</code>。<code>store</code> 对象提供了几个方法,分别是<code>dispatch</code>,<code>subscribe</code>,用来让我们能够将 <code>action</code> 和 <code>Reducer</code> 关联在一起,将整个 <code>store</code> 维护的 <code>state</code> 的变更告知整个系统应用。通过调用<code>store.dispatch(action)</code>可以让对应的 <code>Reducer</code> 进行处理,从而响应action描述的事件,完成应用状态的变更。再通过<code>store.subscribe(fn)</code>在fn回调函数中通过<code>store.getState()</code>获取到变更后的应用状态<code>state</code>,然后从应用的顶层组件下发到底层的子组件更新相应的页面展示。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"更进一步\"><a href=\"#更进一步\" class=\"headerlink\" title=\"更进一步\"></a>更进一步</h3><p>　　在页面交互过程中存在着两种操作,同步操作和异步操作,对于同步操作页面需要等待完这个操作结束才能继续响应用户,而异步的操作页面可以继续响应用户的操作,待异步结果返回再相应的更新页面状态。那么作为描述这些事件的对象action,也存在同步和’异步’,这里的异步指的是通过一个中间件,提供的类似语法糖的功能,可以让你的actionCreator返回的不是action对象而是一个function,在这个function中存在着异步操作,以及针对异步操作的每个阶段所dispatch的action。</p>\n<p>　　我们举个栗子,对于ajax请求的操作,我们的页面往往有几种状态的变更,第一,请求发起(这个时候页面会出现loading状态,俗称转菊花),这个时候会有一个action表示开始请求事件。第二,请求成功响应,这个时候页面会获取到服务器返回的数据,更新UI,这个阶段会有一个action,描述请求成功事件,并会将成功的数据带上给Reducer处理更新相应的UI。第三,在没有第二的情况下,请求失败,这个时候的action代表的是请求失败事件,UI往往会弹出失败提示。所以在一次异步过程中,你将会进行三次dispatch。</p>\n<p> 　　 面对一次异步操作就需要三次action,让事情变得繁琐,但Redux提供了对应的方法来解决这个问题,让你在需要异步请求的时候,只有触发封装好了三个异步请求的函数,就可以完成以上过程。如下:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> ImportRecordsActionCreators = &#123;</div><div class=\"line\">    <span class=\"attr\">startLoadRecords</span> : <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            <span class=\"attr\">type</span> : <span class=\"string\">'START_LOAD_IMPORT_RECORDS'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">onRecordsLoad</span> : <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            <span class=\"attr\">type</span> : <span class=\"string\">'ON_IMPORT_RECORDS_LOAD'</span>,</div><div class=\"line\">            <span class=\"attr\">payload</span> : data</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">onRecordsFail</span> : <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">            <span class=\"attr\">type</span> : <span class=\"string\">'ON_IMPORT_RECORDS_FAIL'</span>,</div><div class=\"line\">            <span class=\"attr\">payload</span> : err</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">getImportRecords</span> : <span class=\"function\">(<span class=\"params\">params</span>) =&gt;</span> &#123;</div><div class=\"line\">        params.id = <span class=\"string\">'601'</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">dispatch</span>) </span>&#123;</div><div class=\"line\">            dispatch(ImportRecordsActionCreators.startLoadRecords());</div><div class=\"line\">            $.ajax(&#123;</div><div class=\"line\">                <span class=\"attr\">type</span>: <span class=\"string\">'post'</span>,</div><div class=\"line\">                <span class=\"attr\">url</span>: <span class=\"string\">'/slice/explore'</span>,</div><div class=\"line\">                <span class=\"attr\">data</span>: params,</div><div class=\"line\">                <span class=\"attr\">dataType</span>: <span class=\"string\">'json'</span>,</div><div class=\"line\">                <span class=\"attr\">success</span>: <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</div><div class=\"line\">                    dispatch(ImportRecordsActionCreators.onRecordsLoad(data));</div><div class=\"line\">                &#125;,</div><div class=\"line\">                <span class=\"attr\">error</span>: <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</div><div class=\"line\">                    dispatch(ImportRecordsActionCreators.onRecordsFail(err))</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> ImportRecordsActionCreators;</div></pre></td></tr></table></figure>\n<p> 为了使得store能够处理function形式的action,在创建store的过程中需要传入<code>redux-thunk</code>提供的中间件<code>thunkMiddleware</code>,对于中间件,我们后面会讲到。先来看下代码:</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> thunkMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span></div><div class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></div><div class=\"line\"><span class=\"keyword\">import</span> rootReducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> store = createStore(</div><div class=\"line\">  rootReducer,</div><div class=\"line\">  applyMiddleware(</div><div class=\"line\">    thunkMiddleware, <span class=\"comment\">// lets us dispatch() functions</span></div><div class=\"line\">  )</div><div class=\"line\">)</div></pre></td></tr></table></figure>\n<p> 这样你的store就具备了dispatch异步action(函数)的能力。这样我们只要调用<code>dispatch(ImportRecordsActionCreators.getImportRecords)</code>就可以一次触发过程中所涉及到的action了。</p>\n<h3 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h3><p>　　中间件这个词对大家来说并不陌生,一般都是在输入和输出中间进行处理的那层插件,对于Express 和 Koa 用户来说,中间件就是请求之后和响应之前中间处理层,比如添加CORS headers, 日志记录, 压缩等。而对于Redux中间件来说,主要是一些第三方扩展,用在dispatch action之后和action 到达具体的Reducer进行处理之前的那层,用于日志记录,崩溃报告,处理异步action,路由等。Redux中间件的代码结构我们一redux-thunk为例子,代码如下:</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"comment\">//redux-thunk代码</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createThunkMiddleware</span>(<span class=\"params\">extraArgument</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">&#123; dispatch, getState &#125;</span>) =&gt;</span> next =&gt; <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action === <span class=\"string\">'function'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> action(dispatch, getState, extraArgument);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> next(action);</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> thunk = createThunkMiddleware();</div><div class=\"line\">thunk.withExtraArgument = createThunkMiddleware;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> thunk;</div></pre></td></tr></table></figure>\n<p>Redux中间件的写法可以参考这个插件,通过一个函数创建返回如下形式的函数:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">(&#123;dispatch, getState&#125;) =&gt; <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> action =&gt; &#123;</div><div class=\"line\">    <span class=\"comment\">//里面为这个中间件的处理逻辑</span></div><div class=\"line\">    <span class=\"comment\">//处理完后不要忘记将action交由下一个中间件处理</span></div><div class=\"line\">    <span class=\"comment\">//此时需要调用next(action)</span></div><div class=\"line\">    next(action);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Reducer-处理逻辑拆分新思路\"><a href=\"#Reducer-处理逻辑拆分新思路\" class=\"headerlink\" title=\"Reducer 处理逻辑拆分新思路\"></a>Reducer 处理逻辑拆分新思路</h3><p>　　根据之前Reducer的介绍,如果系统应用的状态变得复杂,数据层次嵌套多的时候,必然需要我们去拆分Reducer的处理逻辑,让多个Reducer处理不同的,自己关心的状态数据,最后通过combineReducer进行整合。但是这也会突出新的问题,嵌套层数多的State就需要嵌套的combineReducer,可以参看<a href=\"http://div.io/topic/1309\" target=\"_blank\" rel=\"external\">深入到源码：解读 redux 的设计思路与用法</a>这篇文章提出的针对复杂State的三种解决方案。这里我们提出一种新的方式,使得Reducer的逻辑能得以拆分。</p>\n<p>　　在这种方案下我们会按业务拆分Reducer,相同业务的Reducers被拆分到一个单独的文件里,通过Map的形式代替switch case语句来组织相同业务的Reducers,其中Map的key为对应Reducer所要处理的action中的type,Map的值为对应的Reducer函数。然后我们会在一个名为<code>reducer.js</code>的文件中导入所有的Reducers,导出一个rootReducer用于创建store。如下:</p>\n<ul>\n<li><p>import-records-reducers.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> &#123;message&#125; <span class=\"keyword\">from</span> <span class=\"string\">'antd'</span>;</div><div class=\"line\"><span class=\"keyword\">const</span> immutable = <span class=\"built_in\">require</span>(<span class=\"string\">\"object-path-immutable\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</div><div class=\"line\">    <span class=\"string\">'START_IMPORT_RECORDS'</span> : <span class=\"function\">(<span class=\"params\">state</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> immutable(state).set(<span class=\"string\">'xxx.loading'</span>,<span class=\"literal\">true</span>).value();</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'ON_IMPORT_RECORDS_LOAD'</span> : <span class=\"function\">(<span class=\"params\">state,payload</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> immOp = immutable(state).set(<span class=\"string\">'xxx.loading'</span>,<span class=\"literal\">false</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span>(payload) &#123;</div><div class=\"line\">           <span class=\"comment\">// todo something</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> immOp.value();</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">'ON_IMPORT_RECORDS_FAIL'</span> : <span class=\"function\">(<span class=\"params\">state,payload</span>) =&gt;</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> immutable(state).set(<span class=\"string\">'xxx.loading'</span>,<span class=\"literal\">false</span>).value();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>reducer.js</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> r1 <span class=\"keyword\">from</span> <span class=\"string\">'reducers/import-records-reducer'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//初始State状态</span></div><div class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//合并所有reducer Map</span></div><div class=\"line\"><span class=\"keyword\">const</span> reducerMap = $.extend(&#123;&#125;, r1<span class=\"comment\">/*, r2, r3, r4, r5, r6,r7,r8*/</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//导出rootReducer</span></div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">state = initialState, action</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (reducerMap[action.type]) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> reducerMap[action.type](state, <span class=\"keyword\">typeof</span> action.payload === <span class=\"string\">'undefined'</span> ? <span class=\"literal\">null</span> : action.payload);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> state</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样我们的action也就可以根据业务进行划分到不同的文件里,这样使得代码更加便于维护和扩展。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>Redux固然好,但是我们需要根据我们自身项目的实际情况,从需要解决什么问题出发,去考虑是不是一定需要引入Redux,以及引入Redux利弊之间的权衡,以到达发挥工具所应有的作用。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"http://redux.js.org/docs/introduction/\" target=\"_blank\" rel=\"external\">Redux 官方文档</a></p>\n"},{"title":"Mac上搭建RN开发环境","type":"original","date":"2017-04-26T07:40:54.000Z","description":"在针对特定平台开发环境建立之前,你需要先安装node,watchman,react-native-cli。在Mac上我们可以通过HomeBrew进行相应的安装。","_content":"\n## 安装依赖 \n在针对特定平台开发环境建立之前,你需要先安装``node``,``watchman``,``react-native-cli``。在Mac上我们可以通过[HomeBrew](https://brew.sh/)进行相应的安装。\n> brew install node \n> brew install watchman \n> brew install flow \n> npm install -g react-native-cli\n\n### ios 开发环境搭建\n对于ios 只需要从app store中安装xcode即可,安装xcode会自动安装ios 模拟器以及一些构建app所需要的工具。通过react-native 命令初始化一个项目然后测试ios开发环境是否成功建立。\n\n> react-native init AwesomeProject \n> cd AwesomeProject\n\n在ios模拟器中启动应用,两种方式:\n1. 通过命令行直接唤起模拟器打开app\n\n    >  react-native run-ios\n    \n    执行完该命令,正常情况下,会打开ios模拟器,然后启动应用以供调试。\n\n2. 进入目录``AwesomeProject``,打开``ios``目录下的文件``AwesomeProject.xcodeproj``,如果xcode成功安装,默认会打开xcode。然后直接\n![xcode-run](http://rainypin.qiniudn.com/git_imgs/xcode-run.png)\n\n### android 开发环境搭建 \n\n对于android开发环境要稍微复杂一些。\n\n1. 安装安卓模拟器[genymotion](https://www.genymotion.com/download/)\n   > 安装完成后需要去官网注册一个账户并激活,后续创建虚拟设备将会用到。\n2. 安装[virtual box](http://rj.baidu.com/soft/detail/25850.html?ald)\n\n3. 安装最新版JDK\n\n4. 安装安卓Android Studio \n* 打开sdk manager 安装的Android sdk\n  \n  ![android studio](http://rainypin.qiniudn.com/git_imgs/android-studio.png)\n  \n* 选择需要安装的内容\n\n  ![android sdk](http://rainypin.qiniudn.com/git_imgs/android-sdk.png)\n  \n5. 打开genymotion 创建安卓模拟器\n\n    * 先设置好正确的android sdk路径 \n    \n        ![settings](http://rainypin.qiniudn.com/git_imgs/settings.png)\n    \n    * 添加相应的虚拟设备\n    \n        ![virtual-device](http://rainypin.qiniudn.com/git_imgs/virtual-device.png)\n    \n6. 打开对应的虚拟设备测试安卓开发环境是否成功建立\n\n    打开对于的虚拟设备后,在项目根目录执行命令启动应用:\n    > react-native run-android \n    \n    这一步可能发送报错``java.io.EOFException: SSL peer shut down incorrectly``,解决方案在后面。\n    \n    这个时候如果build successfully 则在模拟器上可以看到对于app的页面,如果模拟器上出现如下报错:\n    ![dev-settings](http://rainypin.qiniudn.com/git_imgs/dev-settings.png)\n    \n    需要设置对应的debug host为当前电脑的ip地址,如下图:\n    \n    ![debug-host](http://rainypin.qiniudn.com/git_imgs/debug-host.png)\n    \n \n## 环境配置过程报错解决\n \n * 对于安卓开发环境步骤6中运行``react-native run-android``所报错误解决方法\n    > 下载gradle-2.4-all.zip到本地\n      本地启动对于的服务\n      修改 android/gradle/wrapper 下 gradle-wrapper.properties 文件中的 distributionUrl 为本地地址,重新执行 react-native run-android \n      \n## 参考资料\n\n1. [React Native Android（Genymotion） 环境搭建 for mac](http://www.jianshu.com/p/38cb29cdb77d)\n2. [学习 React Native for Android：环境搭建](http://hahack.com/codes/learn-react-native-for-android-01/)\n3. [Getting Started with Building An App with React Native, Genymotion, and Watchman](http://amiraanuar.com/step-by-step-guide-to-building-an-android-app-using-react-native-and-genymotion/)\n4. [react native getting started](https://facebook.github.io/react-native/releases/next/docs/getting-started.html)\n5. [react-native run-android 报错解决](http://bbs.reactnative.cn/topic/310/react-native-run-android-%E6%8A%A5%E9%94%99-java-io-eofexception-ssl-peer-shut-down-incorrectly)\n6. [React Native For Android初体验](http://www.jianshu.com/p/847a54e0c385)","source":"_posts/rn-dev-prepare.md","raw":"---\ntitle: Mac上搭建RN开发环境\ntype: original\ntags: ['React Native']\ncategories: ['React Native']\ndate: 2017-04-26 15:40:54\ndescription: 在针对特定平台开发环境建立之前,你需要先安装node,watchman,react-native-cli。在Mac上我们可以通过HomeBrew进行相应的安装。\n---\n\n## 安装依赖 \n在针对特定平台开发环境建立之前,你需要先安装``node``,``watchman``,``react-native-cli``。在Mac上我们可以通过[HomeBrew](https://brew.sh/)进行相应的安装。\n> brew install node \n> brew install watchman \n> brew install flow \n> npm install -g react-native-cli\n\n### ios 开发环境搭建\n对于ios 只需要从app store中安装xcode即可,安装xcode会自动安装ios 模拟器以及一些构建app所需要的工具。通过react-native 命令初始化一个项目然后测试ios开发环境是否成功建立。\n\n> react-native init AwesomeProject \n> cd AwesomeProject\n\n在ios模拟器中启动应用,两种方式:\n1. 通过命令行直接唤起模拟器打开app\n\n    >  react-native run-ios\n    \n    执行完该命令,正常情况下,会打开ios模拟器,然后启动应用以供调试。\n\n2. 进入目录``AwesomeProject``,打开``ios``目录下的文件``AwesomeProject.xcodeproj``,如果xcode成功安装,默认会打开xcode。然后直接\n![xcode-run](http://rainypin.qiniudn.com/git_imgs/xcode-run.png)\n\n### android 开发环境搭建 \n\n对于android开发环境要稍微复杂一些。\n\n1. 安装安卓模拟器[genymotion](https://www.genymotion.com/download/)\n   > 安装完成后需要去官网注册一个账户并激活,后续创建虚拟设备将会用到。\n2. 安装[virtual box](http://rj.baidu.com/soft/detail/25850.html?ald)\n\n3. 安装最新版JDK\n\n4. 安装安卓Android Studio \n* 打开sdk manager 安装的Android sdk\n  \n  ![android studio](http://rainypin.qiniudn.com/git_imgs/android-studio.png)\n  \n* 选择需要安装的内容\n\n  ![android sdk](http://rainypin.qiniudn.com/git_imgs/android-sdk.png)\n  \n5. 打开genymotion 创建安卓模拟器\n\n    * 先设置好正确的android sdk路径 \n    \n        ![settings](http://rainypin.qiniudn.com/git_imgs/settings.png)\n    \n    * 添加相应的虚拟设备\n    \n        ![virtual-device](http://rainypin.qiniudn.com/git_imgs/virtual-device.png)\n    \n6. 打开对应的虚拟设备测试安卓开发环境是否成功建立\n\n    打开对于的虚拟设备后,在项目根目录执行命令启动应用:\n    > react-native run-android \n    \n    这一步可能发送报错``java.io.EOFException: SSL peer shut down incorrectly``,解决方案在后面。\n    \n    这个时候如果build successfully 则在模拟器上可以看到对于app的页面,如果模拟器上出现如下报错:\n    ![dev-settings](http://rainypin.qiniudn.com/git_imgs/dev-settings.png)\n    \n    需要设置对应的debug host为当前电脑的ip地址,如下图:\n    \n    ![debug-host](http://rainypin.qiniudn.com/git_imgs/debug-host.png)\n    \n \n## 环境配置过程报错解决\n \n * 对于安卓开发环境步骤6中运行``react-native run-android``所报错误解决方法\n    > 下载gradle-2.4-all.zip到本地\n      本地启动对于的服务\n      修改 android/gradle/wrapper 下 gradle-wrapper.properties 文件中的 distributionUrl 为本地地址,重新执行 react-native run-android \n      \n## 参考资料\n\n1. [React Native Android（Genymotion） 环境搭建 for mac](http://www.jianshu.com/p/38cb29cdb77d)\n2. [学习 React Native for Android：环境搭建](http://hahack.com/codes/learn-react-native-for-android-01/)\n3. [Getting Started with Building An App with React Native, Genymotion, and Watchman](http://amiraanuar.com/step-by-step-guide-to-building-an-android-app-using-react-native-and-genymotion/)\n4. [react native getting started](https://facebook.github.io/react-native/releases/next/docs/getting-started.html)\n5. [react-native run-android 报错解决](http://bbs.reactnative.cn/topic/310/react-native-run-android-%E6%8A%A5%E9%94%99-java-io-eofexception-ssl-peer-shut-down-incorrectly)\n6. [React Native For Android初体验](http://www.jianshu.com/p/847a54e0c385)","slug":"rn-dev-prepare","published":1,"updated":"2017-05-03T05:53:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhr70019b37qlyzvg69e","content":"<h2 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h2><p>在针对特定平台开发环境建立之前,你需要先安装<code>node</code>,<code>watchman</code>,<code>react-native-cli</code>。在Mac上我们可以通过<a href=\"https://brew.sh/\" target=\"_blank\" rel=\"external\">HomeBrew</a>进行相应的安装。</p>\n<blockquote>\n<p>brew install node<br>brew install watchman<br>brew install flow<br>npm install -g react-native-cli</p>\n</blockquote>\n<h3 id=\"ios-开发环境搭建\"><a href=\"#ios-开发环境搭建\" class=\"headerlink\" title=\"ios 开发环境搭建\"></a>ios 开发环境搭建</h3><p>对于ios 只需要从app store中安装xcode即可,安装xcode会自动安装ios 模拟器以及一些构建app所需要的工具。通过react-native 命令初始化一个项目然后测试ios开发环境是否成功建立。</p>\n<blockquote>\n<p>react-native init AwesomeProject<br>cd AwesomeProject</p>\n</blockquote>\n<p>在ios模拟器中启动应用,两种方式:</p>\n<ol>\n<li><p>通过命令行直接唤起模拟器打开app</p>\n<blockquote>\n<p> react-native run-ios</p>\n</blockquote>\n<p> 执行完该命令,正常情况下,会打开ios模拟器,然后启动应用以供调试。</p>\n</li>\n<li><p>进入目录<code>AwesomeProject</code>,打开<code>ios</code>目录下的文件<code>AwesomeProject.xcodeproj</code>,如果xcode成功安装,默认会打开xcode。然后直接<br><img src=\"http://rainypin.qiniudn.com/git_imgs/xcode-run.png\" alt=\"xcode-run\"></p>\n</li>\n</ol>\n<h3 id=\"android-开发环境搭建\"><a href=\"#android-开发环境搭建\" class=\"headerlink\" title=\"android 开发环境搭建\"></a>android 开发环境搭建</h3><p>对于android开发环境要稍微复杂一些。</p>\n<ol>\n<li>安装安卓模拟器<a href=\"https://www.genymotion.com/download/\" target=\"_blank\" rel=\"external\">genymotion</a><blockquote>\n<p>安装完成后需要去官网注册一个账户并激活,后续创建虚拟设备将会用到。</p>\n</blockquote>\n</li>\n<li><p>安装<a href=\"http://rj.baidu.com/soft/detail/25850.html?ald\" target=\"_blank\" rel=\"external\">virtual box</a></p>\n</li>\n<li><p>安装最新版JDK</p>\n</li>\n<li><p>安装安卓Android Studio </p>\n</li>\n</ol>\n<ul>\n<li><p>打开sdk manager 安装的Android sdk</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/android-studio.png\" alt=\"android studio\"></p>\n</li>\n<li><p>选择需要安装的内容</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/android-sdk.png\" alt=\"android sdk\"></p>\n</li>\n</ul>\n<ol>\n<li><p>打开genymotion 创建安卓模拟器</p>\n<ul>\n<li><p>先设置好正确的android sdk路径 </p>\n<p>  <img src=\"http://rainypin.qiniudn.com/git_imgs/settings.png\" alt=\"settings\"></p>\n</li>\n<li><p>添加相应的虚拟设备</p>\n<p>  <img src=\"http://rainypin.qiniudn.com/git_imgs/virtual-device.png\" alt=\"virtual-device\"></p>\n</li>\n</ul>\n</li>\n<li><p>打开对应的虚拟设备测试安卓开发环境是否成功建立</p>\n<p> 打开对于的虚拟设备后,在项目根目录执行命令启动应用:</p>\n<blockquote>\n<p>react-native run-android </p>\n</blockquote>\n<p> 这一步可能发送报错<code>java.io.EOFException: SSL peer shut down incorrectly</code>,解决方案在后面。</p>\n<p> 这个时候如果build successfully 则在模拟器上可以看到对于app的页面,如果模拟器上出现如下报错:<br> <img src=\"http://rainypin.qiniudn.com/git_imgs/dev-settings.png\" alt=\"dev-settings\"></p>\n<p> 需要设置对应的debug host为当前电脑的ip地址,如下图:</p>\n<p> <img src=\"http://rainypin.qiniudn.com/git_imgs/debug-host.png\" alt=\"debug-host\"></p>\n</li>\n</ol>\n<h2 id=\"环境配置过程报错解决\"><a href=\"#环境配置过程报错解决\" class=\"headerlink\" title=\"环境配置过程报错解决\"></a>环境配置过程报错解决</h2><ul>\n<li>对于安卓开发环境步骤6中运行<code>react-native run-android</code>所报错误解决方法<blockquote>\n<p>下载gradle-2.4-all.zip到本地<br>   本地启动对于的服务<br>   修改 android/gradle/wrapper 下 gradle-wrapper.properties 文件中的 distributionUrl 为本地地址,重新执行 react-native run-android </p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://www.jianshu.com/p/38cb29cdb77d\" target=\"_blank\" rel=\"external\">React Native Android（Genymotion） 环境搭建 for mac</a></li>\n<li><a href=\"http://hahack.com/codes/learn-react-native-for-android-01/\" target=\"_blank\" rel=\"external\">学习 React Native for Android：环境搭建</a></li>\n<li><a href=\"http://amiraanuar.com/step-by-step-guide-to-building-an-android-app-using-react-native-and-genymotion/\" target=\"_blank\" rel=\"external\">Getting Started with Building An App with React Native, Genymotion, and Watchman</a></li>\n<li><a href=\"https://facebook.github.io/react-native/releases/next/docs/getting-started.html\" target=\"_blank\" rel=\"external\">react native getting started</a></li>\n<li><a href=\"http://bbs.reactnative.cn/topic/310/react-native-run-android-%E6%8A%A5%E9%94%99-java-io-eofexception-ssl-peer-shut-down-incorrectly\" target=\"_blank\" rel=\"external\">react-native run-android 报错解决</a></li>\n<li><a href=\"http://www.jianshu.com/p/847a54e0c385\" target=\"_blank\" rel=\"external\">React Native For Android初体验</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h2><p>在针对特定平台开发环境建立之前,你需要先安装<code>node</code>,<code>watchman</code>,<code>react-native-cli</code>。在Mac上我们可以通过<a href=\"https://brew.sh/\" target=\"_blank\" rel=\"external\">HomeBrew</a>进行相应的安装。</p>\n<blockquote>\n<p>brew install node<br>brew install watchman<br>brew install flow<br>npm install -g react-native-cli</p>\n</blockquote>\n<h3 id=\"ios-开发环境搭建\"><a href=\"#ios-开发环境搭建\" class=\"headerlink\" title=\"ios 开发环境搭建\"></a>ios 开发环境搭建</h3><p>对于ios 只需要从app store中安装xcode即可,安装xcode会自动安装ios 模拟器以及一些构建app所需要的工具。通过react-native 命令初始化一个项目然后测试ios开发环境是否成功建立。</p>\n<blockquote>\n<p>react-native init AwesomeProject<br>cd AwesomeProject</p>\n</blockquote>\n<p>在ios模拟器中启动应用,两种方式:</p>\n<ol>\n<li><p>通过命令行直接唤起模拟器打开app</p>\n<blockquote>\n<p> react-native run-ios</p>\n</blockquote>\n<p> 执行完该命令,正常情况下,会打开ios模拟器,然后启动应用以供调试。</p>\n</li>\n<li><p>进入目录<code>AwesomeProject</code>,打开<code>ios</code>目录下的文件<code>AwesomeProject.xcodeproj</code>,如果xcode成功安装,默认会打开xcode。然后直接<br><img src=\"http://rainypin.qiniudn.com/git_imgs/xcode-run.png\" alt=\"xcode-run\"></p>\n</li>\n</ol>\n<h3 id=\"android-开发环境搭建\"><a href=\"#android-开发环境搭建\" class=\"headerlink\" title=\"android 开发环境搭建\"></a>android 开发环境搭建</h3><p>对于android开发环境要稍微复杂一些。</p>\n<ol>\n<li>安装安卓模拟器<a href=\"https://www.genymotion.com/download/\" target=\"_blank\" rel=\"external\">genymotion</a><blockquote>\n<p>安装完成后需要去官网注册一个账户并激活,后续创建虚拟设备将会用到。</p>\n</blockquote>\n</li>\n<li><p>安装<a href=\"http://rj.baidu.com/soft/detail/25850.html?ald\" target=\"_blank\" rel=\"external\">virtual box</a></p>\n</li>\n<li><p>安装最新版JDK</p>\n</li>\n<li><p>安装安卓Android Studio </p>\n</li>\n</ol>\n<ul>\n<li><p>打开sdk manager 安装的Android sdk</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/android-studio.png\" alt=\"android studio\"></p>\n</li>\n<li><p>选择需要安装的内容</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/android-sdk.png\" alt=\"android sdk\"></p>\n</li>\n</ul>\n<ol>\n<li><p>打开genymotion 创建安卓模拟器</p>\n<ul>\n<li><p>先设置好正确的android sdk路径 </p>\n<p>  <img src=\"http://rainypin.qiniudn.com/git_imgs/settings.png\" alt=\"settings\"></p>\n</li>\n<li><p>添加相应的虚拟设备</p>\n<p>  <img src=\"http://rainypin.qiniudn.com/git_imgs/virtual-device.png\" alt=\"virtual-device\"></p>\n</li>\n</ul>\n</li>\n<li><p>打开对应的虚拟设备测试安卓开发环境是否成功建立</p>\n<p> 打开对于的虚拟设备后,在项目根目录执行命令启动应用:</p>\n<blockquote>\n<p>react-native run-android </p>\n</blockquote>\n<p> 这一步可能发送报错<code>java.io.EOFException: SSL peer shut down incorrectly</code>,解决方案在后面。</p>\n<p> 这个时候如果build successfully 则在模拟器上可以看到对于app的页面,如果模拟器上出现如下报错:<br> <img src=\"http://rainypin.qiniudn.com/git_imgs/dev-settings.png\" alt=\"dev-settings\"></p>\n<p> 需要设置对应的debug host为当前电脑的ip地址,如下图:</p>\n<p> <img src=\"http://rainypin.qiniudn.com/git_imgs/debug-host.png\" alt=\"debug-host\"></p>\n</li>\n</ol>\n<h2 id=\"环境配置过程报错解决\"><a href=\"#环境配置过程报错解决\" class=\"headerlink\" title=\"环境配置过程报错解决\"></a>环境配置过程报错解决</h2><ul>\n<li>对于安卓开发环境步骤6中运行<code>react-native run-android</code>所报错误解决方法<blockquote>\n<p>下载gradle-2.4-all.zip到本地<br>   本地启动对于的服务<br>   修改 android/gradle/wrapper 下 gradle-wrapper.properties 文件中的 distributionUrl 为本地地址,重新执行 react-native run-android </p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://www.jianshu.com/p/38cb29cdb77d\" target=\"_blank\" rel=\"external\">React Native Android（Genymotion） 环境搭建 for mac</a></li>\n<li><a href=\"http://hahack.com/codes/learn-react-native-for-android-01/\" target=\"_blank\" rel=\"external\">学习 React Native for Android：环境搭建</a></li>\n<li><a href=\"http://amiraanuar.com/step-by-step-guide-to-building-an-android-app-using-react-native-and-genymotion/\" target=\"_blank\" rel=\"external\">Getting Started with Building An App with React Native, Genymotion, and Watchman</a></li>\n<li><a href=\"https://facebook.github.io/react-native/releases/next/docs/getting-started.html\" target=\"_blank\" rel=\"external\">react native getting started</a></li>\n<li><a href=\"http://bbs.reactnative.cn/topic/310/react-native-run-android-%E6%8A%A5%E9%94%99-java-io-eofexception-ssl-peer-shut-down-incorrectly\" target=\"_blank\" rel=\"external\">react-native run-android 报错解决</a></li>\n<li><a href=\"http://www.jianshu.com/p/847a54e0c385\" target=\"_blank\" rel=\"external\">React Native For Android初体验</a></li>\n</ol>\n"},{"title":"用JavaScript来写客户端 — React Native","type":"original","date":"2017-04-26T07:46:34.000Z","description":"React Native让开发者可以使用 JavaScript 编写native应用，利用相同的核心代码就可以创建基于 Web ， iOS 和 Android 平台的原生应用。React Native除了性能体验上比H5更好外,相比用原生来开发页面React Native还是有些优势","_content":"\n> LEARN ONCE, WRITE ANYWHERE!\n\nReact Native让开发者可以使用``JavaScript``编写native应用，利用相同的核心代码就可以创建基于``Web``，``iOS``和``Android``平台的原生应用。React Native除了性能体验上比H5更好外,相比用原生来开发页面React Native还是有些优势:\n* 热更新\n* 开发页面速度会更快一些,页面布局相对更加容易一些\n\n\n\n对于前端的开发同学来说``React Native = React + 封装的Native组件``,所以从``React`` 切换到 ``React Native`` 学习成本主要在于React Native 环境的搭建,学习React Native 所封装的一套组件,如何用有限的CSS样式子集来完成UI的布局以及最后React Native代码的调试。\n\n### React 生命周期\n\nReact提出重新思考UI开发过程，其实不是面向浏览器，而是所有的前端，因为对前端开发而言我们需要涉及的领域已经开始包括了Web与Native,React定义了组件的生命周期,让开发者只需关心组件的状态变更,从组件的角度去思考一个app。让代码的扩展性,重用性都有了很大的提高,简化了应用的开发。React Native 组件沿用了React的生命周期,如下图:\n\n![react-life-cycle](http://rainypin.qiniudn.com/git_imgs/react-life-cycle.png)\n\n[参考React生命周期](/react/react-life-cycle.html)\n### React Native 代码组织\n\n```\n.\n├── README.md*\n├── android/\n├── app/\n│   ├── components/\n│   ├── config.js\n│   ├── containers/\n│   ├── images/\n│   ├── lib/\n│   ├── network/\n│   ├── screens/\n│   └── styles/\n├── bin/\n│   └── bundle*\n├── build/\n│   ├── android/\n│   ├── android-inline.zip\n│   ├── android.zip\n│   ├── ios/\n│   ├── ios-inline.zip\n│   └── ios.zip\n├── gulpfile.js\n├── index.android.js\n├── index.ios.js\n├── ios/\n├── mock/\n│   ├── async/\n│   └── uploads/\n├── ngrok.cfg*\n├── package/\n│   ├── core/\n│   └── lib/\n└── package.json\n```\n#### 1. ``app``目录 \nReact Native 源代码目录,其中:\n* ``components`` 目录\n\n    > 该目录是组件目录,单独抽离封装可被重用的组件存在该目录底下,每个组件单独管理组件的逻辑,样式,和组件所依赖的图片资源。\n    \n* ``containers``目录\n\n   > 容器组件目录/基类存放目录,目前整个React Native中的页面都会继承该目录底下的Base类,这个基类用来同步React Native的生命周期给Native端。并定义一些通用的方法或者绑定和解绑全局事件。\n\n* ``lib``目录\n\n    > 该目录存放了整个React Native项目中用到的基础工具方法。如:base64编码解码,cdn图片的尺寸裁剪,封装好的异步请求接口(会根据RN运行环境选择使用客户端提供的请求和使用RN自带的请求方法),Strorage本地存储,环境选择等工具方法。\n\n* ``screens`` 目录\n    > 该目录存放React Native页面的入口文件,一个页面对应一个入口文件。\n    \n* ``styles``目录\n    > 该目录存放全局的样式配置和不同平台不同屏幕大小的样式兼容处理方法mixin。\n\n* ``images`` 目录\n    > 本地图片存放目录\n\n* ``network``目录 \n    > 测试资源存放目录 \n\n* ``config.js``文件 \n    > 项目全局配置文件,包括平台判断,全局字体颜色,背景颜色,屏幕的高宽等等。\n\n#### 2. ``package``目录\n该目录存放了前端构建任务代码,包括前端数据mock,上传七牛,git版本校验等。\n\n* ``core`` 目录\n\n    > 存放核心任务代码,任务命名规则``'core.' + 任务文件名 + ':具体任务名'``,例如``qiniu.js``里的上传任务名称``core.qiniu:upload``。这样的命名好处在于能够在``gulpfile.js``文件中通过任务名称快速的定位到任务逻辑代码所在的具体文件。\n    \n* ``lib`` 目录\n    \n    > 前端打包体系所依赖的一些工具方法所在的目录。\n    \n#### 3. ``mock``目录 \n异步数据mock文件所在的目录\n* ``async``目录\n   > 异步数据mock文件存放目录,文件内容格式如下:\n   \n   ```javascript\n    module.exports = {\n      /*\n        异步请求接口定义方式\n        'request_method inteface_name' : request handle function\n      */\n      'get /rest/user' : function(req,res) {\n      \n       },\n      /*\n        文件上传mock\n        'request_method inteface_name file' : request handle function\n      */\n      'post /api/contact/import/ file' : function(req,res) {\n      \n       } \n    }\n   ```\n* ``upload``目录 \n\n    > 上传后的文件所在目录。\n\n#### 4. ``bin``目录\nReact Native打包命令所在的目录,打包后的文件存放在build目录中。[参考RN打包工具](https://github.com/xdimh/react-native-bundle)\n\n### React Native 与 Native的通信\n在RN和Native的一个混合应用场景下,RN和Native的通信必不可少,具体形式如下:\n1. Native -> RN \n    * 方式一: Native 通过一定的方式[[参考在原生和React Native间通信]](https://reactnative.cn/docs/0.41/communication-ios.html#content)\n将需要传给RN的数据作为RN页面初始化属性注入,在RN中可以通过``this.props.properties``进行访问。\n    * 方式二: Native 通过emit事件的方式将数据传递给RN端。RN端通过``DeviceEventEmitter.addListener('reloadPageEvent', this.reloadPage.bind(this));``绑定事件,Native端emit对应的事件。\n    * 方式三:Callback,RN调用Native提供的桥接方法,并传入相应的Callback,最终Native会调用这个回调,并传递相应的数据给RN端。\n    \n2. RN -> Native\n\n    > 通过Native提供的桥接方法,RN使用Native的功能并把Native需要的参数传递个Native,最后通过Callback的方式或者事件的方式将结果告知RN。\n\n    ```javascript\n    // Native Bridges\n    const RNView = NativeModules.IMYRNView || {};\n    const RNBridgeManager = NativeModules.IMYRNBridgeManager || {};\n    //然后可以通过RNBridgeManager.method直接调用。\n    ```\n\n### React Native 代码调试\n``React Native`` 的代码调试相比纯web来说要没那么方便些,特别是在和Native对接代码调试那块。对于RN自己这边的代码相比web调试起来差别不是特别大。具体方式ios模拟器(android类似)``command + d``,打开设置项:\n\n![React Native代码调试](http://rainypin.qiniudn.com/git_imgs/rn_debug.png)\n\n启动远程JS调试,启动远程代码调试,可以对代码设置断点,进行断点调试:\n\n![React Native 代码断点调试](http://rainypin.qiniudn.com/git_imgs/rn_debug_breakpoint.png)\n\n同时你可以打开hot reload 功能,这样代码修改,界面就能自动reload,实时看到效果,提高开发调试效率。这个过程对前端开发同学来说比较熟悉,一般出现的问题也很好定位和修改。\n\n对于React Native 和 Native 进行联调就相对来说就要复杂些,由于业务需要,RN 往往需要 Native提供相应的桥接方法,让RN可以使用Native的某些功能。但调试起来却不太方便,在项目开发阶段,这个过程算是比较费时的,如下两种方式正是我们现在所使用的方式:\n* 方式一\n    > RN这边将写好的代码打包成bundle,然后交给Native同学去看,如果有问题(RN这边往往需要console.log输出信息),Native的同学断点定位,判断问题出现在Native端还是RN端,再由接锅的一方修改,然后重复此过程直到功能正常。\n* 方式二\n    > Native给出一个分支,这个分支专门用于和RN进行联调,Native的同学往往需要在这个分支上做一些特殊配置,比如RN的bundle包读取位置不在是本地而是一个url如:``http://192.168.199.115:8081/index.ios.bundle?platform=ios``,RN端只需要通过``node node_modules/react-native/local-cli/cli.js start``启动服务。然后开启Xcode,debug模式启动项目,这样就可以在RN这边单独进行联调,问题的定位,如果确实是Native的问题,再告知Native同学进行修改。\n    \n其中方式二还是从一定程度上提高了React Native 和 Native 端联调的效率。\n\n### React Native 代码打包\n[参考RN打包工具](https://github.com/xdimh/react-native-bundle)\n\n### React Native Zip包下发\n让React Native实现app真正的热更新功能就需要RN的代码每次版本更新时可以通过网络下发到app上,从而不用app重新打包发布。Native获取到新的React Native包逻辑大致如下图:\n\n![Native获取zip包大致逻辑](http://rainypin.qiniudn.com/git_imgs/zip-load-flow.png)\n\n局限性: 如果RN端的修改需要依赖到Native提供新的bridge,这样客户端也不得不重新进行打包发布。\n\nRN版本更新需要对door开关进行配置,具体格式如下:\n```javascript\n{\n    \"list\" : [{\n        \"rnname\": \"projectName1\", //RN项目名称 \n        \"rnversion\": \"1.0.1\", //RN版本\n        \"rnurl\": \"https://hostname/projectName1/path/1.0.1/ios.zip\" //RN最新zip包路径\n    }, {\n        \"rnname\": \"projectName2\",\n        \"rnversion\": \"1.0.1\",\n        \"rnurl\": \"https://hostname/projectName1/path/1.0.1/ios.zip\"\n    }]\n}\n```\n发版的时候只需更新``rnversion``字段就行,通过数组方式支持多个bundle包,不同的bundle包通过rnname进行区分,这种方式还可以更新特定的bundle而不会影响到其他RN页面。\n\n### React Native 版本升级方案【待做】\nReact Native现在几乎是一个月出一个小版本,当前版本已经是``0.41``,可见社区还是很活跃的,也可以看到React Native还是逐渐在完善,有些功能甚至一些参数选项都不太稳定,没准在下一个版本某个组件的选项就会被废弃,某个方法参数就有可能被调整,所以对于版本升级来说,这会照成一些代码兼容性的问题,升级后原有的代码不一定就能跑通,但从新版RN代码更完善的功能,更少的bug,以及以后开源的RN的组件都可能是基于高版本RN而开发的情况,我们都应该有个理想的版本的升级方法,在需要的时候进行版本的升级。","source":"_posts/rn-introduction.md","raw":"---\ntitle: 用JavaScript来写客户端 — React Native\ntype: original\ntags: ['React Native']\ncategories: ['React Native']\ndate: 2017-04-26 15:46:34\ndescription: React Native让开发者可以使用 JavaScript 编写native应用，利用相同的核心代码就可以创建基于 Web ， iOS 和 Android 平台的原生应用。React Native除了性能体验上比H5更好外,相比用原生来开发页面React Native还是有些优势\n---\n\n> LEARN ONCE, WRITE ANYWHERE!\n\nReact Native让开发者可以使用``JavaScript``编写native应用，利用相同的核心代码就可以创建基于``Web``，``iOS``和``Android``平台的原生应用。React Native除了性能体验上比H5更好外,相比用原生来开发页面React Native还是有些优势:\n* 热更新\n* 开发页面速度会更快一些,页面布局相对更加容易一些\n\n\n\n对于前端的开发同学来说``React Native = React + 封装的Native组件``,所以从``React`` 切换到 ``React Native`` 学习成本主要在于React Native 环境的搭建,学习React Native 所封装的一套组件,如何用有限的CSS样式子集来完成UI的布局以及最后React Native代码的调试。\n\n### React 生命周期\n\nReact提出重新思考UI开发过程，其实不是面向浏览器，而是所有的前端，因为对前端开发而言我们需要涉及的领域已经开始包括了Web与Native,React定义了组件的生命周期,让开发者只需关心组件的状态变更,从组件的角度去思考一个app。让代码的扩展性,重用性都有了很大的提高,简化了应用的开发。React Native 组件沿用了React的生命周期,如下图:\n\n![react-life-cycle](http://rainypin.qiniudn.com/git_imgs/react-life-cycle.png)\n\n[参考React生命周期](/react/react-life-cycle.html)\n### React Native 代码组织\n\n```\n.\n├── README.md*\n├── android/\n├── app/\n│   ├── components/\n│   ├── config.js\n│   ├── containers/\n│   ├── images/\n│   ├── lib/\n│   ├── network/\n│   ├── screens/\n│   └── styles/\n├── bin/\n│   └── bundle*\n├── build/\n│   ├── android/\n│   ├── android-inline.zip\n│   ├── android.zip\n│   ├── ios/\n│   ├── ios-inline.zip\n│   └── ios.zip\n├── gulpfile.js\n├── index.android.js\n├── index.ios.js\n├── ios/\n├── mock/\n│   ├── async/\n│   └── uploads/\n├── ngrok.cfg*\n├── package/\n│   ├── core/\n│   └── lib/\n└── package.json\n```\n#### 1. ``app``目录 \nReact Native 源代码目录,其中:\n* ``components`` 目录\n\n    > 该目录是组件目录,单独抽离封装可被重用的组件存在该目录底下,每个组件单独管理组件的逻辑,样式,和组件所依赖的图片资源。\n    \n* ``containers``目录\n\n   > 容器组件目录/基类存放目录,目前整个React Native中的页面都会继承该目录底下的Base类,这个基类用来同步React Native的生命周期给Native端。并定义一些通用的方法或者绑定和解绑全局事件。\n\n* ``lib``目录\n\n    > 该目录存放了整个React Native项目中用到的基础工具方法。如:base64编码解码,cdn图片的尺寸裁剪,封装好的异步请求接口(会根据RN运行环境选择使用客户端提供的请求和使用RN自带的请求方法),Strorage本地存储,环境选择等工具方法。\n\n* ``screens`` 目录\n    > 该目录存放React Native页面的入口文件,一个页面对应一个入口文件。\n    \n* ``styles``目录\n    > 该目录存放全局的样式配置和不同平台不同屏幕大小的样式兼容处理方法mixin。\n\n* ``images`` 目录\n    > 本地图片存放目录\n\n* ``network``目录 \n    > 测试资源存放目录 \n\n* ``config.js``文件 \n    > 项目全局配置文件,包括平台判断,全局字体颜色,背景颜色,屏幕的高宽等等。\n\n#### 2. ``package``目录\n该目录存放了前端构建任务代码,包括前端数据mock,上传七牛,git版本校验等。\n\n* ``core`` 目录\n\n    > 存放核心任务代码,任务命名规则``'core.' + 任务文件名 + ':具体任务名'``,例如``qiniu.js``里的上传任务名称``core.qiniu:upload``。这样的命名好处在于能够在``gulpfile.js``文件中通过任务名称快速的定位到任务逻辑代码所在的具体文件。\n    \n* ``lib`` 目录\n    \n    > 前端打包体系所依赖的一些工具方法所在的目录。\n    \n#### 3. ``mock``目录 \n异步数据mock文件所在的目录\n* ``async``目录\n   > 异步数据mock文件存放目录,文件内容格式如下:\n   \n   ```javascript\n    module.exports = {\n      /*\n        异步请求接口定义方式\n        'request_method inteface_name' : request handle function\n      */\n      'get /rest/user' : function(req,res) {\n      \n       },\n      /*\n        文件上传mock\n        'request_method inteface_name file' : request handle function\n      */\n      'post /api/contact/import/ file' : function(req,res) {\n      \n       } \n    }\n   ```\n* ``upload``目录 \n\n    > 上传后的文件所在目录。\n\n#### 4. ``bin``目录\nReact Native打包命令所在的目录,打包后的文件存放在build目录中。[参考RN打包工具](https://github.com/xdimh/react-native-bundle)\n\n### React Native 与 Native的通信\n在RN和Native的一个混合应用场景下,RN和Native的通信必不可少,具体形式如下:\n1. Native -> RN \n    * 方式一: Native 通过一定的方式[[参考在原生和React Native间通信]](https://reactnative.cn/docs/0.41/communication-ios.html#content)\n将需要传给RN的数据作为RN页面初始化属性注入,在RN中可以通过``this.props.properties``进行访问。\n    * 方式二: Native 通过emit事件的方式将数据传递给RN端。RN端通过``DeviceEventEmitter.addListener('reloadPageEvent', this.reloadPage.bind(this));``绑定事件,Native端emit对应的事件。\n    * 方式三:Callback,RN调用Native提供的桥接方法,并传入相应的Callback,最终Native会调用这个回调,并传递相应的数据给RN端。\n    \n2. RN -> Native\n\n    > 通过Native提供的桥接方法,RN使用Native的功能并把Native需要的参数传递个Native,最后通过Callback的方式或者事件的方式将结果告知RN。\n\n    ```javascript\n    // Native Bridges\n    const RNView = NativeModules.IMYRNView || {};\n    const RNBridgeManager = NativeModules.IMYRNBridgeManager || {};\n    //然后可以通过RNBridgeManager.method直接调用。\n    ```\n\n### React Native 代码调试\n``React Native`` 的代码调试相比纯web来说要没那么方便些,特别是在和Native对接代码调试那块。对于RN自己这边的代码相比web调试起来差别不是特别大。具体方式ios模拟器(android类似)``command + d``,打开设置项:\n\n![React Native代码调试](http://rainypin.qiniudn.com/git_imgs/rn_debug.png)\n\n启动远程JS调试,启动远程代码调试,可以对代码设置断点,进行断点调试:\n\n![React Native 代码断点调试](http://rainypin.qiniudn.com/git_imgs/rn_debug_breakpoint.png)\n\n同时你可以打开hot reload 功能,这样代码修改,界面就能自动reload,实时看到效果,提高开发调试效率。这个过程对前端开发同学来说比较熟悉,一般出现的问题也很好定位和修改。\n\n对于React Native 和 Native 进行联调就相对来说就要复杂些,由于业务需要,RN 往往需要 Native提供相应的桥接方法,让RN可以使用Native的某些功能。但调试起来却不太方便,在项目开发阶段,这个过程算是比较费时的,如下两种方式正是我们现在所使用的方式:\n* 方式一\n    > RN这边将写好的代码打包成bundle,然后交给Native同学去看,如果有问题(RN这边往往需要console.log输出信息),Native的同学断点定位,判断问题出现在Native端还是RN端,再由接锅的一方修改,然后重复此过程直到功能正常。\n* 方式二\n    > Native给出一个分支,这个分支专门用于和RN进行联调,Native的同学往往需要在这个分支上做一些特殊配置,比如RN的bundle包读取位置不在是本地而是一个url如:``http://192.168.199.115:8081/index.ios.bundle?platform=ios``,RN端只需要通过``node node_modules/react-native/local-cli/cli.js start``启动服务。然后开启Xcode,debug模式启动项目,这样就可以在RN这边单独进行联调,问题的定位,如果确实是Native的问题,再告知Native同学进行修改。\n    \n其中方式二还是从一定程度上提高了React Native 和 Native 端联调的效率。\n\n### React Native 代码打包\n[参考RN打包工具](https://github.com/xdimh/react-native-bundle)\n\n### React Native Zip包下发\n让React Native实现app真正的热更新功能就需要RN的代码每次版本更新时可以通过网络下发到app上,从而不用app重新打包发布。Native获取到新的React Native包逻辑大致如下图:\n\n![Native获取zip包大致逻辑](http://rainypin.qiniudn.com/git_imgs/zip-load-flow.png)\n\n局限性: 如果RN端的修改需要依赖到Native提供新的bridge,这样客户端也不得不重新进行打包发布。\n\nRN版本更新需要对door开关进行配置,具体格式如下:\n```javascript\n{\n    \"list\" : [{\n        \"rnname\": \"projectName1\", //RN项目名称 \n        \"rnversion\": \"1.0.1\", //RN版本\n        \"rnurl\": \"https://hostname/projectName1/path/1.0.1/ios.zip\" //RN最新zip包路径\n    }, {\n        \"rnname\": \"projectName2\",\n        \"rnversion\": \"1.0.1\",\n        \"rnurl\": \"https://hostname/projectName1/path/1.0.1/ios.zip\"\n    }]\n}\n```\n发版的时候只需更新``rnversion``字段就行,通过数组方式支持多个bundle包,不同的bundle包通过rnname进行区分,这种方式还可以更新特定的bundle而不会影响到其他RN页面。\n\n### React Native 版本升级方案【待做】\nReact Native现在几乎是一个月出一个小版本,当前版本已经是``0.41``,可见社区还是很活跃的,也可以看到React Native还是逐渐在完善,有些功能甚至一些参数选项都不太稳定,没准在下一个版本某个组件的选项就会被废弃,某个方法参数就有可能被调整,所以对于版本升级来说,这会照成一些代码兼容性的问题,升级后原有的代码不一定就能跑通,但从新版RN代码更完善的功能,更少的bug,以及以后开源的RN的组件都可能是基于高版本RN而开发的情况,我们都应该有个理想的版本的升级方法,在需要的时候进行版本的升级。","slug":"rn-introduction","published":1,"updated":"2017-05-03T05:53:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhre001db37qj3e98bh6","content":"<blockquote>\n<p>LEARN ONCE, WRITE ANYWHERE!</p>\n</blockquote>\n<p>React Native让开发者可以使用<code>JavaScript</code>编写native应用，利用相同的核心代码就可以创建基于<code>Web</code>，<code>iOS</code>和<code>Android</code>平台的原生应用。React Native除了性能体验上比H5更好外,相比用原生来开发页面React Native还是有些优势:</p>\n<ul>\n<li>热更新</li>\n<li>开发页面速度会更快一些,页面布局相对更加容易一些</li>\n</ul>\n<p>对于前端的开发同学来说<code>React Native = React + 封装的Native组件</code>,所以从<code>React</code> 切换到 <code>React Native</code> 学习成本主要在于React Native 环境的搭建,学习React Native 所封装的一套组件,如何用有限的CSS样式子集来完成UI的布局以及最后React Native代码的调试。</p>\n<h3 id=\"React-生命周期\"><a href=\"#React-生命周期\" class=\"headerlink\" title=\"React 生命周期\"></a>React 生命周期</h3><p>React提出重新思考UI开发过程，其实不是面向浏览器，而是所有的前端，因为对前端开发而言我们需要涉及的领域已经开始包括了Web与Native,React定义了组件的生命周期,让开发者只需关心组件的状态变更,从组件的角度去思考一个app。让代码的扩展性,重用性都有了很大的提高,简化了应用的开发。React Native 组件沿用了React的生命周期,如下图:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/react-life-cycle.png\" alt=\"react-life-cycle\"></p>\n<p><a href=\"/react/react-life-cycle.html\">参考React生命周期</a></p>\n<h3 id=\"React-Native-代码组织\"><a href=\"#React-Native-代码组织\" class=\"headerlink\" title=\"React Native 代码组织\"></a>React Native 代码组织</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── README.md*</div><div class=\"line\">├── android/</div><div class=\"line\">├── app/</div><div class=\"line\">│   ├── components/</div><div class=\"line\">│   ├── config.js</div><div class=\"line\">│   ├── containers/</div><div class=\"line\">│   ├── images/</div><div class=\"line\">│   ├── lib/</div><div class=\"line\">│   ├── network/</div><div class=\"line\">│   ├── screens/</div><div class=\"line\">│   └── styles/</div><div class=\"line\">├── bin/</div><div class=\"line\">│   └── bundle*</div><div class=\"line\">├── build/</div><div class=\"line\">│   ├── android/</div><div class=\"line\">│   ├── android-inline.zip</div><div class=\"line\">│   ├── android.zip</div><div class=\"line\">│   ├── ios/</div><div class=\"line\">│   ├── ios-inline.zip</div><div class=\"line\">│   └── ios.zip</div><div class=\"line\">├── gulpfile.js</div><div class=\"line\">├── index.android.js</div><div class=\"line\">├── index.ios.js</div><div class=\"line\">├── ios/</div><div class=\"line\">├── mock/</div><div class=\"line\">│   ├── async/</div><div class=\"line\">│   └── uploads/</div><div class=\"line\">├── ngrok.cfg*</div><div class=\"line\">├── package/</div><div class=\"line\">│   ├── core/</div><div class=\"line\">│   └── lib/</div><div class=\"line\">└── package.json</div></pre></td></tr></table></figure>\n<h4 id=\"1-app目录\"><a href=\"#1-app目录\" class=\"headerlink\" title=\"1. app目录\"></a>1. <code>app</code>目录</h4><p>React Native 源代码目录,其中:</p>\n<ul>\n<li><p><code>components</code> 目录</p>\n<blockquote>\n<p>该目录是组件目录,单独抽离封装可被重用的组件存在该目录底下,每个组件单独管理组件的逻辑,样式,和组件所依赖的图片资源。</p>\n</blockquote>\n</li>\n<li><p><code>containers</code>目录</p>\n<blockquote>\n<p>容器组件目录/基类存放目录,目前整个React Native中的页面都会继承该目录底下的Base类,这个基类用来同步React Native的生命周期给Native端。并定义一些通用的方法或者绑定和解绑全局事件。</p>\n</blockquote>\n</li>\n<li><p><code>lib</code>目录</p>\n<blockquote>\n<p>该目录存放了整个React Native项目中用到的基础工具方法。如:base64编码解码,cdn图片的尺寸裁剪,封装好的异步请求接口(会根据RN运行环境选择使用客户端提供的请求和使用RN自带的请求方法),Strorage本地存储,环境选择等工具方法。</p>\n</blockquote>\n</li>\n<li><p><code>screens</code> 目录</p>\n<blockquote>\n<p>该目录存放React Native页面的入口文件,一个页面对应一个入口文件。</p>\n</blockquote>\n</li>\n<li><p><code>styles</code>目录</p>\n<blockquote>\n<p>该目录存放全局的样式配置和不同平台不同屏幕大小的样式兼容处理方法mixin。</p>\n</blockquote>\n</li>\n<li><p><code>images</code> 目录</p>\n<blockquote>\n<p>本地图片存放目录</p>\n</blockquote>\n</li>\n<li><p><code>network</code>目录 </p>\n<blockquote>\n<p>测试资源存放目录 </p>\n</blockquote>\n</li>\n<li><p><code>config.js</code>文件 </p>\n<blockquote>\n<p>项目全局配置文件,包括平台判断,全局字体颜色,背景颜色,屏幕的高宽等等。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"2-package目录\"><a href=\"#2-package目录\" class=\"headerlink\" title=\"2. package目录\"></a>2. <code>package</code>目录</h4><p>该目录存放了前端构建任务代码,包括前端数据mock,上传七牛,git版本校验等。</p>\n<ul>\n<li><p><code>core</code> 目录</p>\n<blockquote>\n<p>存放核心任务代码,任务命名规则<code>&#39;core.&#39; + 任务文件名 + &#39;:具体任务名&#39;</code>,例如<code>qiniu.js</code>里的上传任务名称<code>core.qiniu:upload</code>。这样的命名好处在于能够在<code>gulpfile.js</code>文件中通过任务名称快速的定位到任务逻辑代码所在的具体文件。</p>\n</blockquote>\n</li>\n<li><p><code>lib</code> 目录</p>\n<blockquote>\n<p>前端打包体系所依赖的一些工具方法所在的目录。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-mock目录\"><a href=\"#3-mock目录\" class=\"headerlink\" title=\"3. mock目录\"></a>3. <code>mock</code>目录</h4><p>异步数据mock文件所在的目录</p>\n<ul>\n<li><p><code>async</code>目录</p>\n<blockquote>\n<p>异步数据mock文件存放目录,文件内容格式如下:</p>\n</blockquote>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\">    异步请求接口定义方式</div><div class=\"line\">    'request_method inteface_name' : request handle function</div><div class=\"line\">  */</div><div class=\"line\">  <span class=\"string\">'get /rest/user'</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>) </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">   &#125;,</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\">    文件上传mock</div><div class=\"line\">    'request_method inteface_name file' : request handle function</div><div class=\"line\">  */</div><div class=\"line\">  <span class=\"string\">'post /api/contact/import/ file'</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>) </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>upload</code>目录 </p>\n<blockquote>\n<p>上传后的文件所在目录。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"4-bin目录\"><a href=\"#4-bin目录\" class=\"headerlink\" title=\"4. bin目录\"></a>4. <code>bin</code>目录</h4><p>React Native打包命令所在的目录,打包后的文件存放在build目录中。<a href=\"https://github.com/xdimh/react-native-bundle\" target=\"_blank\" rel=\"external\">参考RN打包工具</a></p>\n<h3 id=\"React-Native-与-Native的通信\"><a href=\"#React-Native-与-Native的通信\" class=\"headerlink\" title=\"React Native 与 Native的通信\"></a>React Native 与 Native的通信</h3><p>在RN和Native的一个混合应用场景下,RN和Native的通信必不可少,具体形式如下:</p>\n<ol>\n<li><p>Native -&gt; RN </p>\n<ul>\n<li>方式一: Native 通过一定的方式<a href=\"https://reactnative.cn/docs/0.41/communication-ios.html#content\" target=\"_blank\" rel=\"external\">[参考在原生和React Native间通信]</a><br>将需要传给RN的数据作为RN页面初始化属性注入,在RN中可以通过<code>this.props.properties</code>进行访问。</li>\n<li>方式二: Native 通过emit事件的方式将数据传递给RN端。RN端通过<code>DeviceEventEmitter.addListener(&#39;reloadPageEvent&#39;, this.reloadPage.bind(this));</code>绑定事件,Native端emit对应的事件。</li>\n<li>方式三:Callback,RN调用Native提供的桥接方法,并传入相应的Callback,最终Native会调用这个回调,并传递相应的数据给RN端。</li>\n</ul>\n</li>\n<li><p>RN -&gt; Native</p>\n<blockquote>\n<p>通过Native提供的桥接方法,RN使用Native的功能并把Native需要的参数传递个Native,最后通过Callback的方式或者事件的方式将结果告知RN。</p>\n</blockquote>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Native Bridges</span></div><div class=\"line\"><span class=\"keyword\">const</span> RNView = NativeModules.IMYRNView || &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> RNBridgeManager = NativeModules.IMYRNBridgeManager || &#123;&#125;;</div><div class=\"line\"><span class=\"comment\">//然后可以通过RNBridgeManager.method直接调用。</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"React-Native-代码调试\"><a href=\"#React-Native-代码调试\" class=\"headerlink\" title=\"React Native 代码调试\"></a>React Native 代码调试</h3><p><code>React Native</code> 的代码调试相比纯web来说要没那么方便些,特别是在和Native对接代码调试那块。对于RN自己这边的代码相比web调试起来差别不是特别大。具体方式ios模拟器(android类似)<code>command + d</code>,打开设置项:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/rn_debug.png\" alt=\"React Native代码调试\"></p>\n<p>启动远程JS调试,启动远程代码调试,可以对代码设置断点,进行断点调试:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/rn_debug_breakpoint.png\" alt=\"React Native 代码断点调试\"></p>\n<p>同时你可以打开hot reload 功能,这样代码修改,界面就能自动reload,实时看到效果,提高开发调试效率。这个过程对前端开发同学来说比较熟悉,一般出现的问题也很好定位和修改。</p>\n<p>对于React Native 和 Native 进行联调就相对来说就要复杂些,由于业务需要,RN 往往需要 Native提供相应的桥接方法,让RN可以使用Native的某些功能。但调试起来却不太方便,在项目开发阶段,这个过程算是比较费时的,如下两种方式正是我们现在所使用的方式:</p>\n<ul>\n<li>方式一<blockquote>\n<p>RN这边将写好的代码打包成bundle,然后交给Native同学去看,如果有问题(RN这边往往需要console.log输出信息),Native的同学断点定位,判断问题出现在Native端还是RN端,再由接锅的一方修改,然后重复此过程直到功能正常。</p>\n</blockquote>\n</li>\n<li>方式二<blockquote>\n<p>Native给出一个分支,这个分支专门用于和RN进行联调,Native的同学往往需要在这个分支上做一些特殊配置,比如RN的bundle包读取位置不在是本地而是一个url如:<code>http://192.168.199.115:8081/index.ios.bundle?platform=ios</code>,RN端只需要通过<code>node node_modules/react-native/local-cli/cli.js start</code>启动服务。然后开启Xcode,debug模式启动项目,这样就可以在RN这边单独进行联调,问题的定位,如果确实是Native的问题,再告知Native同学进行修改。</p>\n</blockquote>\n</li>\n</ul>\n<p>其中方式二还是从一定程度上提高了React Native 和 Native 端联调的效率。</p>\n<h3 id=\"React-Native-代码打包\"><a href=\"#React-Native-代码打包\" class=\"headerlink\" title=\"React Native 代码打包\"></a>React Native 代码打包</h3><p><a href=\"https://github.com/xdimh/react-native-bundle\" target=\"_blank\" rel=\"external\">参考RN打包工具</a></p>\n<h3 id=\"React-Native-Zip包下发\"><a href=\"#React-Native-Zip包下发\" class=\"headerlink\" title=\"React Native Zip包下发\"></a>React Native Zip包下发</h3><p>让React Native实现app真正的热更新功能就需要RN的代码每次版本更新时可以通过网络下发到app上,从而不用app重新打包发布。Native获取到新的React Native包逻辑大致如下图:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/zip-load-flow.png\" alt=\"Native获取zip包大致逻辑\"></p>\n<p>局限性: 如果RN端的修改需要依赖到Native提供新的bridge,这样客户端也不得不重新进行打包发布。</p>\n<p>RN版本更新需要对door开关进行配置,具体格式如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"list\"</span> : [&#123;</div><div class=\"line\">        <span class=\"string\">\"rnname\"</span>: <span class=\"string\">\"projectName1\"</span>, <span class=\"comment\">//RN项目名称 </span></div><div class=\"line\">        <span class=\"string\">\"rnversion\"</span>: <span class=\"string\">\"1.0.1\"</span>, <span class=\"comment\">//RN版本</span></div><div class=\"line\">        <span class=\"string\">\"rnurl\"</span>: <span class=\"string\">\"https://hostname/projectName1/path/1.0.1/ios.zip\"</span> <span class=\"comment\">//RN最新zip包路径</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        <span class=\"string\">\"rnname\"</span>: <span class=\"string\">\"projectName2\"</span>,</div><div class=\"line\">        <span class=\"string\">\"rnversion\"</span>: <span class=\"string\">\"1.0.1\"</span>,</div><div class=\"line\">        <span class=\"string\">\"rnurl\"</span>: <span class=\"string\">\"https://hostname/projectName1/path/1.0.1/ios.zip\"</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>发版的时候只需更新<code>rnversion</code>字段就行,通过数组方式支持多个bundle包,不同的bundle包通过rnname进行区分,这种方式还可以更新特定的bundle而不会影响到其他RN页面。</p>\n<h3 id=\"React-Native-版本升级方案【待做】\"><a href=\"#React-Native-版本升级方案【待做】\" class=\"headerlink\" title=\"React Native 版本升级方案【待做】\"></a>React Native 版本升级方案【待做】</h3><p>React Native现在几乎是一个月出一个小版本,当前版本已经是<code>0.41</code>,可见社区还是很活跃的,也可以看到React Native还是逐渐在完善,有些功能甚至一些参数选项都不太稳定,没准在下一个版本某个组件的选项就会被废弃,某个方法参数就有可能被调整,所以对于版本升级来说,这会照成一些代码兼容性的问题,升级后原有的代码不一定就能跑通,但从新版RN代码更完善的功能,更少的bug,以及以后开源的RN的组件都可能是基于高版本RN而开发的情况,我们都应该有个理想的版本的升级方法,在需要的时候进行版本的升级。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>LEARN ONCE, WRITE ANYWHERE!</p>\n</blockquote>\n<p>React Native让开发者可以使用<code>JavaScript</code>编写native应用，利用相同的核心代码就可以创建基于<code>Web</code>，<code>iOS</code>和<code>Android</code>平台的原生应用。React Native除了性能体验上比H5更好外,相比用原生来开发页面React Native还是有些优势:</p>\n<ul>\n<li>热更新</li>\n<li>开发页面速度会更快一些,页面布局相对更加容易一些</li>\n</ul>\n<p>对于前端的开发同学来说<code>React Native = React + 封装的Native组件</code>,所以从<code>React</code> 切换到 <code>React Native</code> 学习成本主要在于React Native 环境的搭建,学习React Native 所封装的一套组件,如何用有限的CSS样式子集来完成UI的布局以及最后React Native代码的调试。</p>\n<h3 id=\"React-生命周期\"><a href=\"#React-生命周期\" class=\"headerlink\" title=\"React 生命周期\"></a>React 生命周期</h3><p>React提出重新思考UI开发过程，其实不是面向浏览器，而是所有的前端，因为对前端开发而言我们需要涉及的领域已经开始包括了Web与Native,React定义了组件的生命周期,让开发者只需关心组件的状态变更,从组件的角度去思考一个app。让代码的扩展性,重用性都有了很大的提高,简化了应用的开发。React Native 组件沿用了React的生命周期,如下图:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/react-life-cycle.png\" alt=\"react-life-cycle\"></p>\n<p><a href=\"/react/react-life-cycle.html\">参考React生命周期</a></p>\n<h3 id=\"React-Native-代码组织\"><a href=\"#React-Native-代码组织\" class=\"headerlink\" title=\"React Native 代码组织\"></a>React Native 代码组织</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── README.md*</div><div class=\"line\">├── android/</div><div class=\"line\">├── app/</div><div class=\"line\">│   ├── components/</div><div class=\"line\">│   ├── config.js</div><div class=\"line\">│   ├── containers/</div><div class=\"line\">│   ├── images/</div><div class=\"line\">│   ├── lib/</div><div class=\"line\">│   ├── network/</div><div class=\"line\">│   ├── screens/</div><div class=\"line\">│   └── styles/</div><div class=\"line\">├── bin/</div><div class=\"line\">│   └── bundle*</div><div class=\"line\">├── build/</div><div class=\"line\">│   ├── android/</div><div class=\"line\">│   ├── android-inline.zip</div><div class=\"line\">│   ├── android.zip</div><div class=\"line\">│   ├── ios/</div><div class=\"line\">│   ├── ios-inline.zip</div><div class=\"line\">│   └── ios.zip</div><div class=\"line\">├── gulpfile.js</div><div class=\"line\">├── index.android.js</div><div class=\"line\">├── index.ios.js</div><div class=\"line\">├── ios/</div><div class=\"line\">├── mock/</div><div class=\"line\">│   ├── async/</div><div class=\"line\">│   └── uploads/</div><div class=\"line\">├── ngrok.cfg*</div><div class=\"line\">├── package/</div><div class=\"line\">│   ├── core/</div><div class=\"line\">│   └── lib/</div><div class=\"line\">└── package.json</div></pre></td></tr></table></figure>\n<h4 id=\"1-app目录\"><a href=\"#1-app目录\" class=\"headerlink\" title=\"1. app目录\"></a>1. <code>app</code>目录</h4><p>React Native 源代码目录,其中:</p>\n<ul>\n<li><p><code>components</code> 目录</p>\n<blockquote>\n<p>该目录是组件目录,单独抽离封装可被重用的组件存在该目录底下,每个组件单独管理组件的逻辑,样式,和组件所依赖的图片资源。</p>\n</blockquote>\n</li>\n<li><p><code>containers</code>目录</p>\n<blockquote>\n<p>容器组件目录/基类存放目录,目前整个React Native中的页面都会继承该目录底下的Base类,这个基类用来同步React Native的生命周期给Native端。并定义一些通用的方法或者绑定和解绑全局事件。</p>\n</blockquote>\n</li>\n<li><p><code>lib</code>目录</p>\n<blockquote>\n<p>该目录存放了整个React Native项目中用到的基础工具方法。如:base64编码解码,cdn图片的尺寸裁剪,封装好的异步请求接口(会根据RN运行环境选择使用客户端提供的请求和使用RN自带的请求方法),Strorage本地存储,环境选择等工具方法。</p>\n</blockquote>\n</li>\n<li><p><code>screens</code> 目录</p>\n<blockquote>\n<p>该目录存放React Native页面的入口文件,一个页面对应一个入口文件。</p>\n</blockquote>\n</li>\n<li><p><code>styles</code>目录</p>\n<blockquote>\n<p>该目录存放全局的样式配置和不同平台不同屏幕大小的样式兼容处理方法mixin。</p>\n</blockquote>\n</li>\n<li><p><code>images</code> 目录</p>\n<blockquote>\n<p>本地图片存放目录</p>\n</blockquote>\n</li>\n<li><p><code>network</code>目录 </p>\n<blockquote>\n<p>测试资源存放目录 </p>\n</blockquote>\n</li>\n<li><p><code>config.js</code>文件 </p>\n<blockquote>\n<p>项目全局配置文件,包括平台判断,全局字体颜色,背景颜色,屏幕的高宽等等。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"2-package目录\"><a href=\"#2-package目录\" class=\"headerlink\" title=\"2. package目录\"></a>2. <code>package</code>目录</h4><p>该目录存放了前端构建任务代码,包括前端数据mock,上传七牛,git版本校验等。</p>\n<ul>\n<li><p><code>core</code> 目录</p>\n<blockquote>\n<p>存放核心任务代码,任务命名规则<code>&#39;core.&#39; + 任务文件名 + &#39;:具体任务名&#39;</code>,例如<code>qiniu.js</code>里的上传任务名称<code>core.qiniu:upload</code>。这样的命名好处在于能够在<code>gulpfile.js</code>文件中通过任务名称快速的定位到任务逻辑代码所在的具体文件。</p>\n</blockquote>\n</li>\n<li><p><code>lib</code> 目录</p>\n<blockquote>\n<p>前端打包体系所依赖的一些工具方法所在的目录。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"3-mock目录\"><a href=\"#3-mock目录\" class=\"headerlink\" title=\"3. mock目录\"></a>3. <code>mock</code>目录</h4><p>异步数据mock文件所在的目录</p>\n<ul>\n<li><p><code>async</code>目录</p>\n<blockquote>\n<p>异步数据mock文件存放目录,文件内容格式如下:</p>\n</blockquote>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\">    异步请求接口定义方式</div><div class=\"line\">    'request_method inteface_name' : request handle function</div><div class=\"line\">  */</div><div class=\"line\">  <span class=\"string\">'get /rest/user'</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>) </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">   &#125;,</div><div class=\"line\">  <span class=\"comment\">/*</span></div><div class=\"line\">    文件上传mock</div><div class=\"line\">    'request_method inteface_name file' : request handle function</div><div class=\"line\">  */</div><div class=\"line\">  <span class=\"string\">'post /api/contact/import/ file'</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req,res</span>) </span>&#123;</div><div class=\"line\">  </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p><code>upload</code>目录 </p>\n<blockquote>\n<p>上传后的文件所在目录。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"4-bin目录\"><a href=\"#4-bin目录\" class=\"headerlink\" title=\"4. bin目录\"></a>4. <code>bin</code>目录</h4><p>React Native打包命令所在的目录,打包后的文件存放在build目录中。<a href=\"https://github.com/xdimh/react-native-bundle\" target=\"_blank\" rel=\"external\">参考RN打包工具</a></p>\n<h3 id=\"React-Native-与-Native的通信\"><a href=\"#React-Native-与-Native的通信\" class=\"headerlink\" title=\"React Native 与 Native的通信\"></a>React Native 与 Native的通信</h3><p>在RN和Native的一个混合应用场景下,RN和Native的通信必不可少,具体形式如下:</p>\n<ol>\n<li><p>Native -&gt; RN </p>\n<ul>\n<li>方式一: Native 通过一定的方式<a href=\"https://reactnative.cn/docs/0.41/communication-ios.html#content\" target=\"_blank\" rel=\"external\">[参考在原生和React Native间通信]</a><br>将需要传给RN的数据作为RN页面初始化属性注入,在RN中可以通过<code>this.props.properties</code>进行访问。</li>\n<li>方式二: Native 通过emit事件的方式将数据传递给RN端。RN端通过<code>DeviceEventEmitter.addListener(&#39;reloadPageEvent&#39;, this.reloadPage.bind(this));</code>绑定事件,Native端emit对应的事件。</li>\n<li>方式三:Callback,RN调用Native提供的桥接方法,并传入相应的Callback,最终Native会调用这个回调,并传递相应的数据给RN端。</li>\n</ul>\n</li>\n<li><p>RN -&gt; Native</p>\n<blockquote>\n<p>通过Native提供的桥接方法,RN使用Native的功能并把Native需要的参数传递个Native,最后通过Callback的方式或者事件的方式将结果告知RN。</p>\n</blockquote>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Native Bridges</span></div><div class=\"line\"><span class=\"keyword\">const</span> RNView = NativeModules.IMYRNView || &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">const</span> RNBridgeManager = NativeModules.IMYRNBridgeManager || &#123;&#125;;</div><div class=\"line\"><span class=\"comment\">//然后可以通过RNBridgeManager.method直接调用。</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"React-Native-代码调试\"><a href=\"#React-Native-代码调试\" class=\"headerlink\" title=\"React Native 代码调试\"></a>React Native 代码调试</h3><p><code>React Native</code> 的代码调试相比纯web来说要没那么方便些,特别是在和Native对接代码调试那块。对于RN自己这边的代码相比web调试起来差别不是特别大。具体方式ios模拟器(android类似)<code>command + d</code>,打开设置项:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/rn_debug.png\" alt=\"React Native代码调试\"></p>\n<p>启动远程JS调试,启动远程代码调试,可以对代码设置断点,进行断点调试:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/rn_debug_breakpoint.png\" alt=\"React Native 代码断点调试\"></p>\n<p>同时你可以打开hot reload 功能,这样代码修改,界面就能自动reload,实时看到效果,提高开发调试效率。这个过程对前端开发同学来说比较熟悉,一般出现的问题也很好定位和修改。</p>\n<p>对于React Native 和 Native 进行联调就相对来说就要复杂些,由于业务需要,RN 往往需要 Native提供相应的桥接方法,让RN可以使用Native的某些功能。但调试起来却不太方便,在项目开发阶段,这个过程算是比较费时的,如下两种方式正是我们现在所使用的方式:</p>\n<ul>\n<li>方式一<blockquote>\n<p>RN这边将写好的代码打包成bundle,然后交给Native同学去看,如果有问题(RN这边往往需要console.log输出信息),Native的同学断点定位,判断问题出现在Native端还是RN端,再由接锅的一方修改,然后重复此过程直到功能正常。</p>\n</blockquote>\n</li>\n<li>方式二<blockquote>\n<p>Native给出一个分支,这个分支专门用于和RN进行联调,Native的同学往往需要在这个分支上做一些特殊配置,比如RN的bundle包读取位置不在是本地而是一个url如:<code>http://192.168.199.115:8081/index.ios.bundle?platform=ios</code>,RN端只需要通过<code>node node_modules/react-native/local-cli/cli.js start</code>启动服务。然后开启Xcode,debug模式启动项目,这样就可以在RN这边单独进行联调,问题的定位,如果确实是Native的问题,再告知Native同学进行修改。</p>\n</blockquote>\n</li>\n</ul>\n<p>其中方式二还是从一定程度上提高了React Native 和 Native 端联调的效率。</p>\n<h3 id=\"React-Native-代码打包\"><a href=\"#React-Native-代码打包\" class=\"headerlink\" title=\"React Native 代码打包\"></a>React Native 代码打包</h3><p><a href=\"https://github.com/xdimh/react-native-bundle\" target=\"_blank\" rel=\"external\">参考RN打包工具</a></p>\n<h3 id=\"React-Native-Zip包下发\"><a href=\"#React-Native-Zip包下发\" class=\"headerlink\" title=\"React Native Zip包下发\"></a>React Native Zip包下发</h3><p>让React Native实现app真正的热更新功能就需要RN的代码每次版本更新时可以通过网络下发到app上,从而不用app重新打包发布。Native获取到新的React Native包逻辑大致如下图:</p>\n<p><img src=\"http://rainypin.qiniudn.com/git_imgs/zip-load-flow.png\" alt=\"Native获取zip包大致逻辑\"></p>\n<p>局限性: 如果RN端的修改需要依赖到Native提供新的bridge,这样客户端也不得不重新进行打包发布。</p>\n<p>RN版本更新需要对door开关进行配置,具体格式如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"list\"</span> : [&#123;</div><div class=\"line\">        <span class=\"string\">\"rnname\"</span>: <span class=\"string\">\"projectName1\"</span>, <span class=\"comment\">//RN项目名称 </span></div><div class=\"line\">        <span class=\"string\">\"rnversion\"</span>: <span class=\"string\">\"1.0.1\"</span>, <span class=\"comment\">//RN版本</span></div><div class=\"line\">        <span class=\"string\">\"rnurl\"</span>: <span class=\"string\">\"https://hostname/projectName1/path/1.0.1/ios.zip\"</span> <span class=\"comment\">//RN最新zip包路径</span></div><div class=\"line\">    &#125;, &#123;</div><div class=\"line\">        <span class=\"string\">\"rnname\"</span>: <span class=\"string\">\"projectName2\"</span>,</div><div class=\"line\">        <span class=\"string\">\"rnversion\"</span>: <span class=\"string\">\"1.0.1\"</span>,</div><div class=\"line\">        <span class=\"string\">\"rnurl\"</span>: <span class=\"string\">\"https://hostname/projectName1/path/1.0.1/ios.zip\"</span></div><div class=\"line\">    &#125;]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>发版的时候只需更新<code>rnversion</code>字段就行,通过数组方式支持多个bundle包,不同的bundle包通过rnname进行区分,这种方式还可以更新特定的bundle而不会影响到其他RN页面。</p>\n<h3 id=\"React-Native-版本升级方案【待做】\"><a href=\"#React-Native-版本升级方案【待做】\" class=\"headerlink\" title=\"React Native 版本升级方案【待做】\"></a>React Native 版本升级方案【待做】</h3><p>React Native现在几乎是一个月出一个小版本,当前版本已经是<code>0.41</code>,可见社区还是很活跃的,也可以看到React Native还是逐渐在完善,有些功能甚至一些参数选项都不太稳定,没准在下一个版本某个组件的选项就会被废弃,某个方法参数就有可能被调整,所以对于版本升级来说,这会照成一些代码兼容性的问题,升级后原有的代码不一定就能跑通,但从新版RN代码更完善的功能,更少的bug,以及以后开源的RN的组件都可能是基于高版本RN而开发的情况,我们都应该有个理想的版本的升级方法,在需要的时候进行版本的升级。</p>\n"},{"title":"升级项目中的 webpack1.x 到 webpack2.x , 完善项目构建打包 - 测试","type":"original","date":"2017-05-08T08:50:17.000Z","description":"webpack 是当下最热门的前端资源模块化打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分割。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJS 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。现在 webpack 版本已经到了2.x,写法改变了不少,但是也带来了更好的特性,所以还是赶紧升级项目中的webpack吧。这篇文章将带你逐步从webpack1.x 升级到 webpack2.x,并提供完善你自己打包构建任务的一些思路。","_content":"## webpack 中模块解析\n\n在webpack中,webpack解析如下三种类型的文件路径:\n\n* 绝对路径\n\n    ```JavaScript\n    import \"/home/me/file\";\n    import \"C:\\\\Users\\\\me\\\\file\";\n    ```\n    这种情况因为已经是绝对路径,webpack只需要去对应的路径加载解析模块即可,无需额外的路径解析。\n    \n* 相对路径\n\n  ```JavaScript\n  import \"../src/file1\";\n  import \"./file2\";\n\n  ```\n  当前文件所在的目录为相对路径的上下文目录,通过join 当前文件所在目录和 import 或者 require 指定的目录来获得模块的绝对路径,从而可以正确加载和解析引入的模块。\n  \n* 模块路径\n \n  ```javascript\n  import \"module\";\n  import \"module/lib/file\";\n\n  ```\n  如果是模块路径的话,webpack会在 ``resolve.modules`` 指定的目录中搜索,同时会查看 ``resolve.alias``的别名设置,如果设置了对应的别名还会进行相应的别名替换,具体详细的替换规则参看官方文档[resolve alias](https://webpack.js.org/configuration/resolve/#resolve-alias)。当然这种模块引入方式,最后会去``node_modules``中搜索对应的模块。 \n  \n  一旦根据上面的规则得到了模块的路径,webpack 模块解析器会根据下面两种情况进行相应的模块加载:\n  \n  1. 如果模块路径指向文件\n  \n        * 如果路径包含文件扩展名,那么直接打包指定的模块内容。\n       \n        * 如果文件扩展名未指定,则会去查看 ``resolve.extension`` 的配置,解析器会尝试去寻找文件的扩展名为``resolve.extension``指定值的模块文件。__注意:如果你不想配置可选扩展名,那么可以通过设置``resolve.enforceExtension``为 true 强制提供文件扩展名__\n        \n  2. 如果模块路径指向一个目录\n     \n     * 如果该目录底下存在 package.json 文件,然后会查看 ``resolve.mainFields`` 的配置,按照配置的字段顺序,去package.json 文件中找,找到哪个就是哪个,具体参看官方文档[resolve.mainFields](https://webpack.js.org/configuration/resolve/#resolve-mainfields)。\n     \n     * 如果不存在 package.json 文件,或者是 ``resolve.mainFields`` 指定的文件路径不正确,解析器则会依次去搜索 ``resolve.mainFiles`` 指定的文件名称,按顺序找到哪个算哪个。默认值为``mainFiles: [\"index\"]``\n     \n     * 文件扩展名和前面一样,使用``resolve.extensions``选项。\n  \n  \n  \n  ## webpack1.x 到 webpack2.x 变化的地方\n  \n  * resolve.root, resolve.fallback, resolve.modulesDirectories 被一个单独的选项 resolve.modules 取代。\n  \n  ```JavaScript\n    \n      resolve: {\n      -    extensions: ['', '.js', '.jsx', '.scss'],\n      -    alias: {},\n      -    root: [\n      +    extensions: ['.js', '.jsx', '.scss'],\n      +    alias: {\n      +      echarts$ : path.resolve(__dirname, '../src/base/echarts-3.5.4.js')\n      +    },\n      +    modules: [\n             path.resolve('src'),\n      -      path.resolve('src/components')\n      +      path.resolve('src/components'),\n      +      'node_modules'\n           ]\n      -  }\n      \n  ```\n    \n  * module.loaders 改为 module.rules\n  \n    ```JavaScript\n      module: {\n    -   loaders: [\n    +   rules: [\n          {\n            test: /\\.css$/,\n    -       loaders: [\n    -         \"style-loader\",\n    -         \"css-loader?modules=true\"\n    +       use: [\n    +         {\n    +           loader: \"style-loader\"\n    +         },\n    +         {\n    +           loader: \"css-loader\",\n    +           options: {\n    +             modules: true\n    +           }\n    +         }\n            ]\n          }]\n     }\n     \n    ```\n  \n  * 取消「在模块名中自动添加 -loader 后缀」\n    \n    在引用loader的是候默认不能省略loader后缀,除非按如下方式显示指明:\n    \n    ```\n    + resolveLoader: {\n    +   moduleExtensions: [\"-loader\"]\n    + }\n    ```\n    所以像之前的 babel-loader, 都不能写成babel 需要显示写成babel-loader。\n    \n  * OccurrenceOrderPlugin\n    \n    将短的id分配给使用频率高的模块,webpack2对此插件会默认加载,所以在webpack2 配置文件中不需要加载 ``OccurrenceOrderPlugin``。\n  \n  * DedupePlugin \n    \n    去除重复模块,减少bundle的大小,但是webapck2 本身的功能就已经支持了,所以不再需要该插件。\n    \n  * ExtractTextWebpackPlugin - 破坏性改动\n  \n    对于这个插件的使用方式,改动还是很多的:\n    \n    * ExtractTextPlugin.extract\n    \n        对于loader中,webpack2 你需要这么写:\n        \n        ```javascript\n            module: {\n              rules: [\n                {\n                  test: /.css$/,\n            -      loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\", { publicPath: \"/dist\" })\n            +      use: ExtractTextPlugin.extract({\n            +        fallback: \"style-loader\", // 无法提取的样式,最后还是采用内联。\n            +        use: \"css-loader\",\n            +        publicPath: \"/dist\" // 这里可以不提供,默认会使用output中的publicPath, 如果提供了,会优先使用这里的publicPath 指定的值。\n            +      })\n                }\n              ]\n            }\n        ```\n    * new ExtractTextPlugin({options}) \n    \n      在 plugins 中还是需要进行修改,不然打包会出错。\n      \n      ```JavaScript\n      -  new ExtractTextPlugin(\"bundle.css\", { allChunks: true, disable: false })\n      +  new ExtractTextPlugin({\n      +    filename: \"bundle.css\",\n      +    disable: false,\n      +    allChunks: true\n      +  })\n      ]\n      ```\n      \n 关于webpack1.x 到 webpack2.x 更多的变化参看官方文档https://doc.webpack-china.org/guides/migrating/。\n \n ## 代码分割\n \n 最初搭建项目前端架构的时候,没有特别信任webpack的代码分割功能,总觉得webpack不能很好的识别代码中引入的第三方库,并成功提取出来,合并成一个文件。所以对像 ``react``, `react-dom`, ``react-redux``, ``redux``,``zepto``,``echarts``第三方库,都采用UMD(页面标签)引入方式,通过在webpack中配置externals 实现在代码中通过ES6 import 方式进行引入,所以 externals 也是挺乱的:\n \n ```git\n -  externals: {\n -    'Zepto': '$',\n -    'react': 'React',\n -    'React': 'React',\n -    'ReactDOM': 'ReactDOM',\n -    'react-dom': 'ReactDOM',\n -    'react/lib/ReactDOM': 'ReactDOM',\n -    'react/lib/ReactComponentWithPureRenderMixin': 'React.addons.PureRenderMixin',\n -    'ReactRouter': 'ReactRouter',\n -    'Redux': 'Redux',\n -    'ReactRedux': 'ReactRedux',\n -    'echarts': 'echarts'\n    }\n ```\n 但这样会造成一些问题:\n  \n 1. 最后在项目打包发布的时候,第三方库需要自己通过gulp写合并压缩命名的构建任务,导致构建任务复杂化。\n \n 2. 通过UMD方式引入第三方库,需要人为维护第三方库的版本更新,容易造成团队中成员使用的第三方库版本不一致。\n \n所以基于上面的问题,决定通过这次webpack1.x 到 webpack2.x 的升级顺带将第三方库采用CMD方式引入,具体提取抽离交由 webpack 代码分割特性进行处理。webpack 可以完成两类代码分割任务:\n\n#### 1. 分割资源，实现缓存资源和并行加载资源。\n\n   * 分割第三方库(vendor)\n   \n     一个典型的应用程序，会依赖于许多提供框架/功能需求的第三方库代码。不同于应用程序代码，这些第三方库代码不会频繁修改。如果我们将这些库(library)中的代码，保留在与应用程序代码相独立的 bundle 中，我们就可以利用浏览器缓存机制，把这些文件长时间地缓存在用户机器上。\n    \n     webpack 提供了 CommonsChunkPlugin 插件,用于完成第三方JS库的代码分割,具体如下:\n     \n     ```JavaScript\n       // 在 entry 中指定要抽离的第三方 JS 库。\n       entry: {\n         \"vendor\": ['react','react-dom','react-router','redux','react-redux','n-zepto','echarts','moment'],\n         \"bundle\": path.resolve('src/') + '/index.js'\n       }\n        \n       // 在 plugins 中添加 CommonsChunkPlugin 插件,并指定提取出来第三方库文件的名称。\n       plugins : [\n         new webpack.optimize.CommonsChunkPlugin({\n               name: \"vendor\" // 和 entry 中指定的名称对应\n         })\n       ]\n     ```\n     \n   * 分离 CSS \n     \n     在代码中,引入的样式资源,我们可以将样式代码分离到单独的 bundle 中，与应用程序的逻辑分离。 这加强了样式的可缓存性，并且使得浏览器能够并行加载应用程序代码中的样式文件，避免无样式内容造成的闪烁问题。通过 webpack 的 ExtractTextWebpackPlugin 完成样式的提取。具体的用法参看前面的 __ExtractTextWebpackPlugin - 破坏性改动__。\n\n#### 2. 按需加载\n\n对于一个项目,像单页应用,展示首页时往往不需要将所有资源都加载到浏览器端,这样的好处就是能够是减少首屏渲染时间,所以 webpack 提供了相应的方法,让你指定代码分割点,可以实现对应的代码按需加载。这里我们通过 ``require.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String)`` 来定义分割点。\n    \n  * dependencies \n        \n    定义callback执行依赖的模块。\n    \n  * callback \n       \n    当所有dependencies定义的依赖加载完后,callback 就会被执行,require 作为参数传入,在callback中 require 引入的模块都会被合并成一个chunk, 然后在程序用到的时候,动态加载。\n    \n  * errorCallback \n        \n    依赖加载失败回调\n  \n  * chunkName\n     \n    合并后的按需加载块的名称,如果这里不指定,默认会按照output中定义的 filename 定义的名称格式来,其中的 ``[name]`` 被块 ``[id]`` 替换。所以得到的文件名称如下图:\n        \n   ![id加chunkhash:8加version](http://rainypin.qiniudn.com/blog/images/chunk-name.png)\n    \n   指定名称后:\n    \n   ```JavaScript\n    {\n      path: '/home/order-detail', // 订单分析 -> 订单明细\n      onEnter: routeAuths.onSubRouteEnter.bind(routeAuths),\n      getComponents: (nextState, callback) => {\n        require.ensure([], function(require) {\n          callback(null, require('./pages/dashboard/order-detail'))\n        },'order-detail')\n      }\n    }\n   ```\n       \n  ![chunkname加chunkhash:8加version](http://rainypin.qiniudn.com/blog/images/chunk-name-2.png)\n    \n   \n## npm prune 后通过 npm shrinkwrap 锁定依赖包版本\n\n在维护老项目的时候,经常会遇到因为包版本的升级,导致项目打包失败的问题,或者也遇到过,在你电脑上运行没问题的代码,然后在同事电脑上安装完依赖包却报错。因为 npm 包管理工具在安装一个包后,在package.json中记录的版本是一个范围,如下:\n\n![package,json](http://rainypin.qiniudn.com/blog/images/pkg.png)\n\n如上面的 react-router 指定的是2.8.1以上的版本,然后现在可以用的版本已经是 3.x 了,并且有不少的改动,如果别的同事直接 ``npm install`` 安装的 react-router 可能就是最新版本,所以可能就会导致程序运行出错,所以我们可以通过``npm shrinkwrap``命令,生成当前正在使用的包版本信息文件npm-shrinkwrap.json,然后提交到代码仓库,其他同事通过 ``npm install`` 依赖包的时候,会先读取 npm-shrinkwrap.json 版本信息,然后进行安装,这样就能保证每个人电脑上依赖包版本的一致,也使得后面代码的维护更加简单。更多内容可以参考 [npm shrinkwrap 官方说明](https://docs.npmjs.com/cli/shrinkwrap)。\n\n__注:如果执行npm shrinkwrap 命令失败,可能是因为你直接安装了一些依赖包,但并没有记录在package.json文件中导致的,可以通过npm prune移除这些未记录在package.json的包后,再通过npm shrinkwrap 尝试生成版本信息文件。__\n\n\n## 完善项目构建打包 \n\n由于之前项目打包构建针对不同情况的配置直接写在打包任务中,导致构建任务变得复杂,不够清晰,也不便于和后端联调,所以这次对其做了一些调整,前端代码其实主要会根据三种情况进行不同的打包,分别是本地调试,接近发布状态的调试,发布打包,所以针对三种情况分离出特有的配置内容和公共的配置内容如下:\n\n\n![三种情况打包配置](http://rainypin.qiniudn.com/blog/images/webpack.png)\n\n\n三种情况特有配置分别对应文件:local.js , beta.js , release.js。除了特有的配置,文件中还包含了每种情况环境常量,如打包后文件存放路径,publicPath 等。\n\n![打包构建目录结构](http://rainypin.qiniudn.com/blog/images/package.png)\n\nlocal.js, beta.js, release.js 配置内容结构大致如下:\n\n```javascript\n\"use strict\";\n\nconst webpack = require('webpack'),\n      path = require('path'),\n      util = require('../lib/util.js');\n\nlet constants = {\n    // 不同情况环境常量\n};\n\nlet webpackConfig = {\n    // 特有webpack打包配置\n};\n\nmodule.exports = {\n  constants,\n  webpack : webpackConfig\n};\n\n```\n最后在 package.json 加入针对不同情况的打包命令:\n\n```javascript\n\"scripts\": {\n    \"local\": \"gulp build -h\", // 针对本地开发自测打包,同时开启mock服务,相当于gulp build -l -h\n    \"beta\": \"gulp build -b\", // 预发布状态打包测试,会打出sourcemap,便于调试定位问题。\n    \"release\": \"gulp build -r\" // 发布打包,会将打完包的文件发布到cdn上\n}\n```\n\n\n## 参考文档\n\n1. [webpack docs](https://doc.webpack-china.org/) \n2. [npm shrinkwrap](https://docs.npmjs.com/cli/shrinkwrap)\n\n \n","source":"_posts/webpack1-to-webpack2.md","raw":"---\ntitle: '升级项目中的 webpack1.x 到 webpack2.x , 完善项目构建打包 - 测试'\ntype: original\ntags: [webpack]\ncategories: [构建工具,前端大杂烩]\ndate: 2017-05-08 16:50:17\ndescription: webpack 是当下最热门的前端资源模块化打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分割。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJS 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。现在 webpack 版本已经到了2.x,写法改变了不少,但是也带来了更好的特性,所以还是赶紧升级项目中的webpack吧。这篇文章将带你逐步从webpack1.x 升级到 webpack2.x,并提供完善你自己打包构建任务的一些思路。\n---\n## webpack 中模块解析\n\n在webpack中,webpack解析如下三种类型的文件路径:\n\n* 绝对路径\n\n    ```JavaScript\n    import \"/home/me/file\";\n    import \"C:\\\\Users\\\\me\\\\file\";\n    ```\n    这种情况因为已经是绝对路径,webpack只需要去对应的路径加载解析模块即可,无需额外的路径解析。\n    \n* 相对路径\n\n  ```JavaScript\n  import \"../src/file1\";\n  import \"./file2\";\n\n  ```\n  当前文件所在的目录为相对路径的上下文目录,通过join 当前文件所在目录和 import 或者 require 指定的目录来获得模块的绝对路径,从而可以正确加载和解析引入的模块。\n  \n* 模块路径\n \n  ```javascript\n  import \"module\";\n  import \"module/lib/file\";\n\n  ```\n  如果是模块路径的话,webpack会在 ``resolve.modules`` 指定的目录中搜索,同时会查看 ``resolve.alias``的别名设置,如果设置了对应的别名还会进行相应的别名替换,具体详细的替换规则参看官方文档[resolve alias](https://webpack.js.org/configuration/resolve/#resolve-alias)。当然这种模块引入方式,最后会去``node_modules``中搜索对应的模块。 \n  \n  一旦根据上面的规则得到了模块的路径,webpack 模块解析器会根据下面两种情况进行相应的模块加载:\n  \n  1. 如果模块路径指向文件\n  \n        * 如果路径包含文件扩展名,那么直接打包指定的模块内容。\n       \n        * 如果文件扩展名未指定,则会去查看 ``resolve.extension`` 的配置,解析器会尝试去寻找文件的扩展名为``resolve.extension``指定值的模块文件。__注意:如果你不想配置可选扩展名,那么可以通过设置``resolve.enforceExtension``为 true 强制提供文件扩展名__\n        \n  2. 如果模块路径指向一个目录\n     \n     * 如果该目录底下存在 package.json 文件,然后会查看 ``resolve.mainFields`` 的配置,按照配置的字段顺序,去package.json 文件中找,找到哪个就是哪个,具体参看官方文档[resolve.mainFields](https://webpack.js.org/configuration/resolve/#resolve-mainfields)。\n     \n     * 如果不存在 package.json 文件,或者是 ``resolve.mainFields`` 指定的文件路径不正确,解析器则会依次去搜索 ``resolve.mainFiles`` 指定的文件名称,按顺序找到哪个算哪个。默认值为``mainFiles: [\"index\"]``\n     \n     * 文件扩展名和前面一样,使用``resolve.extensions``选项。\n  \n  \n  \n  ## webpack1.x 到 webpack2.x 变化的地方\n  \n  * resolve.root, resolve.fallback, resolve.modulesDirectories 被一个单独的选项 resolve.modules 取代。\n  \n  ```JavaScript\n    \n      resolve: {\n      -    extensions: ['', '.js', '.jsx', '.scss'],\n      -    alias: {},\n      -    root: [\n      +    extensions: ['.js', '.jsx', '.scss'],\n      +    alias: {\n      +      echarts$ : path.resolve(__dirname, '../src/base/echarts-3.5.4.js')\n      +    },\n      +    modules: [\n             path.resolve('src'),\n      -      path.resolve('src/components')\n      +      path.resolve('src/components'),\n      +      'node_modules'\n           ]\n      -  }\n      \n  ```\n    \n  * module.loaders 改为 module.rules\n  \n    ```JavaScript\n      module: {\n    -   loaders: [\n    +   rules: [\n          {\n            test: /\\.css$/,\n    -       loaders: [\n    -         \"style-loader\",\n    -         \"css-loader?modules=true\"\n    +       use: [\n    +         {\n    +           loader: \"style-loader\"\n    +         },\n    +         {\n    +           loader: \"css-loader\",\n    +           options: {\n    +             modules: true\n    +           }\n    +         }\n            ]\n          }]\n     }\n     \n    ```\n  \n  * 取消「在模块名中自动添加 -loader 后缀」\n    \n    在引用loader的是候默认不能省略loader后缀,除非按如下方式显示指明:\n    \n    ```\n    + resolveLoader: {\n    +   moduleExtensions: [\"-loader\"]\n    + }\n    ```\n    所以像之前的 babel-loader, 都不能写成babel 需要显示写成babel-loader。\n    \n  * OccurrenceOrderPlugin\n    \n    将短的id分配给使用频率高的模块,webpack2对此插件会默认加载,所以在webpack2 配置文件中不需要加载 ``OccurrenceOrderPlugin``。\n  \n  * DedupePlugin \n    \n    去除重复模块,减少bundle的大小,但是webapck2 本身的功能就已经支持了,所以不再需要该插件。\n    \n  * ExtractTextWebpackPlugin - 破坏性改动\n  \n    对于这个插件的使用方式,改动还是很多的:\n    \n    * ExtractTextPlugin.extract\n    \n        对于loader中,webpack2 你需要这么写:\n        \n        ```javascript\n            module: {\n              rules: [\n                {\n                  test: /.css$/,\n            -      loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\", { publicPath: \"/dist\" })\n            +      use: ExtractTextPlugin.extract({\n            +        fallback: \"style-loader\", // 无法提取的样式,最后还是采用内联。\n            +        use: \"css-loader\",\n            +        publicPath: \"/dist\" // 这里可以不提供,默认会使用output中的publicPath, 如果提供了,会优先使用这里的publicPath 指定的值。\n            +      })\n                }\n              ]\n            }\n        ```\n    * new ExtractTextPlugin({options}) \n    \n      在 plugins 中还是需要进行修改,不然打包会出错。\n      \n      ```JavaScript\n      -  new ExtractTextPlugin(\"bundle.css\", { allChunks: true, disable: false })\n      +  new ExtractTextPlugin({\n      +    filename: \"bundle.css\",\n      +    disable: false,\n      +    allChunks: true\n      +  })\n      ]\n      ```\n      \n 关于webpack1.x 到 webpack2.x 更多的变化参看官方文档https://doc.webpack-china.org/guides/migrating/。\n \n ## 代码分割\n \n 最初搭建项目前端架构的时候,没有特别信任webpack的代码分割功能,总觉得webpack不能很好的识别代码中引入的第三方库,并成功提取出来,合并成一个文件。所以对像 ``react``, `react-dom`, ``react-redux``, ``redux``,``zepto``,``echarts``第三方库,都采用UMD(页面标签)引入方式,通过在webpack中配置externals 实现在代码中通过ES6 import 方式进行引入,所以 externals 也是挺乱的:\n \n ```git\n -  externals: {\n -    'Zepto': '$',\n -    'react': 'React',\n -    'React': 'React',\n -    'ReactDOM': 'ReactDOM',\n -    'react-dom': 'ReactDOM',\n -    'react/lib/ReactDOM': 'ReactDOM',\n -    'react/lib/ReactComponentWithPureRenderMixin': 'React.addons.PureRenderMixin',\n -    'ReactRouter': 'ReactRouter',\n -    'Redux': 'Redux',\n -    'ReactRedux': 'ReactRedux',\n -    'echarts': 'echarts'\n    }\n ```\n 但这样会造成一些问题:\n  \n 1. 最后在项目打包发布的时候,第三方库需要自己通过gulp写合并压缩命名的构建任务,导致构建任务复杂化。\n \n 2. 通过UMD方式引入第三方库,需要人为维护第三方库的版本更新,容易造成团队中成员使用的第三方库版本不一致。\n \n所以基于上面的问题,决定通过这次webpack1.x 到 webpack2.x 的升级顺带将第三方库采用CMD方式引入,具体提取抽离交由 webpack 代码分割特性进行处理。webpack 可以完成两类代码分割任务:\n\n#### 1. 分割资源，实现缓存资源和并行加载资源。\n\n   * 分割第三方库(vendor)\n   \n     一个典型的应用程序，会依赖于许多提供框架/功能需求的第三方库代码。不同于应用程序代码，这些第三方库代码不会频繁修改。如果我们将这些库(library)中的代码，保留在与应用程序代码相独立的 bundle 中，我们就可以利用浏览器缓存机制，把这些文件长时间地缓存在用户机器上。\n    \n     webpack 提供了 CommonsChunkPlugin 插件,用于完成第三方JS库的代码分割,具体如下:\n     \n     ```JavaScript\n       // 在 entry 中指定要抽离的第三方 JS 库。\n       entry: {\n         \"vendor\": ['react','react-dom','react-router','redux','react-redux','n-zepto','echarts','moment'],\n         \"bundle\": path.resolve('src/') + '/index.js'\n       }\n        \n       // 在 plugins 中添加 CommonsChunkPlugin 插件,并指定提取出来第三方库文件的名称。\n       plugins : [\n         new webpack.optimize.CommonsChunkPlugin({\n               name: \"vendor\" // 和 entry 中指定的名称对应\n         })\n       ]\n     ```\n     \n   * 分离 CSS \n     \n     在代码中,引入的样式资源,我们可以将样式代码分离到单独的 bundle 中，与应用程序的逻辑分离。 这加强了样式的可缓存性，并且使得浏览器能够并行加载应用程序代码中的样式文件，避免无样式内容造成的闪烁问题。通过 webpack 的 ExtractTextWebpackPlugin 完成样式的提取。具体的用法参看前面的 __ExtractTextWebpackPlugin - 破坏性改动__。\n\n#### 2. 按需加载\n\n对于一个项目,像单页应用,展示首页时往往不需要将所有资源都加载到浏览器端,这样的好处就是能够是减少首屏渲染时间,所以 webpack 提供了相应的方法,让你指定代码分割点,可以实现对应的代码按需加载。这里我们通过 ``require.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String)`` 来定义分割点。\n    \n  * dependencies \n        \n    定义callback执行依赖的模块。\n    \n  * callback \n       \n    当所有dependencies定义的依赖加载完后,callback 就会被执行,require 作为参数传入,在callback中 require 引入的模块都会被合并成一个chunk, 然后在程序用到的时候,动态加载。\n    \n  * errorCallback \n        \n    依赖加载失败回调\n  \n  * chunkName\n     \n    合并后的按需加载块的名称,如果这里不指定,默认会按照output中定义的 filename 定义的名称格式来,其中的 ``[name]`` 被块 ``[id]`` 替换。所以得到的文件名称如下图:\n        \n   ![id加chunkhash:8加version](http://rainypin.qiniudn.com/blog/images/chunk-name.png)\n    \n   指定名称后:\n    \n   ```JavaScript\n    {\n      path: '/home/order-detail', // 订单分析 -> 订单明细\n      onEnter: routeAuths.onSubRouteEnter.bind(routeAuths),\n      getComponents: (nextState, callback) => {\n        require.ensure([], function(require) {\n          callback(null, require('./pages/dashboard/order-detail'))\n        },'order-detail')\n      }\n    }\n   ```\n       \n  ![chunkname加chunkhash:8加version](http://rainypin.qiniudn.com/blog/images/chunk-name-2.png)\n    \n   \n## npm prune 后通过 npm shrinkwrap 锁定依赖包版本\n\n在维护老项目的时候,经常会遇到因为包版本的升级,导致项目打包失败的问题,或者也遇到过,在你电脑上运行没问题的代码,然后在同事电脑上安装完依赖包却报错。因为 npm 包管理工具在安装一个包后,在package.json中记录的版本是一个范围,如下:\n\n![package,json](http://rainypin.qiniudn.com/blog/images/pkg.png)\n\n如上面的 react-router 指定的是2.8.1以上的版本,然后现在可以用的版本已经是 3.x 了,并且有不少的改动,如果别的同事直接 ``npm install`` 安装的 react-router 可能就是最新版本,所以可能就会导致程序运行出错,所以我们可以通过``npm shrinkwrap``命令,生成当前正在使用的包版本信息文件npm-shrinkwrap.json,然后提交到代码仓库,其他同事通过 ``npm install`` 依赖包的时候,会先读取 npm-shrinkwrap.json 版本信息,然后进行安装,这样就能保证每个人电脑上依赖包版本的一致,也使得后面代码的维护更加简单。更多内容可以参考 [npm shrinkwrap 官方说明](https://docs.npmjs.com/cli/shrinkwrap)。\n\n__注:如果执行npm shrinkwrap 命令失败,可能是因为你直接安装了一些依赖包,但并没有记录在package.json文件中导致的,可以通过npm prune移除这些未记录在package.json的包后,再通过npm shrinkwrap 尝试生成版本信息文件。__\n\n\n## 完善项目构建打包 \n\n由于之前项目打包构建针对不同情况的配置直接写在打包任务中,导致构建任务变得复杂,不够清晰,也不便于和后端联调,所以这次对其做了一些调整,前端代码其实主要会根据三种情况进行不同的打包,分别是本地调试,接近发布状态的调试,发布打包,所以针对三种情况分离出特有的配置内容和公共的配置内容如下:\n\n\n![三种情况打包配置](http://rainypin.qiniudn.com/blog/images/webpack.png)\n\n\n三种情况特有配置分别对应文件:local.js , beta.js , release.js。除了特有的配置,文件中还包含了每种情况环境常量,如打包后文件存放路径,publicPath 等。\n\n![打包构建目录结构](http://rainypin.qiniudn.com/blog/images/package.png)\n\nlocal.js, beta.js, release.js 配置内容结构大致如下:\n\n```javascript\n\"use strict\";\n\nconst webpack = require('webpack'),\n      path = require('path'),\n      util = require('../lib/util.js');\n\nlet constants = {\n    // 不同情况环境常量\n};\n\nlet webpackConfig = {\n    // 特有webpack打包配置\n};\n\nmodule.exports = {\n  constants,\n  webpack : webpackConfig\n};\n\n```\n最后在 package.json 加入针对不同情况的打包命令:\n\n```javascript\n\"scripts\": {\n    \"local\": \"gulp build -h\", // 针对本地开发自测打包,同时开启mock服务,相当于gulp build -l -h\n    \"beta\": \"gulp build -b\", // 预发布状态打包测试,会打出sourcemap,便于调试定位问题。\n    \"release\": \"gulp build -r\" // 发布打包,会将打完包的文件发布到cdn上\n}\n```\n\n\n## 参考文档\n\n1. [webpack docs](https://doc.webpack-china.org/) \n2. [npm shrinkwrap](https://docs.npmjs.com/cli/shrinkwrap)\n\n \n","slug":"webpack1-to-webpack2","published":1,"updated":"2018-02-26T15:44:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cje4gdhrh001hb37qxi9bik3t","content":"<h2 id=\"webpack-中模块解析\"><a href=\"#webpack-中模块解析\" class=\"headerlink\" title=\"webpack 中模块解析\"></a>webpack 中模块解析</h2><p>在webpack中,webpack解析如下三种类型的文件路径:</p>\n<ul>\n<li><p>绝对路径</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"/home/me/file\"</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"C:\\\\Users\\\\me\\\\file\"</span>;</div></pre></td></tr></table></figure>\n<p>  这种情况因为已经是绝对路径,webpack只需要去对应的路径加载解析模块即可,无需额外的路径解析。</p>\n</li>\n<li><p>相对路径</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"../src/file1\"</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"./file2\"</span>;</div></pre></td></tr></table></figure>\n<p>当前文件所在的目录为相对路径的上下文目录,通过join 当前文件所在目录和 import 或者 require 指定的目录来获得模块的绝对路径,从而可以正确加载和解析引入的模块。</p>\n</li>\n<li><p>模块路径</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"module\"</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"module/lib/file\"</span>;</div></pre></td></tr></table></figure>\n<p>如果是模块路径的话,webpack会在 <code>resolve.modules</code> 指定的目录中搜索,同时会查看 <code>resolve.alias</code>的别名设置,如果设置了对应的别名还会进行相应的别名替换,具体详细的替换规则参看官方文档<a href=\"https://webpack.js.org/configuration/resolve/#resolve-alias\" target=\"_blank\" rel=\"external\">resolve alias</a>。当然这种模块引入方式,最后会去<code>node_modules</code>中搜索对应的模块。 </p>\n<p>一旦根据上面的规则得到了模块的路径,webpack 模块解析器会根据下面两种情况进行相应的模块加载:</p>\n<ol>\n<li><p>如果模块路径指向文件</p>\n<ul>\n<li><p>如果路径包含文件扩展名,那么直接打包指定的模块内容。</p>\n</li>\n<li><p>如果文件扩展名未指定,则会去查看 <code>resolve.extension</code> 的配置,解析器会尝试去寻找文件的扩展名为<code>resolve.extension</code>指定值的模块文件。<strong>注意:如果你不想配置可选扩展名,那么可以通过设置<code>resolve.enforceExtension</code>为 true 强制提供文件扩展名</strong></p>\n</li>\n</ul>\n</li>\n<li><p>如果模块路径指向一个目录</p>\n<ul>\n<li><p>如果该目录底下存在 package.json 文件,然后会查看 <code>resolve.mainFields</code> 的配置,按照配置的字段顺序,去package.json 文件中找,找到哪个就是哪个,具体参看官方文档<a href=\"https://webpack.js.org/configuration/resolve/#resolve-mainfields\" target=\"_blank\" rel=\"external\">resolve.mainFields</a>。</p>\n</li>\n<li><p>如果不存在 package.json 文件,或者是 <code>resolve.mainFields</code> 指定的文件路径不正确,解析器则会依次去搜索 <code>resolve.mainFiles</code> 指定的文件名称,按顺序找到哪个算哪个。默认值为<code>mainFiles: [&quot;index&quot;]</code></p>\n</li>\n<li><p>文件扩展名和前面一样,使用<code>resolve.extensions</code>选项。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"webpack1-x-到-webpack2-x-变化的地方\"><a href=\"#webpack1-x-到-webpack2-x-变化的地方\" class=\"headerlink\" title=\"webpack1.x 到 webpack2.x 变化的地方\"></a>webpack1.x 到 webpack2.x 变化的地方</h2><ul>\n<li><p>resolve.root, resolve.fallback, resolve.modulesDirectories 被一个单独的选项 resolve.modules 取代。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">    </div><div class=\"line\">resolve: &#123;</div><div class=\"line\">-    extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.jsx'</span>, <span class=\"string\">'.scss'</span>],</div><div class=\"line\">-    alias: &#123;&#125;,</div><div class=\"line\">-    root: [</div><div class=\"line\">+    extensions: [<span class=\"string\">'.js'</span>, <span class=\"string\">'.jsx'</span>, <span class=\"string\">'.scss'</span>],</div><div class=\"line\">+    alias: &#123;</div><div class=\"line\">+      echarts$ : path.resolve(__dirname, <span class=\"string\">'../src/base/echarts-3.5.4.js'</span>)</div><div class=\"line\">+    &#125;,</div><div class=\"line\">+    modules: [</div><div class=\"line\">       path.resolve(<span class=\"string\">'src'</span>),</div><div class=\"line\">-      path.resolve(<span class=\"string\">'src/components'</span>)</div><div class=\"line\">+      path.resolve(<span class=\"string\">'src/components'</span>),</div><div class=\"line\">+      <span class=\"string\">'node_modules'</span></div><div class=\"line\">     ]</div><div class=\"line\">-  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>module.loaders 改为 module.rules</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">-   loaders: [</div><div class=\"line\">+   rules: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</div><div class=\"line\">-       loaders: [</div><div class=\"line\">-         <span class=\"string\">\"style-loader\"</span>,</div><div class=\"line\">-         <span class=\"string\">\"css-loader?modules=true\"</span></div><div class=\"line\">+       use: [</div><div class=\"line\">+         &#123;</div><div class=\"line\">+           loader: <span class=\"string\">\"style-loader\"</span></div><div class=\"line\">+         &#125;,</div><div class=\"line\">+         &#123;</div><div class=\"line\">+           loader: <span class=\"string\">\"css-loader\"</span>,</div><div class=\"line\">+           options: &#123;</div><div class=\"line\">+             modules: <span class=\"literal\">true</span></div><div class=\"line\">+           &#125;</div><div class=\"line\">+         &#125;</div><div class=\"line\">        ]</div><div class=\"line\">      &#125;]</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>取消「在模块名中自动添加 -loader 后缀」</p>\n<p>在引用loader的是候默认不能省略loader后缀,除非按如下方式显示指明:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ resolveLoader: &#123;</div><div class=\"line\">+   moduleExtensions: [&quot;-loader&quot;]</div><div class=\"line\">+ &#125;</div></pre></td></tr></table></figure>\n<p>所以像之前的 babel-loader, 都不能写成babel 需要显示写成babel-loader。</p>\n</li>\n<li><p>OccurrenceOrderPlugin</p>\n<p>将短的id分配给使用频率高的模块,webpack2对此插件会默认加载,所以在webpack2 配置文件中不需要加载 <code>OccurrenceOrderPlugin</code>。</p>\n</li>\n<li><p>DedupePlugin </p>\n<p>去除重复模块,减少bundle的大小,但是webapck2 本身的功能就已经支持了,所以不再需要该插件。</p>\n</li>\n<li><p>ExtractTextWebpackPlugin - 破坏性改动</p>\n<p>对于这个插件的使用方式,改动还是很多的:</p>\n<ul>\n<li><p>ExtractTextPlugin.extract</p>\n<p>  对于loader中,webpack2 你需要这么写:</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">rules</span>: [</div><div class=\"line\">    &#123;</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/.css$/</span>,</div><div class=\"line\">-      loader: ExtractTextPlugin.extract(<span class=\"string\">\"style-loader\"</span>, <span class=\"string\">\"css-loader\"</span>, &#123; <span class=\"attr\">publicPath</span>: <span class=\"string\">\"/dist\"</span> &#125;)</div><div class=\"line\">+      use: ExtractTextPlugin.extract(&#123;</div><div class=\"line\">+        fallback: <span class=\"string\">\"style-loader\"</span>, <span class=\"comment\">// 无法提取的样式,最后还是采用内联。</span></div><div class=\"line\">+        use: <span class=\"string\">\"css-loader\"</span>,</div><div class=\"line\">+        publicPath: <span class=\"string\">\"/dist\"</span> <span class=\"comment\">// 这里可以不提供,默认会使用output中的publicPath, 如果提供了,会优先使用这里的publicPath 指定的值。</span></div><div class=\"line\">+      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>new ExtractTextPlugin({options}) </p>\n<p>在 plugins 中还是需要进行修改,不然打包会出错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">-  <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">\"bundle.css\"</span>, &#123; <span class=\"attr\">allChunks</span>: <span class=\"literal\">true</span>, <span class=\"attr\">disable</span>: <span class=\"literal\">false</span> &#125;)</div><div class=\"line\">+  <span class=\"keyword\">new</span> ExtractTextPlugin(&#123;</div><div class=\"line\">+    filename: <span class=\"string\">\"bundle.css\"</span>,</div><div class=\"line\">+    disable: <span class=\"literal\">false</span>,</div><div class=\"line\">+    allChunks: <span class=\"literal\">true</span></div><div class=\"line\">+  &#125;)</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p> 关于webpack1.x 到 webpack2.x 更多的变化参看官方文档<a href=\"https://doc.webpack-china.org/guides/migrating/。\" target=\"_blank\" rel=\"external\">https://doc.webpack-china.org/guides/migrating/。</a></p>\n<h2 id=\"代码分割\"><a href=\"#代码分割\" class=\"headerlink\" title=\"代码分割\"></a>代码分割</h2><p> 最初搭建项目前端架构的时候,没有特别信任webpack的代码分割功能,总觉得webpack不能很好的识别代码中引入的第三方库,并成功提取出来,合并成一个文件。所以对像 <code>react</code>, <code>react-dom</code>, <code>react-redux</code>, <code>redux</code>,<code>zepto</code>,<code>echarts</code>第三方库,都采用UMD(页面标签)引入方式,通过在webpack中配置externals 实现在代码中通过ES6 import 方式进行引入,所以 externals 也是挺乱的:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">-  externals: &#123;</div><div class=\"line\">-    &apos;Zepto&apos;: &apos;$&apos;,</div><div class=\"line\">-    &apos;react&apos;: &apos;React&apos;,</div><div class=\"line\">-    &apos;React&apos;: &apos;React&apos;,</div><div class=\"line\">-    &apos;ReactDOM&apos;: &apos;ReactDOM&apos;,</div><div class=\"line\">-    &apos;react-dom&apos;: &apos;ReactDOM&apos;,</div><div class=\"line\">-    &apos;react/lib/ReactDOM&apos;: &apos;ReactDOM&apos;,</div><div class=\"line\">-    &apos;react/lib/ReactComponentWithPureRenderMixin&apos;: &apos;React.addons.PureRenderMixin&apos;,</div><div class=\"line\">-    &apos;ReactRouter&apos;: &apos;ReactRouter&apos;,</div><div class=\"line\">-    &apos;Redux&apos;: &apos;Redux&apos;,</div><div class=\"line\">-    &apos;ReactRedux&apos;: &apos;ReactRedux&apos;,</div><div class=\"line\">-    &apos;echarts&apos;: &apos;echarts&apos;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> 但这样会造成一些问题:</p>\n<ol>\n<li><p>最后在项目打包发布的时候,第三方库需要自己通过gulp写合并压缩命名的构建任务,导致构建任务复杂化。</p>\n</li>\n<li><p>通过UMD方式引入第三方库,需要人为维护第三方库的版本更新,容易造成团队中成员使用的第三方库版本不一致。</p>\n</li>\n</ol>\n<p>所以基于上面的问题,决定通过这次webpack1.x 到 webpack2.x 的升级顺带将第三方库采用CMD方式引入,具体提取抽离交由 webpack 代码分割特性进行处理。webpack 可以完成两类代码分割任务:</p>\n<h4 id=\"1-分割资源，实现缓存资源和并行加载资源。\"><a href=\"#1-分割资源，实现缓存资源和并行加载资源。\" class=\"headerlink\" title=\"1. 分割资源，实现缓存资源和并行加载资源。\"></a>1. 分割资源，实现缓存资源和并行加载资源。</h4><ul>\n<li><p>分割第三方库(vendor)</p>\n<p>一个典型的应用程序，会依赖于许多提供框架/功能需求的第三方库代码。不同于应用程序代码，这些第三方库代码不会频繁修改。如果我们将这些库(library)中的代码，保留在与应用程序代码相独立的 bundle 中，我们就可以利用浏览器缓存机制，把这些文件长时间地缓存在用户机器上。</p>\n<p>webpack 提供了 CommonsChunkPlugin 插件,用于完成第三方JS库的代码分割,具体如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在 entry 中指定要抽离的第三方 JS 库。</span></div><div class=\"line\">entry: &#123;</div><div class=\"line\">  <span class=\"string\">\"vendor\"</span>: [<span class=\"string\">'react'</span>,<span class=\"string\">'react-dom'</span>,<span class=\"string\">'react-router'</span>,<span class=\"string\">'redux'</span>,<span class=\"string\">'react-redux'</span>,<span class=\"string\">'n-zepto'</span>,<span class=\"string\">'echarts'</span>,<span class=\"string\">'moment'</span>],</div><div class=\"line\">  <span class=\"string\">\"bundle\"</span>: path.resolve(<span class=\"string\">'src/'</span>) + <span class=\"string\">'/index.js'</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 在 plugins 中添加 CommonsChunkPlugin 插件,并指定提取出来第三方库文件的名称。</span></div><div class=\"line\">plugins : [</div><div class=\"line\">  <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">\"vendor\"</span> <span class=\"comment\">// 和 entry 中指定的名称对应</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>分离 CSS </p>\n<p>在代码中,引入的样式资源,我们可以将样式代码分离到单独的 bundle 中，与应用程序的逻辑分离。 这加强了样式的可缓存性，并且使得浏览器能够并行加载应用程序代码中的样式文件，避免无样式内容造成的闪烁问题。通过 webpack 的 ExtractTextWebpackPlugin 完成样式的提取。具体的用法参看前面的 <strong>ExtractTextWebpackPlugin - 破坏性改动</strong>。</p>\n</li>\n</ul>\n<h4 id=\"2-按需加载\"><a href=\"#2-按需加载\" class=\"headerlink\" title=\"2. 按需加载\"></a>2. 按需加载</h4><p>对于一个项目,像单页应用,展示首页时往往不需要将所有资源都加载到浏览器端,这样的好处就是能够是减少首屏渲染时间,所以 webpack 提供了相应的方法,让你指定代码分割点,可以实现对应的代码按需加载。这里我们通过 <code>require.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String)</code> 来定义分割点。</p>\n<ul>\n<li><p>dependencies </p>\n<p>定义callback执行依赖的模块。</p>\n</li>\n<li><p>callback </p>\n<p>当所有dependencies定义的依赖加载完后,callback 就会被执行,require 作为参数传入,在callback中 require 引入的模块都会被合并成一个chunk, 然后在程序用到的时候,动态加载。</p>\n</li>\n<li><p>errorCallback </p>\n<p>依赖加载失败回调</p>\n</li>\n<li><p>chunkName</p>\n<p>合并后的按需加载块的名称,如果这里不指定,默认会按照output中定义的 filename 定义的名称格式来,其中的 <code>[name]</code> 被块 <code>[id]</code> 替换。所以得到的文件名称如下图:</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/chunk-name.png\" alt=\"id加chunkhash:8加version\"></p>\n<p>指定名称后:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'/home/order-detail'</span>, <span class=\"comment\">// 订单分析 -&gt; 订单明细</span></div><div class=\"line\">  onEnter: routeAuths.onSubRouteEnter.bind(routeAuths),</div><div class=\"line\">  <span class=\"attr\">getComponents</span>: <span class=\"function\">(<span class=\"params\">nextState, callback</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">      callback(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'./pages/dashboard/order-detail'</span>))</div><div class=\"line\">    &#125;,<span class=\"string\">'order-detail'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  <img src=\"http://rainypin.qiniudn.com/blog/images/chunk-name-2.png\" alt=\"chunkname加chunkhash:8加version\"></p>\n<h2 id=\"npm-prune-后通过-npm-shrinkwrap-锁定依赖包版本\"><a href=\"#npm-prune-后通过-npm-shrinkwrap-锁定依赖包版本\" class=\"headerlink\" title=\"npm prune 后通过 npm shrinkwrap 锁定依赖包版本\"></a>npm prune 后通过 npm shrinkwrap 锁定依赖包版本</h2><p>在维护老项目的时候,经常会遇到因为包版本的升级,导致项目打包失败的问题,或者也遇到过,在你电脑上运行没问题的代码,然后在同事电脑上安装完依赖包却报错。因为 npm 包管理工具在安装一个包后,在package.json中记录的版本是一个范围,如下:</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/pkg.png\" alt=\"package,json\"></p>\n<p>如上面的 react-router 指定的是2.8.1以上的版本,然后现在可以用的版本已经是 3.x 了,并且有不少的改动,如果别的同事直接 <code>npm install</code> 安装的 react-router 可能就是最新版本,所以可能就会导致程序运行出错,所以我们可以通过<code>npm shrinkwrap</code>命令,生成当前正在使用的包版本信息文件npm-shrinkwrap.json,然后提交到代码仓库,其他同事通过 <code>npm install</code> 依赖包的时候,会先读取 npm-shrinkwrap.json 版本信息,然后进行安装,这样就能保证每个人电脑上依赖包版本的一致,也使得后面代码的维护更加简单。更多内容可以参考 <a href=\"https://docs.npmjs.com/cli/shrinkwrap\" target=\"_blank\" rel=\"external\">npm shrinkwrap 官方说明</a>。</p>\n<p><strong>注:如果执行npm shrinkwrap 命令失败,可能是因为你直接安装了一些依赖包,但并没有记录在package.json文件中导致的,可以通过npm prune移除这些未记录在package.json的包后,再通过npm shrinkwrap 尝试生成版本信息文件。</strong></p>\n<h2 id=\"完善项目构建打包\"><a href=\"#完善项目构建打包\" class=\"headerlink\" title=\"完善项目构建打包\"></a>完善项目构建打包</h2><p>由于之前项目打包构建针对不同情况的配置直接写在打包任务中,导致构建任务变得复杂,不够清晰,也不便于和后端联调,所以这次对其做了一些调整,前端代码其实主要会根据三种情况进行不同的打包,分别是本地调试,接近发布状态的调试,发布打包,所以针对三种情况分离出特有的配置内容和公共的配置内容如下:</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/webpack.png\" alt=\"三种情况打包配置\"></p>\n<p>三种情况特有配置分别对应文件:local.js , beta.js , release.js。除了特有的配置,文件中还包含了每种情况环境常量,如打包后文件存放路径,publicPath 等。</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/package.png\" alt=\"打包构建目录结构\"></p>\n<p>local.js, beta.js, release.js 配置内容结构大致如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>),</div><div class=\"line\">      path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>),</div><div class=\"line\">      util = <span class=\"built_in\">require</span>(<span class=\"string\">'../lib/util.js'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> constants = &#123;</div><div class=\"line\">    <span class=\"comment\">// 不同情况环境常量</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> webpackConfig = &#123;</div><div class=\"line\">    <span class=\"comment\">// 特有webpack打包配置</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  constants,</div><div class=\"line\">  <span class=\"attr\">webpack</span> : webpackConfig</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>最后在 package.json 加入针对不同情况的打包命令:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"local\"</span>: <span class=\"string\">\"gulp build -h\"</span>, <span class=\"comment\">// 针对本地开发自测打包,同时开启mock服务,相当于gulp build -l -h</span></div><div class=\"line\">    <span class=\"string\">\"beta\"</span>: <span class=\"string\">\"gulp build -b\"</span>, <span class=\"comment\">// 预发布状态打包测试,会打出sourcemap,便于调试定位问题。</span></div><div class=\"line\">    <span class=\"string\">\"release\"</span>: <span class=\"string\">\"gulp build -r\"</span> <span class=\"comment\">// 发布打包,会将打完包的文件发布到cdn上</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ol>\n<li><a href=\"https://doc.webpack-china.org/\" target=\"_blank\" rel=\"external\">webpack docs</a> </li>\n<li><a href=\"https://docs.npmjs.com/cli/shrinkwrap\" target=\"_blank\" rel=\"external\">npm shrinkwrap</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"webpack-中模块解析\"><a href=\"#webpack-中模块解析\" class=\"headerlink\" title=\"webpack 中模块解析\"></a>webpack 中模块解析</h2><p>在webpack中,webpack解析如下三种类型的文件路径:</p>\n<ul>\n<li><p>绝对路径</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"/home/me/file\"</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"C:\\\\Users\\\\me\\\\file\"</span>;</div></pre></td></tr></table></figure>\n<p>  这种情况因为已经是绝对路径,webpack只需要去对应的路径加载解析模块即可,无需额外的路径解析。</p>\n</li>\n<li><p>相对路径</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"../src/file1\"</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"./file2\"</span>;</div></pre></td></tr></table></figure>\n<p>当前文件所在的目录为相对路径的上下文目录,通过join 当前文件所在目录和 import 或者 require 指定的目录来获得模块的绝对路径,从而可以正确加载和解析引入的模块。</p>\n</li>\n<li><p>模块路径</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"module\"</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"module/lib/file\"</span>;</div></pre></td></tr></table></figure>\n<p>如果是模块路径的话,webpack会在 <code>resolve.modules</code> 指定的目录中搜索,同时会查看 <code>resolve.alias</code>的别名设置,如果设置了对应的别名还会进行相应的别名替换,具体详细的替换规则参看官方文档<a href=\"https://webpack.js.org/configuration/resolve/#resolve-alias\" target=\"_blank\" rel=\"external\">resolve alias</a>。当然这种模块引入方式,最后会去<code>node_modules</code>中搜索对应的模块。 </p>\n<p>一旦根据上面的规则得到了模块的路径,webpack 模块解析器会根据下面两种情况进行相应的模块加载:</p>\n<ol>\n<li><p>如果模块路径指向文件</p>\n<ul>\n<li><p>如果路径包含文件扩展名,那么直接打包指定的模块内容。</p>\n</li>\n<li><p>如果文件扩展名未指定,则会去查看 <code>resolve.extension</code> 的配置,解析器会尝试去寻找文件的扩展名为<code>resolve.extension</code>指定值的模块文件。<strong>注意:如果你不想配置可选扩展名,那么可以通过设置<code>resolve.enforceExtension</code>为 true 强制提供文件扩展名</strong></p>\n</li>\n</ul>\n</li>\n<li><p>如果模块路径指向一个目录</p>\n<ul>\n<li><p>如果该目录底下存在 package.json 文件,然后会查看 <code>resolve.mainFields</code> 的配置,按照配置的字段顺序,去package.json 文件中找,找到哪个就是哪个,具体参看官方文档<a href=\"https://webpack.js.org/configuration/resolve/#resolve-mainfields\" target=\"_blank\" rel=\"external\">resolve.mainFields</a>。</p>\n</li>\n<li><p>如果不存在 package.json 文件,或者是 <code>resolve.mainFields</code> 指定的文件路径不正确,解析器则会依次去搜索 <code>resolve.mainFiles</code> 指定的文件名称,按顺序找到哪个算哪个。默认值为<code>mainFiles: [&quot;index&quot;]</code></p>\n</li>\n<li><p>文件扩展名和前面一样,使用<code>resolve.extensions</code>选项。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"webpack1-x-到-webpack2-x-变化的地方\"><a href=\"#webpack1-x-到-webpack2-x-变化的地方\" class=\"headerlink\" title=\"webpack1.x 到 webpack2.x 变化的地方\"></a>webpack1.x 到 webpack2.x 变化的地方</h2><ul>\n<li><p>resolve.root, resolve.fallback, resolve.modulesDirectories 被一个单独的选项 resolve.modules 取代。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">    </div><div class=\"line\">resolve: &#123;</div><div class=\"line\">-    extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.jsx'</span>, <span class=\"string\">'.scss'</span>],</div><div class=\"line\">-    alias: &#123;&#125;,</div><div class=\"line\">-    root: [</div><div class=\"line\">+    extensions: [<span class=\"string\">'.js'</span>, <span class=\"string\">'.jsx'</span>, <span class=\"string\">'.scss'</span>],</div><div class=\"line\">+    alias: &#123;</div><div class=\"line\">+      echarts$ : path.resolve(__dirname, <span class=\"string\">'../src/base/echarts-3.5.4.js'</span>)</div><div class=\"line\">+    &#125;,</div><div class=\"line\">+    modules: [</div><div class=\"line\">       path.resolve(<span class=\"string\">'src'</span>),</div><div class=\"line\">-      path.resolve(<span class=\"string\">'src/components'</span>)</div><div class=\"line\">+      path.resolve(<span class=\"string\">'src/components'</span>),</div><div class=\"line\">+      <span class=\"string\">'node_modules'</span></div><div class=\"line\">     ]</div><div class=\"line\">-  &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>module.loaders 改为 module.rules</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">-   loaders: [</div><div class=\"line\">+   rules: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</div><div class=\"line\">-       loaders: [</div><div class=\"line\">-         <span class=\"string\">\"style-loader\"</span>,</div><div class=\"line\">-         <span class=\"string\">\"css-loader?modules=true\"</span></div><div class=\"line\">+       use: [</div><div class=\"line\">+         &#123;</div><div class=\"line\">+           loader: <span class=\"string\">\"style-loader\"</span></div><div class=\"line\">+         &#125;,</div><div class=\"line\">+         &#123;</div><div class=\"line\">+           loader: <span class=\"string\">\"css-loader\"</span>,</div><div class=\"line\">+           options: &#123;</div><div class=\"line\">+             modules: <span class=\"literal\">true</span></div><div class=\"line\">+           &#125;</div><div class=\"line\">+         &#125;</div><div class=\"line\">        ]</div><div class=\"line\">      &#125;]</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>取消「在模块名中自动添加 -loader 后缀」</p>\n<p>在引用loader的是候默认不能省略loader后缀,除非按如下方式显示指明:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ resolveLoader: &#123;</div><div class=\"line\">+   moduleExtensions: [&quot;-loader&quot;]</div><div class=\"line\">+ &#125;</div></pre></td></tr></table></figure>\n<p>所以像之前的 babel-loader, 都不能写成babel 需要显示写成babel-loader。</p>\n</li>\n<li><p>OccurrenceOrderPlugin</p>\n<p>将短的id分配给使用频率高的模块,webpack2对此插件会默认加载,所以在webpack2 配置文件中不需要加载 <code>OccurrenceOrderPlugin</code>。</p>\n</li>\n<li><p>DedupePlugin </p>\n<p>去除重复模块,减少bundle的大小,但是webapck2 本身的功能就已经支持了,所以不再需要该插件。</p>\n</li>\n<li><p>ExtractTextWebpackPlugin - 破坏性改动</p>\n<p>对于这个插件的使用方式,改动还是很多的:</p>\n<ul>\n<li><p>ExtractTextPlugin.extract</p>\n<p>  对于loader中,webpack2 你需要这么写:</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>: &#123;</div><div class=\"line\">  <span class=\"attr\">rules</span>: [</div><div class=\"line\">    &#123;</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/.css$/</span>,</div><div class=\"line\">-      loader: ExtractTextPlugin.extract(<span class=\"string\">\"style-loader\"</span>, <span class=\"string\">\"css-loader\"</span>, &#123; <span class=\"attr\">publicPath</span>: <span class=\"string\">\"/dist\"</span> &#125;)</div><div class=\"line\">+      use: ExtractTextPlugin.extract(&#123;</div><div class=\"line\">+        fallback: <span class=\"string\">\"style-loader\"</span>, <span class=\"comment\">// 无法提取的样式,最后还是采用内联。</span></div><div class=\"line\">+        use: <span class=\"string\">\"css-loader\"</span>,</div><div class=\"line\">+        publicPath: <span class=\"string\">\"/dist\"</span> <span class=\"comment\">// 这里可以不提供,默认会使用output中的publicPath, 如果提供了,会优先使用这里的publicPath 指定的值。</span></div><div class=\"line\">+      &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>new ExtractTextPlugin({options}) </p>\n<p>在 plugins 中还是需要进行修改,不然打包会出错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">-  <span class=\"keyword\">new</span> ExtractTextPlugin(<span class=\"string\">\"bundle.css\"</span>, &#123; <span class=\"attr\">allChunks</span>: <span class=\"literal\">true</span>, <span class=\"attr\">disable</span>: <span class=\"literal\">false</span> &#125;)</div><div class=\"line\">+  <span class=\"keyword\">new</span> ExtractTextPlugin(&#123;</div><div class=\"line\">+    filename: <span class=\"string\">\"bundle.css\"</span>,</div><div class=\"line\">+    disable: <span class=\"literal\">false</span>,</div><div class=\"line\">+    allChunks: <span class=\"literal\">true</span></div><div class=\"line\">+  &#125;)</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p> 关于webpack1.x 到 webpack2.x 更多的变化参看官方文档<a href=\"https://doc.webpack-china.org/guides/migrating/。\" target=\"_blank\" rel=\"external\">https://doc.webpack-china.org/guides/migrating/。</a></p>\n<h2 id=\"代码分割\"><a href=\"#代码分割\" class=\"headerlink\" title=\"代码分割\"></a>代码分割</h2><p> 最初搭建项目前端架构的时候,没有特别信任webpack的代码分割功能,总觉得webpack不能很好的识别代码中引入的第三方库,并成功提取出来,合并成一个文件。所以对像 <code>react</code>, <code>react-dom</code>, <code>react-redux</code>, <code>redux</code>,<code>zepto</code>,<code>echarts</code>第三方库,都采用UMD(页面标签)引入方式,通过在webpack中配置externals 实现在代码中通过ES6 import 方式进行引入,所以 externals 也是挺乱的:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">-  externals: &#123;</div><div class=\"line\">-    &apos;Zepto&apos;: &apos;$&apos;,</div><div class=\"line\">-    &apos;react&apos;: &apos;React&apos;,</div><div class=\"line\">-    &apos;React&apos;: &apos;React&apos;,</div><div class=\"line\">-    &apos;ReactDOM&apos;: &apos;ReactDOM&apos;,</div><div class=\"line\">-    &apos;react-dom&apos;: &apos;ReactDOM&apos;,</div><div class=\"line\">-    &apos;react/lib/ReactDOM&apos;: &apos;ReactDOM&apos;,</div><div class=\"line\">-    &apos;react/lib/ReactComponentWithPureRenderMixin&apos;: &apos;React.addons.PureRenderMixin&apos;,</div><div class=\"line\">-    &apos;ReactRouter&apos;: &apos;ReactRouter&apos;,</div><div class=\"line\">-    &apos;Redux&apos;: &apos;Redux&apos;,</div><div class=\"line\">-    &apos;ReactRedux&apos;: &apos;ReactRedux&apos;,</div><div class=\"line\">-    &apos;echarts&apos;: &apos;echarts&apos;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p> 但这样会造成一些问题:</p>\n<ol>\n<li><p>最后在项目打包发布的时候,第三方库需要自己通过gulp写合并压缩命名的构建任务,导致构建任务复杂化。</p>\n</li>\n<li><p>通过UMD方式引入第三方库,需要人为维护第三方库的版本更新,容易造成团队中成员使用的第三方库版本不一致。</p>\n</li>\n</ol>\n<p>所以基于上面的问题,决定通过这次webpack1.x 到 webpack2.x 的升级顺带将第三方库采用CMD方式引入,具体提取抽离交由 webpack 代码分割特性进行处理。webpack 可以完成两类代码分割任务:</p>\n<h4 id=\"1-分割资源，实现缓存资源和并行加载资源。\"><a href=\"#1-分割资源，实现缓存资源和并行加载资源。\" class=\"headerlink\" title=\"1. 分割资源，实现缓存资源和并行加载资源。\"></a>1. 分割资源，实现缓存资源和并行加载资源。</h4><ul>\n<li><p>分割第三方库(vendor)</p>\n<p>一个典型的应用程序，会依赖于许多提供框架/功能需求的第三方库代码。不同于应用程序代码，这些第三方库代码不会频繁修改。如果我们将这些库(library)中的代码，保留在与应用程序代码相独立的 bundle 中，我们就可以利用浏览器缓存机制，把这些文件长时间地缓存在用户机器上。</p>\n<p>webpack 提供了 CommonsChunkPlugin 插件,用于完成第三方JS库的代码分割,具体如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在 entry 中指定要抽离的第三方 JS 库。</span></div><div class=\"line\">entry: &#123;</div><div class=\"line\">  <span class=\"string\">\"vendor\"</span>: [<span class=\"string\">'react'</span>,<span class=\"string\">'react-dom'</span>,<span class=\"string\">'react-router'</span>,<span class=\"string\">'redux'</span>,<span class=\"string\">'react-redux'</span>,<span class=\"string\">'n-zepto'</span>,<span class=\"string\">'echarts'</span>,<span class=\"string\">'moment'</span>],</div><div class=\"line\">  <span class=\"string\">\"bundle\"</span>: path.resolve(<span class=\"string\">'src/'</span>) + <span class=\"string\">'/index.js'</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 在 plugins 中添加 CommonsChunkPlugin 插件,并指定提取出来第三方库文件的名称。</span></div><div class=\"line\">plugins : [</div><div class=\"line\">  <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">        <span class=\"attr\">name</span>: <span class=\"string\">\"vendor\"</span> <span class=\"comment\">// 和 entry 中指定的名称对应</span></div><div class=\"line\">  &#125;)</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>分离 CSS </p>\n<p>在代码中,引入的样式资源,我们可以将样式代码分离到单独的 bundle 中，与应用程序的逻辑分离。 这加强了样式的可缓存性，并且使得浏览器能够并行加载应用程序代码中的样式文件，避免无样式内容造成的闪烁问题。通过 webpack 的 ExtractTextWebpackPlugin 完成样式的提取。具体的用法参看前面的 <strong>ExtractTextWebpackPlugin - 破坏性改动</strong>。</p>\n</li>\n</ul>\n<h4 id=\"2-按需加载\"><a href=\"#2-按需加载\" class=\"headerlink\" title=\"2. 按需加载\"></a>2. 按需加载</h4><p>对于一个项目,像单页应用,展示首页时往往不需要将所有资源都加载到浏览器端,这样的好处就是能够是减少首屏渲染时间,所以 webpack 提供了相应的方法,让你指定代码分割点,可以实现对应的代码按需加载。这里我们通过 <code>require.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String)</code> 来定义分割点。</p>\n<ul>\n<li><p>dependencies </p>\n<p>定义callback执行依赖的模块。</p>\n</li>\n<li><p>callback </p>\n<p>当所有dependencies定义的依赖加载完后,callback 就会被执行,require 作为参数传入,在callback中 require 引入的模块都会被合并成一个chunk, 然后在程序用到的时候,动态加载。</p>\n</li>\n<li><p>errorCallback </p>\n<p>依赖加载失败回调</p>\n</li>\n<li><p>chunkName</p>\n<p>合并后的按需加载块的名称,如果这里不指定,默认会按照output中定义的 filename 定义的名称格式来,其中的 <code>[name]</code> 被块 <code>[id]</code> 替换。所以得到的文件名称如下图:</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/chunk-name.png\" alt=\"id加chunkhash:8加version\"></p>\n<p>指定名称后:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"attr\">path</span>: <span class=\"string\">'/home/order-detail'</span>, <span class=\"comment\">// 订单分析 -&gt; 订单明细</span></div><div class=\"line\">  onEnter: routeAuths.onSubRouteEnter.bind(routeAuths),</div><div class=\"line\">  <span class=\"attr\">getComponents</span>: <span class=\"function\">(<span class=\"params\">nextState, callback</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">require</span>.ensure([], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>) </span>&#123;</div><div class=\"line\">      callback(<span class=\"literal\">null</span>, <span class=\"built_in\">require</span>(<span class=\"string\">'./pages/dashboard/order-detail'</span>))</div><div class=\"line\">    &#125;,<span class=\"string\">'order-detail'</span>)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  <img src=\"http://rainypin.qiniudn.com/blog/images/chunk-name-2.png\" alt=\"chunkname加chunkhash:8加version\"></p>\n<h2 id=\"npm-prune-后通过-npm-shrinkwrap-锁定依赖包版本\"><a href=\"#npm-prune-后通过-npm-shrinkwrap-锁定依赖包版本\" class=\"headerlink\" title=\"npm prune 后通过 npm shrinkwrap 锁定依赖包版本\"></a>npm prune 后通过 npm shrinkwrap 锁定依赖包版本</h2><p>在维护老项目的时候,经常会遇到因为包版本的升级,导致项目打包失败的问题,或者也遇到过,在你电脑上运行没问题的代码,然后在同事电脑上安装完依赖包却报错。因为 npm 包管理工具在安装一个包后,在package.json中记录的版本是一个范围,如下:</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/pkg.png\" alt=\"package,json\"></p>\n<p>如上面的 react-router 指定的是2.8.1以上的版本,然后现在可以用的版本已经是 3.x 了,并且有不少的改动,如果别的同事直接 <code>npm install</code> 安装的 react-router 可能就是最新版本,所以可能就会导致程序运行出错,所以我们可以通过<code>npm shrinkwrap</code>命令,生成当前正在使用的包版本信息文件npm-shrinkwrap.json,然后提交到代码仓库,其他同事通过 <code>npm install</code> 依赖包的时候,会先读取 npm-shrinkwrap.json 版本信息,然后进行安装,这样就能保证每个人电脑上依赖包版本的一致,也使得后面代码的维护更加简单。更多内容可以参考 <a href=\"https://docs.npmjs.com/cli/shrinkwrap\" target=\"_blank\" rel=\"external\">npm shrinkwrap 官方说明</a>。</p>\n<p><strong>注:如果执行npm shrinkwrap 命令失败,可能是因为你直接安装了一些依赖包,但并没有记录在package.json文件中导致的,可以通过npm prune移除这些未记录在package.json的包后,再通过npm shrinkwrap 尝试生成版本信息文件。</strong></p>\n<h2 id=\"完善项目构建打包\"><a href=\"#完善项目构建打包\" class=\"headerlink\" title=\"完善项目构建打包\"></a>完善项目构建打包</h2><p>由于之前项目打包构建针对不同情况的配置直接写在打包任务中,导致构建任务变得复杂,不够清晰,也不便于和后端联调,所以这次对其做了一些调整,前端代码其实主要会根据三种情况进行不同的打包,分别是本地调试,接近发布状态的调试,发布打包,所以针对三种情况分离出特有的配置内容和公共的配置内容如下:</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/webpack.png\" alt=\"三种情况打包配置\"></p>\n<p>三种情况特有配置分别对应文件:local.js , beta.js , release.js。除了特有的配置,文件中还包含了每种情况环境常量,如打包后文件存放路径,publicPath 等。</p>\n<p><img src=\"http://rainypin.qiniudn.com/blog/images/package.png\" alt=\"打包构建目录结构\"></p>\n<p>local.js, beta.js, release.js 配置内容结构大致如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">\"use strict\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>),</div><div class=\"line\">      path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>),</div><div class=\"line\">      util = <span class=\"built_in\">require</span>(<span class=\"string\">'../lib/util.js'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> constants = &#123;</div><div class=\"line\">    <span class=\"comment\">// 不同情况环境常量</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> webpackConfig = &#123;</div><div class=\"line\">    <span class=\"comment\">// 特有webpack打包配置</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  constants,</div><div class=\"line\">  <span class=\"attr\">webpack</span> : webpackConfig</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>最后在 package.json 加入针对不同情况的打包命令:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</div><div class=\"line\">    <span class=\"string\">\"local\"</span>: <span class=\"string\">\"gulp build -h\"</span>, <span class=\"comment\">// 针对本地开发自测打包,同时开启mock服务,相当于gulp build -l -h</span></div><div class=\"line\">    <span class=\"string\">\"beta\"</span>: <span class=\"string\">\"gulp build -b\"</span>, <span class=\"comment\">// 预发布状态打包测试,会打出sourcemap,便于调试定位问题。</span></div><div class=\"line\">    <span class=\"string\">\"release\"</span>: <span class=\"string\">\"gulp build -r\"</span> <span class=\"comment\">// 发布打包,会将打完包的文件发布到cdn上</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ol>\n<li><a href=\"https://doc.webpack-china.org/\" target=\"_blank\" rel=\"external\">webpack docs</a> </li>\n<li><a href=\"https://docs.npmjs.com/cli/shrinkwrap\" target=\"_blank\" rel=\"external\">npm shrinkwrap</a></li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cje4gdhpv000ab37qc875w4xm","category_id":"cje4gdhpu0008b37qg9v7mofd","_id":"cje4gdhq9000gb37qzzoprc1f"},{"post_id":"cje4gdhpl0005b37qgqylbrko","category_id":"cje4gdhpu0008b37qg9v7mofd","_id":"cje4gdhqe000lb37qblmq4zdi"},{"post_id":"cje4gdhq2000bb37q7avld1ce","category_id":"cje4gdhpu0008b37qg9v7mofd","_id":"cje4gdhqj000ob37qnd6bfhdl"},{"post_id":"cje4gdhpn0006b37qu4lv3lvv","category_id":"cje4gdhph0003b37qm3kj55hf","_id":"cje4gdhqq000tb37qp4wv94bn"},{"post_id":"cje4gdhpn0006b37qu4lv3lvv","category_id":"cje4gdhq5000cb37qdsfoc34x","_id":"cje4gdhqu000wb37qefry69gl"},{"post_id":"cje4gdhp50001b37q1rl4rapk","category_id":"cje4gdhph0003b37qm3kj55hf","_id":"cje4gdhqx0010b37q9958n815"},{"post_id":"cje4gdhp50001b37q1rl4rapk","category_id":"cje4gdhq5000cb37qdsfoc34x","_id":"cje4gdhr20014b37q343ztah9"},{"post_id":"cje4gdhqm000pb37qblff9kxm","category_id":"cje4gdhpu0008b37qg9v7mofd","_id":"cje4gdhr60017b37q7hg0h2xu"},{"post_id":"cje4gdhps0007b37q6wqd5srr","category_id":"cje4gdhpu0008b37qg9v7mofd","_id":"cje4gdhrd001cb37q70rpq6gq"},{"post_id":"cje4gdhqy0012b37qub9ghszh","category_id":"cje4gdhpu0008b37qg9v7mofd","_id":"cje4gdhrg001fb37qhjmngw0g"},{"post_id":"cje4gdhq7000eb37q63r57pag","category_id":"cje4gdhqw000zb37qo9sg5fj7","_id":"cje4gdhrm001kb37qqpkqgxim"},{"post_id":"cje4gdhr30015b37qr9kelrw8","category_id":"cje4gdhpu0008b37qg9v7mofd","_id":"cje4gdhrn001mb37qenrg0pvu"},{"post_id":"cje4gdhqa000hb37q1n19fhcq","category_id":"cje4gdhqw000zb37qo9sg5fj7","_id":"cje4gdhro001qb37q1kcuwrgb"},{"post_id":"cje4gdhqg000mb37qe22i97cf","category_id":"cje4gdhph0003b37qm3kj55hf","_id":"cje4gdhro001sb37qkhiibd0h"},{"post_id":"cje4gdhqg000mb37qe22i97cf","category_id":"cje4gdhrg001gb37qkoj8yx91","_id":"cje4gdhrr001vb37qqr2j93b9"},{"post_id":"cje4gdhqr000ub37qo0xcteh7","category_id":"cje4gdhqw000zb37qo9sg5fj7","_id":"cje4gdhrr001wb37qncur00id"},{"post_id":"cje4gdhqu000xb37qpgw9ssd9","category_id":"cje4gdhrp001tb37q3s24vujn","_id":"cje4gdhrv0020b37qwyr341x0"},{"post_id":"cje4gdhr70019b37qlyzvg69e","category_id":"cje4gdhrs001xb37q213qtu0t","_id":"cje4gdhrw0024b37qprx30pcp"},{"post_id":"cje4gdhre001db37qj3e98bh6","category_id":"cje4gdhrs001xb37q213qtu0t","_id":"cje4gdhry0028b37qie4vmffe"},{"post_id":"cje4gdhrh001hb37qxi9bik3t","category_id":"cje4gdhrw0025b37qw8rhhjij","_id":"cje4gdhs1002gb37qe1oj7vmh"},{"post_id":"cje4gdhrh001hb37qxi9bik3t","category_id":"cje4gdhrz002cb37qai1fbyw3","_id":"cje4gdhs2002ib37qgapg98bb"}],"PostTag":[{"post_id":"cje4gdhp50001b37q1rl4rapk","tag_id":"cje4gdhpj0004b37qhc2p5d6j","_id":"cje4gdhq8000fb37qg44jl34w"},{"post_id":"cje4gdhp50001b37q1rl4rapk","tag_id":"cje4gdhpv0009b37q0fgubaxx","_id":"cje4gdhqd000ib37qvpoxdze9"},{"post_id":"cje4gdhpl0005b37qgqylbrko","tag_id":"cje4gdhq5000db37qhco7gecx","_id":"cje4gdhqj000nb37qobe8cqez"},{"post_id":"cje4gdhqa000hb37q1n19fhcq","tag_id":"cje4gdhpj0004b37qhc2p5d6j","_id":"cje4gdhqp000qb37qnt1rbo15"},{"post_id":"cje4gdhqg000mb37qe22i97cf","tag_id":"cje4gdhpv0009b37q0fgubaxx","_id":"cje4gdhqt000vb37qrkdm3e0c"},{"post_id":"cje4gdhpn0006b37qu4lv3lvv","tag_id":"cje4gdhpv0009b37q0fgubaxx","_id":"cje4gdhqw000yb37qx6wejvgx"},{"post_id":"cje4gdhpn0006b37qu4lv3lvv","tag_id":"cje4gdhpj0004b37qhc2p5d6j","_id":"cje4gdhr20013b37qkcvinpni"},{"post_id":"cje4gdhqm000pb37qblff9kxm","tag_id":"cje4gdhq5000db37qhco7gecx","_id":"cje4gdhr50016b37qj3402jl5"},{"post_id":"cje4gdhqy0012b37qub9ghszh","tag_id":"cje4gdhq5000db37qhco7gecx","_id":"cje4gdhrc001bb37q1ddkpi80"},{"post_id":"cje4gdhr30015b37qr9kelrw8","tag_id":"cje4gdhq5000db37qhco7gecx","_id":"cje4gdhrf001eb37q867hyp3q"},{"post_id":"cje4gdhps0007b37q6wqd5srr","tag_id":"cje4gdhqq000sb37qfszot0wg","_id":"cje4gdhrm001jb37qmbjbuarb"},{"post_id":"cje4gdhps0007b37q6wqd5srr","tag_id":"cje4gdhqx0011b37qvftx5xh1","_id":"cje4gdhrm001lb37qtto600qp"},{"post_id":"cje4gdhpv000ab37qc875w4xm","tag_id":"cje4gdhq5000db37qhco7gecx","_id":"cje4gdhrn001pb37q3ih2dp3v"},{"post_id":"cje4gdhq2000bb37q7avld1ce","tag_id":"cje4gdhq5000db37qhco7gecx","_id":"cje4gdhro001rb37qh822iews"},{"post_id":"cje4gdhq7000eb37q63r57pag","tag_id":"cje4gdhrn001ob37qez0x1tcq","_id":"cje4gdhrv001zb37qzhzwgsf6"},{"post_id":"cje4gdhq7000eb37q63r57pag","tag_id":"cje4gdhrq001ub37qpaazdqih","_id":"cje4gdhrv0021b37q22k07ur2"},{"post_id":"cje4gdhqr000ub37qo0xcteh7","tag_id":"cje4gdhrn001ob37qez0x1tcq","_id":"cje4gdhrx0027b37q0udyow16"},{"post_id":"cje4gdhqr000ub37qo0xcteh7","tag_id":"cje4gdhrq001ub37qpaazdqih","_id":"cje4gdhry0029b37qum2m3xeh"},{"post_id":"cje4gdhqu000xb37qpgw9ssd9","tag_id":"cje4gdhrw0026b37qsse9ethu","_id":"cje4gdhrz002bb37q4hcts7wo"},{"post_id":"cje4gdhr70019b37qlyzvg69e","tag_id":"cje4gdhry002ab37qb9t5eqx8","_id":"cje4gdhs1002eb37q4h0v3njt"},{"post_id":"cje4gdhre001db37qj3e98bh6","tag_id":"cje4gdhry002ab37qb9t5eqx8","_id":"cje4gdhs2002hb37qtjfaf60y"},{"post_id":"cje4gdhrh001hb37qxi9bik3t","tag_id":"cje4gdhs1002fb37q3suttw7x","_id":"cje4gdhs2002jb37q68jbqjgc"}],"Tag":[{"name":"JavaScript","_id":"cje4gdhpj0004b37qhc2p5d6j"},{"name":"NodeJS","_id":"cje4gdhpv0009b37q0fgubaxx"},{"name":"前端大杂烩","_id":"cje4gdhq5000db37qhco7gecx"},{"name":"git","_id":"cje4gdhqq000sb37qfszot0wg"},{"name":"npm","_id":"cje4gdhqx0011b37qvftx5xh1"},{"name":"Mongoose","_id":"cje4gdhrn001ob37qez0x1tcq"},{"name":"Mongodb","_id":"cje4gdhrq001ub37qpaazdqih"},{"name":"React","_id":"cje4gdhrw0026b37qsse9ethu"},{"name":"React Native","_id":"cje4gdhry002ab37qb9t5eqx8"},{"name":"webpack","_id":"cje4gdhs1002fb37q3suttw7x"}]}}